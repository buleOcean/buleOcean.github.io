<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础 | JaksonBlog</title><meta name="keywords" content="博客"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础Java概述 程序：计算机执行某些操作解决问题而编写的指令的集合。  Java主要特点 Java语言是面向对象的（oop）。  Java语言是健壮的         —-       Java的强类型机制，异常处理机制，垃圾的自动收集是java程序健壮性的重要保证。  Java语言是跨平台性的。  Java语言是解释类型的。 解释性语言：Javascript，PHP，Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2022/09/01/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="JaksonBlog">
<meta property="og:description" content="Java基础Java概述 程序：计算机执行某些操作解决问题而编写的指令的集合。  Java主要特点 Java语言是面向对象的（oop）。  Java语言是健壮的         —-       Java的强类型机制，异常处理机制，垃圾的自动收集是java程序健壮性的重要保证。  Java语言是跨平台性的。  Java语言是解释类型的。 解释性语言：Javascript，PHP，Java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png">
<meta property="article:published_time" content="2022-09-01T10:52:26.000Z">
<meta property="article:modified_time" content="2022-09-01T10:53:27.375Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/01/Java%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-01 18:53:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://img.wxcha.com/m00/f0/f5/5e3999ad5a8d62188ac5ba8ca32e058f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 连接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">JaksonBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 连接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情连接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-01T10:52:26.000Z" title="发表于 2022-09-01 18:52:26">2022-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-01T10:53:27.375Z" title="更新于 2022-09-01 18:53:27">2022-09-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h2><blockquote>
<p>程序：计算机执行某些操作解决问题而编写的指令的集合。</p>
</blockquote>
<h3 id="Java主要特点"><a href="#Java主要特点" class="headerlink" title="Java主要特点"></a>Java主要特点</h3><ol>
<li><p>Java语言是面向对象的（oop）。</p>
</li>
<li><p>Java语言是健壮的         —-       Java的强类型机制，异常处理机制，垃圾的自动收集是java程序健壮性的重要保证。</p>
</li>
<li><p>Java语言是跨平台性的。</p>
</li>
<li><p>Java语言是解释类型的。</p>
<p>解释性语言：Javascript，PHP，Java       编译性语言： c  &#x2F; c++</p>
<p>解释性语言和编译性语言的区别：</p>
<pre><code>==解释性语言编译后的代码不能直接由机器执行，需要由解释器来执行，编译性语言，编译后的代码可以直接被机器执行。==
</code></pre>
</li>
</ol>
<h3 id="Java运行机制及运行过程"><a href="#Java运行机制及运行过程" class="headerlink" title="Java运行机制及运行过程"></a>Java运行机制及运行过程</h3><blockquote>
<p>jave 核心机制-Java虚拟机（JVM）</p>
<p>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据，内存，寄存器，包含在JDK中。</p>
<p>对于不同的平台，有不同的虚拟机。</p>
<p>Java虚拟机机制同步了底层运行平台的差别，实现了一次编译到处运行。</p>
</blockquote>
<p>运行过程： 将编写的java文件编译为字节码文件，在使用解释器运行。</p>
<h3 id="JDK，JRE，JVM简介"><a href="#JDK，JRE，JVM简介" class="headerlink" title="JDK，JRE，JVM简介"></a>JDK，JRE，JVM简介</h3><ul>
<li><p>JDK基本介绍</p>
<ol>
<li><p>JDK的全称是Java Development Kit(开发者工具包);</p>
<p>JDK &#x3D; JRE + java的开发工具[Java，javac，javadoc，javap]</p>
</li>
<li><p>JDK是提供给开发人员使用的，其中包括了Java的开发工具，也包括了JRE。</p>
</li>
</ol>
</li>
<li><p>JRE基本介绍</p>
<ol>
<li><p>JRE的全称是Java Runtime Environment （Java运行环境）</p>
<p>JRE &#x3D; JVM + java核心类库</p>
</li>
<li><p>包括Java虚拟机和Java程序所需运行的核心类库，如果想运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
</ol>
</li>
</ul>
<h2 id="java开发注意事项和细节说明"><a href="#java开发注意事项和细节说明" class="headerlink" title="java开发注意事项和细节说明"></a>java开发注意事项和细节说明</h2><blockquote>
<ul>
<li>java源文件以.java为扩展名，源文件的基本组成部分是类(class)。</li>
<li>java应用程序的执行入口是main()方法。他有固定的书写格式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] srgs)</span>&#123;。。。。&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>java语言严格区分大小写。</li>
<li>Java语言由一条条语句构成，每个语句以“；”结束。</li>
<li>大括号都是成对出现的。</li>
<li>一个源文件只能有一个public类，其他的类的个数不限。</li>
<li>如果源文件中包含一个public类，则文件名必须按照该类名命名。</li>
<li>一个源文件只能有一个public类，其他的类的个数不限，也可以将main方法写在别的public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</li>
</ul>
</blockquote>
<h2 id="一-java语法"><a href="#一-java语法" class="headerlink" title="一,java语法"></a>一,java语法</h2><h3 id="1-Java转义字符"><a href="#1-Java转义字符" class="headerlink" title="1. Java转义字符"></a>1. Java转义字符</h3><p>常用转义字符：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>\t</td>
<td>一个制表符</td>
<td></td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
<td></td>
</tr>
<tr>
<td>\\</td>
<td>一个反斜杠</td>
<td></td>
</tr>
<tr>
<td>&quot;</td>
<td>一个双引号</td>
<td></td>
</tr>
<tr>
<td>&#39;</td>
<td>一个单引号</td>
<td></td>
</tr>
<tr>
<td>\r</td>
<td>一个回车</td>
<td>比较特殊</td>
</tr>
</tbody></table>
<p>\n是换行符，这并不是java中的规定，而是更广泛的计算机领域中均为此含义。<br>1、提到\n就不能不提\r（回车），下面，详细讲解一下：<br>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；<br>Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车&gt;”，即“\n\r”；<br>Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix&#x2F;Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix&#x2F;Mac下打开的话，在每行的结尾可能会多出一个^M符号。<br>\r回车是将光标移到一行的前面<br>\n是移到下一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Changechar</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;生活你好\r世界&quot;</span>);  <span class="comment">//输出：世界你好</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// \r会使输出光标重新返回改行前面，使后输出的内容覆盖已经输出的内容</span></span><br></pre></td></tr></table></figure>



<h3 id="2-Java注释"><a href="#2-Java注释" class="headerlink" title="2. Java注释"></a>2. Java注释</h3><blockquote>
<p>注释是解释程序的文字，注释提高了代码的可读性，将自己的思想通过注释整理出来，再用代码去体现。</p>
<p>被注释的语句不会被JVM虚拟机执行。</p>
</blockquote>
<h4 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个单行注释</span></span><br></pre></td></tr></table></figure>

<h4 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个多行注释  */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释不能嵌套</li>
</ul>
<h4 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3.文档注释"></a>3.文档注释</h4><blockquote>
<p>文档注释内容可以被JDK所提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类中。</p>
</blockquote>
<p>基本格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@version</span></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>生成对应的文档注释：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -d 生成后放置目录 -author -version 文件名.java</span><br></pre></td></tr></table></figure>

<h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h3><blockquote>
<p>变量是程序的基本组成单位。</p>
<p>变量相当于内存中一个数据存储空间的表示，可以通过变量名访问到变量值。不同的变量，类型不同占用的空间大小也不同。(int占据四个字节，double占据八个字节)</p>
<p>该区域必须先声明，后使用。不允许在同一个作用域中重名。</p>
<p>&#x3D;&#x3D;变量 &#x3D; 变量名 + 值 + 数据类型&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Var</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">	<span class="type">int</span> a;     <span class="comment">//第一种方式</span></span><br><span class="line">    a = <span class="number">520</span>;    <span class="comment">//第二种方式</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">521</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4.数据类型"></a>4.数据类型</h3><blockquote>
<p>每一种数据都定义了明确的数据类型，在内存中分配大小不同的内存空间(字节).</p>
<p>Java数据类型：</p>
<pre><code>1.  基本数据类型：
 * 数值型
   * 整数类型 （byte [1],short [2],int [4],long [8]）
   * 浮点类型 （float [4],double [8]）
 * 字符型 （char [2]存放单个字符）
 * 布尔型 （boolean [1] true，false）
   2. 引用数据类型：
 * 类 class
 * 接口 interface
 * 数组 []
</code></pre>
</blockquote>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><blockquote>
<p>java各整数类型有固定的范围和字段长度，不受具体的os的影响，以保证java程序的可移植性。</p>
<p>java中的&#x3D;&#x3D;整形默认常量为int型&#x3D;&#x3D;，声明long类型常量后需要加 L或者l。</p>
<p>java程序中变量常声明为int型。</p>
</blockquote>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><blockquote>
<p>浮点数在机器的存放形式： 浮点数 &#x3D; 符号位 + 指数位 + 尾数位</p>
<p>java各浮点数类型有固定的范围和字段长度，不受具体的os的影响，以保证java程序的可移植性。</p>
<p>java中的&#x3D;&#x3D;浮点数默认常量为double型&#x3D;&#x3D;，声明float类型常量后需要加 F或者f。</p>
<p>尾数部分可能丢失。</p>
<p>&#x3D;&#x3D;对运算结果是小数的进行相等判断要小心，应该是求两个数的差值的绝对值在某个精度范围内。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(num1 - num2)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><blockquote>
<p>字符类型可以表示单个字符，字符类型是char是两个字节，可以存放汉字，多个字符使用String。</p>
<ul>
<li>字符常量是用单引号括起来的单个字符。</li>
<li>Java允许使用转义字符’\‘来将其后的字符转变为特殊字符型常量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;    <span class="comment">// 表示换行符</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在java中，char的本质就是一个整数，在输出的时候，是unicode码对应的字符。</li>
<li>可以给char赋一个整数，然后在输出的时候会按照对应的unicode字符进行输出。</li>
<li>char类型可以进行运算，相当于一个整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Changechar</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">      	<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line">	System.out.println(c);    <span class="comment">//会输出97所编码的字符</span></span><br><span class="line">      	System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="number">100</span>);   <span class="comment">//得出结果197  </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符型存储到计算机中：</p>
<ul>
<li>‘a’ —&gt; 码值97 —&gt; 转换为二进制 —-&gt;</li>
</ul>
</li>
<li><p>常用编码：</p>
<ul>
<li><p>ASCII: 使用一个字节表示，一共128个字符，实际上可以表示256个字符只使用了128个</p>
</li>
<li><p>Unicode： 固定大小编码，使用两个字节表示，字母和汉字统一都占两个字节。Unicode兼容ASCII</p>
</li>
<li><p>utf-8：大小可变编码，字母使用一个字节，汉字使用三个字节。</p>
</li>
<li><p>gbk： 大小可变，字母使用一个字节，汉字使用两个字节。</p>
</li>
<li><p>gb312：可以表示汉字，gb2312 &lt; gbk。</p>
</li>
<li><p>big5：繁体中文。</p>
<p>​    a</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><blockquote>
<p>布尔类型只允许使用ture和false，无null</p>
<p>boolean类型占一个字节。</p>
<p>boolean类型适用于逻辑运算，一般用于流程控制。</p>
<p>&#x3D;&#x3D;不可以用0或者其他数字代替。&#x3D;&#x3D;</p>
</blockquote>
<h3 id="5-加号的使用"><a href="#5-加号的使用" class="headerlink" title="5. 加号的使用"></a>5. 加号的使用</h3><blockquote>
<p>当左右两边都是数值型时，做加法运算。</p>
<p>当左右两边有一方为字符串时，为拼接运算。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Changechar</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">		System.out.println(<span class="number">100</span> + <span class="number">98</span>);   <span class="comment">//输出加法运算</span></span><br><span class="line">		System.out.println(<span class="string">&quot;100&quot;</span> + <span class="number">98</span>);	<span class="comment">//字符串拼接</span></span><br><span class="line">		System.out.println(<span class="number">100</span> + <span class="number">98</span> + <span class="string">&quot;hello&quot;</span>);    <span class="comment">//先加法再字符串拼接</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello&quot;</span> + <span class="number">100</span> + <span class="number">98</span>); 	<span class="comment">//先字符串拼接，再字符串拼接</span></span><br><span class="line">      	<span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      	<span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">      	System.out.println(a + b); 	<span class="comment">//cahr类型进行运算先转换为int类型，以码值相加</span></span><br><span class="line">          </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="6-基本数据类型转换"><a href="#6-基本数据类型转换" class="headerlink" title="6. 基本数据类型转换"></a>6. 基本数据类型转换</h3><blockquote>
<p>当java程序在进行赋值或者运算时，精度小的类型可以自动转换为精度大的数据类型，这个就是&#x3D;&#x3D;自动类型转换&#x3D;&#x3D;。</p>
<p>数据类型按精度大小排序：</p>
<p>char &lt; int &lt; long &lt; float &lt; double</p>
<p>byte &lt; short &lt; int &lt; long &lt; float &lt; double</p>
</blockquote>
<h4 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h4><blockquote>
<p>当有多种类型的数据混合运算的时候，系统首先将所有数据转换成容量最大的那种数据类型，然后再进行计算。</p>
<p>当把精度大的数据类型赋值给精度小的数据类型时会报错，将精度低的赋值给精度高的是，会自动类型转换。</p>
<p>boolean不参与转换。</p>
<p>&#x3D;&#x3D;byte，short和char他们三者可以计算，在计算时首先转换为int，不论是单独还是混合出现。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给byte类型变量赋值时，先判断该数是否再byte范围中，如果可以就成功</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;               <span class="comment">//short s = 10；</span></span><br><span class="line"><span class="comment">//byte类型精度不足以存放int类型数值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> i;</span><br></pre></td></tr></table></figure>

<p>byte 和 short 类型数据进行运算后，精度会被直接提升到int</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">10</span>；</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b + s; <span class="comment">//byte 和 short 类型数据进行运算后，精度会被直接提升到int</span></span><br></pre></td></tr></table></figure>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><blockquote>
<p>自动类型转换的逆过程，将容量大的数据库类型转换为容量小的数据类型。使用时需要加上强制类型转换符</p>
<p>() 可能造成精度降低或者溢出，要格外小心。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.9</span>;   <span class="comment">//会将小数位删除造成数据丢失</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强制符号只针对最近的操作数有效，往往使用小括号提升优先级</p>
<p>&#x3D;&#x3D;char类型可以保存int类型的常量值，但是不能保存int类型的变量值，需要使用强制类型转换。&#x3D;&#x3D;</p>
<p>byte和short，char类型进行运算的时候，当成int类型处理。</p>
</blockquote>
<h3 id="7-基本数据类型转换为String"><a href="#7-基本数据类型转换为String" class="headerlink" title="7. 基本数据类型转换为String"></a>7. 基本数据类型转换为String</h3><blockquote>
<p>经常需要将基本数据类型转换为字符串，或者将字符串转换为基本数据类型。</p>
<p>基本数据类型转换为字符串只需要将值加上 “ “ .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>String类型转换为基本数据类型需要调用包装类的parseXX方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(<span class="string">&quot;&quot;</span>);    <span class="comment">//如果不能成功转换抛出异常</span></span><br><span class="line">Double.parseDouble(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Float.parseFloat(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Short.parseShort(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Long.ParseLong(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Boolean.parseBoolean(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Byte.ParseByte(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//char类型通过取出字符串类型中的字符得到</span></span><br><span class="line">变量.charAt();</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="8-运算符"><a href="#8-运算符" class="headerlink" title="8. 运算符"></a>8. 运算符</h3><blockquote>
<p>运算符是一种特殊的符号，用以表似乎数据的运算，赋值和比较等。</p>
<p>运算符有：</p>
<p>​	算数运算符，赋值运算符，关系运算符(比较运算符)，逻辑运算符，位运算符，三元运算符</p>
</blockquote>
<h4 id="8-1算数运算符"><a href="#8-1算数运算符" class="headerlink" title="8.1算数运算符"></a>8.1算数运算符</h4><table>
<thead>
<tr>
<th align="center">描述</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">加-两个对象相加</td>
<td>+</td>
</tr>
<tr>
<td align="center">减-得到复数或是一个数减去另一个数</td>
<td>-</td>
</tr>
<tr>
<td align="center">乘-两个数相乘或是返回一个被重复若干次的字符串</td>
<td>*</td>
</tr>
<tr>
<td align="center">除-X除以Y，两个整数相除得到一个浮点数</td>
<td>&#x2F;</td>
</tr>
<tr>
<td align="center">取模-返回除法的余数 本质： a % b &#x3D; a - a &#x2F;b * b</td>
<td>%</td>
</tr>
<tr>
<td align="center">幂-返回x的y次幂</td>
<td>**</td>
</tr>
<tr>
<td align="center">取整数- 向下取接近除数的整数</td>
<td>&#x2F;&#x2F;</td>
</tr>
<tr>
<td align="center">字符串相加</td>
<td>+</td>
</tr>
<tr>
<td align="center">自加运算（分为前加加和后加加）</td>
<td>++</td>
</tr>
<tr>
<td align="center">自减运算（分为前减减和后减减）</td>
<td>–</td>
</tr>
</tbody></table>
<p>如果a%b时a为小数：  a % b &#x3D; a - （int）a &#x2F; b * b</p>
<h4 id="8-2关系运算符"><a href="#8-2关系运算符" class="headerlink" title="8.2关系运算符"></a>8.2关系运算符</h4><blockquote>
<p>关系运算符的结果都是boolean类型的，常常使用在if结构中或者循环结构中。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">等于-比较对象是否相等</td>
<td>&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="center">不等于-比较两个对象是否不相等</td>
<td>!&#x3D;</td>
</tr>
<tr>
<td align="center">大于-返回X是否大于Y</td>
<td>&gt;</td>
</tr>
<tr>
<td align="center">小于-返回X是否小于Y(所有比较运算符返回1为真，返回0表示假)</td>
<td>&lt;</td>
</tr>
<tr>
<td align="center">大于等于-返回X是否大于等于Y</td>
<td>&gt;&#x3D;</td>
</tr>
<tr>
<td align="center">小于等于-返回X是否小于等于Y</td>
<td>&lt;&#x3D;</td>
</tr>
<tr>
<td align="center">检查是否是类的对象(运行类型)</td>
<td>instanceof</td>
</tr>
</tbody></table>
<h4 id="8-3-逻辑运算符"><a href="#8-3-逻辑运算符" class="headerlink" title="8.3 逻辑运算符"></a>8.3 逻辑运算符</h4><blockquote>
<p>用于链接多个条件，最终结果也是个boolean类型的值。</p>
<p>&#x3D;&#x3D;短路效率比较高，只运行短路部分。&#x3D;&#x3D;</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td align="center">|</td>
<td>逻辑或</td>
</tr>
<tr>
<td align="center">^</td>
<td>逻辑异或</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td>短路逻辑与</td>
</tr>
<tr>
<td align="center">||</td>
<td>短路逻辑或</td>
</tr>
<tr>
<td align="center">！</td>
<td>取反</td>
</tr>
</tbody></table>
<h4 id="8-4-赋值运算符"><a href="#8-4-赋值运算符" class="headerlink" title="8.4 赋值运算符"></a>8.4 赋值运算符</h4><blockquote>
<p>赋值运算符就是将某个运算后的值，赋给指定的变量。</p>
<p>基本赋值运算符： &#x3D;</p>
<p>复合赋值运算符： +&#x3D;，-&#x3D;，*&#x3D;，%&#x3D;</p>
<p>复合赋值运算符会进行类型的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">b += <span class="number">2</span> <span class="comment">//  b = (byte)(b + 2)</span></span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td>等于- a&#x3D;1</td>
</tr>
<tr>
<td align="center">+&#x3D;</td>
<td>加法赋值语句-“a+&#x3D;b” &#x3D; “a&#x3D;a+b”</td>
</tr>
<tr>
<td align="center">-&#x3D;</td>
<td>减法赋值语句-“a-&#x3D;b” &#x3D; “a&#x3D;a-b”</td>
</tr>
<tr>
<td align="center">*&#x3D;</td>
<td>乘法赋值语句-“a*&#x3D;b”  &#x3D; “a&#x3D;a*b”</td>
</tr>
<tr>
<td align="center">&#x2F;&#x3D;</td>
<td>除法赋值语句-“a&#x2F;&#x3D;b” &#x3D; “a&#x3D;a&#x2F;b”</td>
</tr>
<tr>
<td align="center">%&#x3D;</td>
<td>取模赋值语句-“a%&#x3D;b” &#x3D; “a&#x3D;a%b”</td>
</tr>
<tr>
<td align="center">**&#x3D;</td>
<td>幂赋值语句-“a* *&#x3D;b” &#x3D; “a&#x3D;a * *b”</td>
</tr>
<tr>
<td align="center">&#x2F;&#x2F;&#x3D;</td>
<td>加法赋值语句-“a&#x2F;&#x2F;&#x3D;b” &#x3D; “a&#x3D;a&#x2F;&#x2F;b”</td>
</tr>
</tbody></table>
<h4 id="8-5-三元运算符"><a href="#8-5-三元运算符" class="headerlink" title="8.5 三元运算符"></a>8.5 三元运算符</h4><blockquote>
<p>条件表达式 ？表达式1 ：表达式2;</p>
<p>如果条件表达式的结果为true，运算后的结果为表达式1；</p>
<p>如果条件表达式的结果为false，运算后的结果为表达式2；</p>
<p>表达式1和表达式2要为可以赋给接收变量的类型(或可以自动转换)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b ？a : b;</span><br></pre></td></tr></table></figure>

<p>可以在三元运算符中使用强转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &gt; b ？(<span class="type">int</span>) <span class="number">1.1</span>: (<span class="type">int</span>)<span class="number">2.2</span>;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="8-6-运算符的优先级"><a href="#8-6-运算符的优先级" class="headerlink" title="8.6 运算符的优先级"></a>8.6 运算符的优先级</h4><blockquote>
<p>运算符具有不同的优先级。</p>
<p>只有单目运算符和赋值运算符是从右向左执行的。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">++  –  ~ !(data type)</td>
<td>R —&gt; L</td>
</tr>
<tr>
<td align="center">*  &#x2F;  %</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">+  -</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">&gt;&gt; &lt;&lt;  &gt;&gt;&gt;</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;    &lt;     &gt;   &gt;&#x3D;  instanceof</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D;   !&#x3D;</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">^</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">|</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">||</td>
<td>L —&gt;  R</td>
</tr>
<tr>
<td align="center">&#x3D;    +&#x3D;   -&#x3D;   *&#x3D; &#x2F;&#x3D;   %&#x3D;   &amp;&#x3D;   ^&#x3D;  &lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &gt;&gt;&gt;&#x3D;</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h4 id="8-7-位运算"><a href="#8-7-位运算" class="headerlink" title="8.7 位运算"></a>8.7 位运算</h4><table>
<thead>
<tr>
<th align="center">运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td>按位与运算符-    参与运算的两个值相应位为1则结果为1，否则为0</td>
</tr>
<tr>
<td align="center">|</td>
<td>按位或运算符-    参与运算的其中一个值为1，结果为1.</td>
</tr>
<tr>
<td align="center">^</td>
<td>按位异或运算符-  当两相应的二进制位相异时，结果为1.</td>
</tr>
<tr>
<td align="center">~</td>
<td>按位取反运算符-  对数据的每个二进制位取反，即把1变为0，把0变为1.</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>左移动运算符-  运算数的各二进制位全部左移若干位由”&lt;&lt;”指定移动的位数。</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>右移动运算符-运算数的各二进制位全部右移若干位由”&lt;&lt;”指定移动的位数。</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td>无符号右移</td>
</tr>
</tbody></table>
<h4 id="8-8-原码，反码，补码"><a href="#8-8-原码，反码，补码" class="headerlink" title="8.8 原码，反码，补码"></a>8.8 原码，反码，补码</h4><blockquote>
<p>二进制的最高位是符号位，0表示正数，1表示负数</p>
<p>正数的源码，补码，反码都一样。(三码合一)</p>
<p>负数的反码 &#x3D; 它的原码除符号位不变，其余位取反。</p>
<p>复数的补码 &#x3D; 它的反码 + 1；  复数的反码 &#x3D; 复数的补码 - 1；</p>
<p>0 的反码，补码都是0.</p>
<p>Java没有无符号数，java中的数都是有符号的。</p>
<p>在计算机运算的时候，都是以补码的方式来运算的。</p>
<p>看运算结果时，要看它的原码。</p>
</blockquote>
<h3 id="9-键盘输入语句"><a href="#9-键盘输入语句" class="headerlink" title="9. 键盘输入语句"></a>9. 键盘输入语句</h3><blockquote>
<p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取&#x2F;</p>
<p>需要一个扫描器，Scanner。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入该类所在的包</span></span><br><span class="line"><span class="comment">//创建该类的对象</span></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;				<span class="comment">//导入该类所在的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Changechar</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">		String name;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//创建该类的对象，传入标准输入流</span></span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">&quot;请输入：&quot;</span>); </span><br><span class="line"></span><br><span class="line">		name = sc.next();				<span class="comment">//使用方法</span></span><br><span class="line"></span><br><span class="line">		System.out.print(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Scanner对象.next()  :        				接收一个字符串</p>
<p>Scanner对象.nextInt()  :				接受一个整数</p>
<p>Scanner对象.nextLong()  :			接收一个长整型  </p>
<p>Scanner对象.nextShort()  :			接收一个短整型</p>
<p>Scanner对象.nextFloat()  :			接收一个单精度</p>
<p>Scanner对象.nextDouble()  :			接收一个双精度</p>
</blockquote>
<h3 id="10-控制结构"><a href="#10-控制结构" class="headerlink" title="10. 控制结构"></a>10. 控制结构</h3><blockquote>
<p>在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句。</p>
<ol>
<li>顺序控制</li>
<li>分支控制</li>
<li>循环控制</li>
</ol>
</blockquote>
<h4 id="10-1-顺序控制"><a href="#10-1-顺序控制" class="headerlink" title="10.1 顺序控制"></a>10.1 顺序控制</h4><blockquote>
<p>程序从上到下逐行的执行，中间没有任何判断和跳转。</p>
<p>向前引用</p>
</blockquote>
<h4 id="10-2-分支控制"><a href="#10-2-分支控制" class="headerlink" title="10.2 分支控制"></a>10.2 分支控制</h4><blockquote>
<p>经过判断指定的条件表达式，达到执行响应代码的作用，分为但分支，双分支和多分支。</p>
<p>分支控制之间可以嵌套执行。</p>
<p>在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支结构成为内层分支外面的分支结构称为外层分支。</p>
<p>if判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行代码块；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">执行代码</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch分支结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量一: 语句一;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量二: 语句二;<span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">case</span> 常量三: 语句三;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量四: 语句四;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:语句;<span class="keyword">break</span>;    <span class="comment">//default后的break不重要，有没有都会退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ol>
<li>表达式数据类型，应该和case后的常量类型一致，或者可以自动转换成可以比较的类型。</li>
<li>switch(表达式) 中的表达式的返回值必须是&#x3D;&#x3D;byte，short，int，char，enum，String&#x3D;&#x3D;。</li>
<li>case后的值必须是常量不能是变量。</li>
<li>break语句用来跳出switch循环，如果没有写会顺序执行到结尾。</li>
</ol>
</blockquote>
<p>分支控制的选择：</p>
<blockquote>
<ul>
<li>如果判断的具体数值不多，而且符合byte，short，int，char，enum，String。</li>
<li>对于区间判断，对结构未boolean类型判断，使用if，if的范围比较广。</li>
</ul>
</blockquote>
<h4 id="10-3-循环控制"><a href="#10-3-循环控制" class="headerlink" title="10.3 循环控制"></a>10.3 循环控制</h4><blockquote>
<p>for循环控制：</p>
<ol>
<li>for关键字，表示循环控制。</li>
<li>for有四要素： 循环变量初始化，循环条件，循环操作，循环变量迭代。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">  循环操作(可以多条语句)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>循环条件是返回一个布尔值的表达式。</li>
<li>如果循环变量初始化定义变量，此变量的适用范围只有for循环中。</li>
<li>for(;循环判断条件;) ，中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略。</li>
<li>循环初始值可以有多条初始化语句，但是要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开。</li>
</ol>
</blockquote>
<blockquote>
<p> while循环控制</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">循环变量初始化;</span><br><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">	循环体;</span><br><span class="line"> 循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意：</p>
<ul>
<li>while也有四要素，只是放置四要素的位置和for循环不一样。</li>
<li>循环条件返回一个布尔值的表达式。</li>
<li>while循环是先判断再循环。</li>
</ul>
</blockquote>
<blockquote>
<p>do-while循环控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体;</span><br><span class="line">循环变量迭代;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件)；</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>do-while循环至少会循环一次。</li>
<li>while也有四要素。</li>
</ul>
</blockquote>
<h3 id="11-跳转控制语句"><a href="#11-跳转控制语句" class="headerlink" title="11. 跳转控制语句"></a>11. 跳转控制语句</h3><blockquote>
<ul>
<li>break语句用于&#x3D;&#x3D;终止某个语句块&#x3D;&#x3D;的执行，一般用于switch和循环中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  …………</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>break语句出现在多层嵌套的语句块中时，可以通过&#x3D;&#x3D;标签&#x3D;&#x3D;指明要退出的是哪一层语句块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label1：&#123;</span><br><span class="line">  label2： &#123;</span><br><span class="line">    label3： &#123;</span><br><span class="line">      <span class="keyword">break</span> label2；</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>break 语句可以指定推出哪层。</li>
<li>label1 是标签名，名字由人指定。</li>
<li>break 后指定到哪个lable就退出到哪里。</li>
<li>如果没有指定break，则默认推出最近的循环体。</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>continue语句用于结束本次循环，继续执行下一次循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  …………</span><br><span class="line">  <span class="keyword">continue</span>；</span><br><span class="line">  …………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>Continue语句出现在多层嵌套语句体中时，可以通过标签名指定要跳过的是哪一层循环，和break的标签使用方法相同。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label1：&#123;</span><br><span class="line">  label2： &#123;</span><br><span class="line">    label3： &#123;</span><br><span class="line">      <span class="keyword">continue</span> label2；</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li><p>return </p>
<p>return语句表示跳出所在的方法。如果在主方法中写return表示推出程序。</p>
</li>
</ul>
</blockquote>
<h3 id="12-数组"><a href="#12-数组" class="headerlink" title="12. 数组"></a>12. 数组</h3><blockquote>
<p>数组可以放置多个同一类型的数据，数组也是一种数据类型，使引用类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组类型[] 数组名 = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>可以通过数组名[下标] 来访问数组元素。</p>
<p>下标是从零开始。</p>
<p>数组名.length  属性表示数组的长度</p>
<p>注意：</p>
<ol>
<li><p>数组是多个&#x3D;&#x3D;相同类型数据&#x3D;&#x3D;的组合，实现对这些数据的统一管理。</p>
</li>
<li><p>数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型，但是不能混用。</p>
</li>
<li><p>数组创建之后，如果没有赋值，有默认值：</p>
<ul>
<li>int 0   short 0 long 0 byte 0 float 0.0 double 0.0 char \u0000 boolean false String null</li>
</ul>
</li>
<li><p>使用数组的步骤： 1.声明数组2.开辟空间 3.给数组各个元素赋值4.使用数组</p>
</li>
<li><p>数组的下标从0开始。</p>
</li>
<li><p>数组下标必须在指定范围内使用，否则抛出异常：下标越界异常，比如：</p>
<p>​	int a[] &#x3D; new int[5]; 有效下标为0-4.</p>
</li>
<li><p>数组属于引用类型，数组型数据是对象。</p>
</li>
<li><p>可以通过声明父类型数组，放置类型不同的元素。</p>
</li>
</ol>
</blockquote>
<h4 id="12-1-动态初始化"><a href="#12-1-动态初始化" class="headerlink" title="12.1 动态初始化"></a>12.1 动态初始化</h4><blockquote>
<p>数据类型[] 数组名 &#x3D; new 数据类型[大小]；</p>
<p>定义数组可以不定义大小，开辟空间必须定义大小。</p>
<p>&#x3D;&#x3D;数组初始化未赋值时初始化为0。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种：<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">第二种：<span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">第三种：<span class="type">int</span> a[];</span><br><span class="line">	  a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">a[i] = scan.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="12-2-静态初始化"><a href="#12-2-静态初始化" class="headerlink" title="12.2 静态初始化"></a>12.2 静态初始化</h4><blockquote>
<p>数据类型 数组名[] &#x3D; {元素值,元素值}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="12-3-数组赋值的分配机制"><a href="#12-3-数组赋值的分配机制" class="headerlink" title="12.3 数组赋值的分配机制"></a>12.3 数组赋值的分配机制</h4><blockquote>
<p>基本数据类型赋值，这个值就是具体的数据，不会相互影响。</p>
<p>数组默认情况下时引用传递，赋的是地址，会相互影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">y = <span class="number">2</span>;				<span class="comment">//值传递，变量不会相互影响</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[] = a; </span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//址传递，会相互影响</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="13-二维数组"><a href="#13-二维数组" class="headerlink" title="13 二维数组"></a>13 二维数组</h3><blockquote>
<p>二维数组由多个一维数组组成，他的各个一维数组的长度可以相同，也可以不相同。</p>
<p>二维数组定义时可以不定义大小，开辟空间时必须指定大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br><span class="line"><span class="type">int</span> arr[][] = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr[] = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<p> 二维数组动态初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">已知二维数组项数</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; i++)&#123;</span><br><span class="line">    arr[i][j] = <span class="number">1</span>；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">未知二维数组项数</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][];  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line"> 	arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-类与对象"><a href="#14-类与对象" class="headerlink" title="14  类与对象"></a>14  类与对象</h3><blockquote>
<p>使用类的过程：</p>
<ol>
<li>定义相应的类</li>
<li>创建实例对象<ol>
<li>先加载类信息(属性和方法信息，只会加载一次（在方法区加载），下次创建实例不加载)</li>
<li>在堆中分配空间，进行默认初始化</li>
<li>把堆中地址分配给对象</li>
<li>进行指定初始化</li>
</ol>
</li>
<li>调用类的成员或者方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">  属性；</span><br><span class="line">  属性；</span><br><span class="line">  方法()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doubao</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">void</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">    类名 对象名 = <span class="keyword">new</span> 类名();  \ 类名 对象名；</span><br><span class="line">   	对象名.属性；				\ 对象名 = <span class="keyword">new</span> 类名；</span><br><span class="line">    对象名.方法();			  \</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java内存分配机制</p>
<blockquote>
<p>栈：一般存放基本数据类型(局部变量)</p>
<p>堆: 存放对象，数组</p>
<p>方法区：常量池(常量，比如字符串)，类加载信息</p>
</blockquote>
</blockquote>
<h4 id="14-1-属性"><a href="#14-1-属性" class="headerlink" title="14.1 属性"></a>14.1 属性</h4><blockquote>
<p>从概念叫法上看，成员变量 &#x3D; 属性 。</p>
<p>属性是类的一个组成部分，一般是基本数据类型，也可以是引用数据类型(对象，数组)。</p>
<p>属性的定义语法同变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问修饰符 属性类型 属性名；</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age；</span><br></pre></td></tr></table></figure>

<p>控制属性的访问范围</p>
<ol>
<li>public </li>
<li>protected</li>
<li>默认</li>
<li>private</li>
</ol>
<p>属性可以定义为任何类型，包括基本类型和引用类型。</p>
<p>属性如果不赋值，有默认值，同数组。</p>
<ul>
<li>int 0   short 0 long 0 byte 0 float 0.0 double 0.0 char \u0000 boolean false String null</li>
</ul>
</blockquote>
<h4 id="14-2-成员方法"><a href="#14-2-成员方法" class="headerlink" title="14.2 成员方法"></a>14.2 成员方法</h4><p>​    成员方法的定义：</p>
<blockquote>
<ul>
<li>提高了代码复用性</li>
<li>可以将实现的细节封装起来，然后供其他的用户使用</li>
<li>成员方法中不能再定义方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clssname</span>&#123;</span><br><span class="line">  String name;					<span class="comment">//属性</span></span><br><span class="line">  访问修饰符 返回数据类型 方法名(参数列表……)&#123;			 <span class="comment">//方法=</span></span><br><span class="line">	语句；</span><br><span class="line">     <span class="keyword">return</span> 返回值；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>访问修饰符控制方法的使用范围。</p>
</li>
<li><p>数据类型(返回类型)： 表示成员方法输出，void表示没有返回值。</p>
<ul>
<li>返回类型可以为任意类型，包含基本类型或引用类型，一个方法只有一个返回值。</li>
<li>return语句不是必须的 ，但是如果方法要求有返回的数据类型，则必须要有return语句且返回数据类型必须和return的值类型一致或者兼容。</li>
</ul>
</li>
<li><p>形参列表：表示成员方法的输入。</p>
<ul>
<li>一个方法可以有零个参数也可以有多个参数，中间用逗号隔开。</li>
<li>参数类型可以为任意类型，包含基本类型或者引用类型。</li>
<li>调用带参数的方法时，一定对应这参数列表传入相同类型或者兼容类型的参数。</li>
<li>方法定义时的参数被称为形式参数，简称形参，方法调用时的参数被称为实际参数，简称实参。实参和形参的类型要一致或者兼容，个数顺序必须一致。</li>
</ul>
</li>
</ol>
<p>方法调用小结：</p>
<blockquote>
<ol>
<li>当程序执行到方法时就会开辟一个独立的空间(栈空间)。</li>
<li>当方法执行完毕或者执行到return时就会返回。</li>
<li>返回到调用方法的地方。</li>
<li>返回后，继续执行方法后面的代码。</li>
<li>当main方法(栈执行完毕，整个程序退出)。</li>
</ol>
</blockquote>
<p><img src="https://s4.ax1x.com/2022/01/21/72vGKs.png" alt="方法内存分配"></p>
<h4 id="14-3-方法的重载"><a href="#14-3-方法的重载" class="headerlink" title="14.3 方法的重载"></a>14.3 方法的重载</h4><blockquote>
<p>java中允许同一个类中，多个同名方法的存在，但是要求形参列表不一致(形参名字无所谓，主要是形参类型和顺序)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOverload</span><span class="params">(<span class="type">int</span> i)</span>&#123;  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOverload</span><span class="params">(<span class="type">char</span> name)</span>&#123;  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOverload</span><span class="params">(String age)</span>&#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="14-4-可变参数"><a href="#14-4-可变参数" class="headerlink" title="14.4 可变参数"></a>14.4 可变参数</h4><blockquote>
<p>java中允许将同一个类中多个同名同功能但是参数不同的方法封装为一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法：</span></span><br><span class="line">访问修饰符 返回类型 方法名( 数据类型... 形参名 )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  int...表示接受的是可变参数，类型是int，使用可变参数可以当作数组使用</span></span><br><span class="line"><span class="comment">//使用形参名.length可以得到输入参数的长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOverload</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>可变参数的实参可以是0个也可以是任意多个。</li>
<li>可变参数的实参可以是数组。</li>
<li>可变参数的本质就是数组。</li>
<li>可变参数可以和普通参数一起放在形参列表，&#x3D;&#x3D;但是可变参数必须放在最后&#x3D;&#x3D;.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOverload</span><span class="params">(String name,<span class="type">int</span>... nums)</span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个形参列表只能出现一个可变参数。</li>
</ul>
</blockquote>
<h4 id="14-5-构造器"><a href="#14-5-构造器" class="headerlink" title="14.5 构造器"></a>14.5 构造器</h4><blockquote>
<p>构造器又叫构造方法，&#x3D;&#x3D;是类的一种特殊方法，可以在创建类的对象时传入参数，完成数据的初始化。&#x3D;&#x3D;</p>
<blockquote>
<p>创建对象时，先创建属性，然后赋默认值，再调用构造器进行初始化。</p>
</blockquote>
<p>[修饰符] 方法名(形参列表)  {  方法体;  }</p>
<p>构造器的修饰符有可以默认，构造器没有返回值。</p>
<p>构造器的方法名必须和类名一致。</p>
<p>构造器由系统调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">doubao</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">doubao</span><span class="params">(String name)</span>&#123;		<span class="comment">//构造器没有返回值</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">doubao</span><span class="params">(<span class="type">int</span> age)</span>&#123;		<span class="comment">//构造器没有返回值</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户没有定义构造器，系统会自动给类生成一个默认无参数的构造器(也叫默认构造器)。</p>
<p>&#x3D;&#x3D;一旦自己定义了构造器，系统就不会生成默认构造器。&#x3D;&#x3D;</p>
</blockquote>
<h4 id="14-6-this关键字"><a href="#14-6-this关键字" class="headerlink" title="14.6 this关键字"></a>14.6 this关键字</h4><blockquote>
<p>this 关键字用来指代当前调用this的对象。</p>
<p>this可以看作时指代对象的属性，保存着指代对象的地址。</p>
<p>this关键字可以用来访问本类的属性，方法，构造器。</p>
<p>this用于区分当前类的属性和局部变量。</p>
<p>访问成员方法的语法：this.方法名(参数列表)；</p>
<p>访问构造器语法this(参数列表)，&#x3D;&#x3D;只能在构造器中使用。&#x3D;&#x3D; &#x3D;&#x3D;且必须放在第一行&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">doubao</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">doubao</span><span class="params">()</span>&#123;		</span><br><span class="line"> <span class="built_in">this</span>(<span class="number">12</span>,<span class="string">&quot;doubao&quot;</span>);   <span class="comment">//无参构造器访问了有参数构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">doubao</span><span class="params">(<span class="type">int</span> age,String name)</span>&#123;		<span class="comment">//构造器没有返回值</span></span><br><span class="line"> <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>this不能再类定义的外部使用，只能再类中的方法中使用。</p>
</blockquote>
<h3 id="15-递归"><a href="#15-递归" class="headerlink" title="15 递归"></a>15 递归</h3><blockquote>
<p>执行一个方法时，就创建一个新的相互独立的空间(栈空间);</p>
<p>方法的局部变量时独立的不会互相影响。</p>
<p>如果方法中使用的是引用类型的变量，就会共享引用类型变量的数据。</p>
<p>递归必须向推出递归条件逼近，否则就是无限递归。</p>
<p><img src="https://s4.ax1x.com/2022/01/22/7friMd.png"></p>
</blockquote>
<h3 id="16-作用域"><a href="#16-作用域" class="headerlink" title="16. 作用域"></a>16. 作用域</h3><p>作用域细节：</p>
<blockquote>
<p>在Java中，主要的变量就是属性(成员变量)和局部变量。</p>
<p>局部变量一般是指在成员方法中定义的变量。</p>
<ul>
<li>全局变量：就是属性，作用域为整个类体。可以被本类使用，也可以在其他类使用。</li>
<li>局部变量：也就是属性之外的其他变量，作用于定义它的代码块中。</li>
</ul>
<p>&#x3D;&#x3D;全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值使用，没有默认值。&#x3D;&#x3D;</p>
<p>全局变量在类的初始化阶段会被赋值，局部变量不会经历初始化阶段不会自动赋初值。</p>
</blockquote>
<blockquote>
<ul>
<li>属性和局部变量可以重名，访问遵循就近原则。</li>
<li>在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。</li>
<li>属性生命周期长，伴随着对象的创建而创建，伴随着对象的死亡而死亡，局部变量，生命周期短，伴随着他的代码块的执行而创建，伴随着代码块的结束而死亡。</li>
<li>&#x3D;&#x3D;全局变量可以加访问修饰符，局部变量不能加访问修饰符&#x3D;&#x3D;。</li>
</ul>
</blockquote>
<h3 id="17-包"><a href="#17-包" class="headerlink" title="17. 包"></a>17. 包</h3><blockquote>
<p>本质：实际上就是创建不同的文件夹保存文件。</p>
<p>作用：区分相同名字的类，控制管理类。控制类的访问范围。</p>
<p>命名规则：</p>
<p>​     只能包含数字，字母，下划线，小圆点，但是不能以数字开头，不能是关键字或者保留字。</p>
<p>命名规范：</p>
<p>​	一般是小写字母 + 小圆点，com.公司名.项目名.业务模块名</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.*  基本包，默认引入，不需要再引入</span><br><span class="line">java.util.*  util包，系统提供的工具包，工具类，使用Scanner</span><br><span class="line">java.net.* 网络包，网络开发</span><br><span class="line">java.awt.* 是做Java的界面开发。GUI</span><br></pre></td></tr></table></figure>

<blockquote>
<p>package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package。</p>
<p>import指令位置放在package的下面，再类定义前面，可以有多句没有顺序。</p>
</blockquote>
<h3 id="18-访问修饰符"><a href="#18-访问修饰符" class="headerlink" title="18. 访问修饰符"></a>18. 访问修饰符</h3><blockquote>
<p>java一共提供了四种访问修饰符号，用于控制方法和属性(成员变量)的访问权限(范围)。</p>
<p>1.公开级别： public，对外公开。</p>
<p>2.受保护级别：protected，对子类和同一个包中的类公开。</p>
<p>3.默认级别：没有符号，向同一个包的类公开。</p>
<p>4.私有级别：private修饰，只允许类本身可以访问，不公开。</p>
<p>注意事项：</p>
<ul>
<li>修饰符可以用来修饰类中的属性，成员方法以及类。</li>
<li>只有默认的和public才能修饰类，并且遵循以上的访问权限的特点。</li>
<li>成员方法的访问规则和属性完全一样。</li>
</ul>
</blockquote>
<h3 id="19-面向对象—封装"><a href="#19-面向对象—封装" class="headerlink" title="19. 面向对象—封装"></a>19. 面向对象—封装</h3><blockquote>
<p>面向对象三大特征：封装，继承，多态。</p>
<p>封装：就是把抽象出来的对象[属性]和对数据的操作[方法]封装一起，数据被保护在内部程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。</p>
<ul>
<li>隐藏实现细节。</li>
<li>可以对数据进行验证，保证安全合理。</li>
</ul>
</blockquote>
<p>封装实现步骤：</p>
<ol>
<li>将属性进行私有化。</li>
<li>提供一个公共的set方法，用于对属性赋值。</li>
<li>提供一个公共的get方法，用于获取属性的值。</li>
</ol>
<h3 id="20-面向对象—继承"><a href="#20-面向对象—继承" class="headerlink" title="20. 面向对象—继承"></a>20. 面向对象—继承</h3><blockquote>
<p>继承可以解决代码复用，让我们的编程更加接近人类思维，当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义相同的属性和方法，所有的子类不许要重新定义这些方法和属性，只需要通过extends来声明继承父类即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类自动拥有父类定义的属性和方法。</p>
<p>父类又叫超类，基类。</p>
<p>子类又叫派生类。</p>
</blockquote>
<p>继承细节：</p>
<ul>
<li>子类继承了所有的属性和方法，但是私有属性和方法不能在子类中直接访问，要通过父类提供的公共的方法访问。(继承包括私有的所有属性方法只是不能访问)</li>
<li>子类必须调用父类的构造器完成父类的初始化。</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过。</li>
<li>如果希望指定去调用父类的某个构造器，则显示的调用一下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(参数列表);</span><br></pre></td></tr></table></figure>



<ul>
<li>super在使用时，需要放在构造器的第一行。</li>
<li>super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中。</li>
<li>java的所有类都是object的子类。</li>
<li>父类构造器的调用不限于直接父类，将一直追溯到object类。</li>
<li>子类最多只能直接继承一个父类。</li>
<li>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系。</li>
</ul>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><blockquote>
<p>super代表父类的引用，用于访问父类属性，方法，构造器。</p>
<ol>
<li>访问父类的属性，但是不能访问父类的private属性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.属性名；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>访问父类的方法，&#x3D;&#x3D;不能访问父类的private方法&#x3D;&#x3D;。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.方法名(参数列表);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>访问父类的构造器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(参数列表);   <span class="comment">//只能放在构造器的第一句，只能出现一句。</span></span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th>区别点</th>
<th>this</th>
<th>super</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td>访问本类中的属性，&#x3D;&#x3D;如果本类中没有此属性则从父类中继续查找&#x3D;&#x3D;</td>
<td>访问父类中的属性</td>
<td></td>
</tr>
<tr>
<td>调用方法</td>
<td>访问本类中的方法，如果本类中没有此方法则从父类继续查找</td>
<td>直接访问父类中的方法</td>
<td></td>
</tr>
<tr>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
<td></td>
</tr>
<tr>
<td>特殊</td>
<td>表示当前对象</td>
<td>子类中访问父类对象</td>
<td></td>
</tr>
</tbody></table>
<h3 id="21-重写-override"><a href="#21-重写-override" class="headerlink" title="21. 重写(override)"></a>21. 重写(override)</h3><blockquote>
<p>子类 有一个方法，和父类的某个方法的名称，返回类型，参数是一样的，那么我们可以说这个方法覆盖了父类的方法。</p>
<p>方法重写细节：</p>
<ol>
<li><p>子类方法的参数，方法名称，要和父类方法的参数，方法名称完全一样。</p>
</li>
<li><p>子类方法的返回类型和父类方法的返回类型一样，或者父类是返回类型的子类。</p>
<p>例如：父类返回类型：object    子类返回类型：  String  </p>
</li>
<li><p>子类方法不能缩小父类方法的访问权限。</p>
</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>发生范围</th>
<th>方法名</th>
<th>参数列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>本类</td>
<td>必须一样</td>
<td>类型，个数，顺序至少一个不同</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td>重写</td>
<td>父子类</td>
<td>必须一样</td>
<td>必须完全相同</td>
<td>子类重写的方法和父类返回的类型一致或者是其子类</td>
<td>子类方法不能缩小父类的访问范围</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="22-面向对象—多态"><a href="#22-面向对象—多态" class="headerlink" title="22.面向对象—多态"></a>22.面向对象—多态</h3><blockquote>
<p>多态：方法或对象具有多种形态，多态是建立在封装和继承基础之上的。</p>
<p>多态有利于代码维护和代码复用性。</p>
</blockquote>
<h4 id="22-1-方法的多态"><a href="#22-1-方法的多态" class="headerlink" title="22.1 方法的多态"></a>22.1 方法的多态</h4><blockquote>
<p>方法的多态：重载：传入不同的参数会调用不同的方法。</p>
</blockquote>
<p>​      			   重写：自动定位使用的方法。</p>
<h4 id="22-2-对象的多态："><a href="#22-2-对象的多态：" class="headerlink" title="22.2 对象的多态："></a>22.2 对象的多态：</h4><blockquote>
<ul>
<li>一个&#x3D;&#x3D;对象的编译类型和运行类型可以不一致&#x3D;&#x3D;。</li>
<li>instanceof用于判断对象的&#x3D;&#x3D;运行类型&#x3D;&#x3D;是否为指定类型或者指定类型的子类型。</li>
<li>编译类型在定义对象时就确定了，不能改变。</li>
<li>运行类型是可以变化的。</li>
<li>编译类型看定义时 &#x3D; 号的左边，运行类型看定义时 &#x3D; 号的右边 。</li>
<li>&#x3D;&#x3D;属性没有重写之说，属性的值看编译类型。&#x3D;&#x3D;</li>
<li>instanceof判断的是运行类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dag</span>();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>多态的使用前提： 两个对象之间存在继承关系。</p>
<p>本质：父类的引用指向了子类的对象(多态向上转型)</p>
<p>多态的向上转型：</p>
<blockquote>
<p>语法： 父类类型  引用名 &#x3D; new 子类类型()</p>
</blockquote>
<blockquote>
<p>特点： &#x3D;&#x3D;可以调用父类中的所有成员(需要遵循访问权限)，不能调用子类中的特有成员，最终结果看子类的具体实现。&#x3D;&#x3D;   （在编译阶段，能和调用哪些成员由编译器决定）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dag</span>();</span><br></pre></td></tr></table></figure>



<p>多态的向下转型：</p>
<blockquote>
<p>语法： 子类类型 引用名 &#x3D; (子类类型)父类引用；</p>
<p>只能强转父类的引用，不能强转父类的对象。(改变的只是编译器所限定的调用范围 )</p>
<p>要求父类的引用必须指向的是当前目标类型的对象。</p>
<p>向下转型后可以调用子类类型中所有的成员。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dag</span>();</span><br><span class="line"><span class="type">Dag</span> <span class="variable">dag</span> <span class="operator">=</span> (Dag)animal;      <span class="comment">//可以使用子类全部方法</span></span><br></pre></td></tr></table></figure>

<h4 id="22-3-动态绑定机制"><a href="#22-3-动态绑定机制" class="headerlink" title="22.3 动态绑定机制"></a>22.3 动态绑定机制</h4><blockquote>
<p>&#x3D;&#x3D;当调用对象的方法时，该方法会和该对象的内存地址&#x2F;运行类型绑定&#x3D;&#x3D;</p>
<p>当调配用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</p>
<p>发挥作用的顺序:  动态绑定机制    继承机制</p>
</blockquote>
<h4 id="22-4-多态数组"><a href="#22-4-多态数组" class="headerlink" title="22.4 多态数组"></a>22.4 多态数组</h4><blockquote>
<p>可以将数组编译类型定义为父类类型，向数组中添加多种子类类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">5</span>];</span><br><span class="line">obj[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Ingter</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<h4 id="22-5-多态参数"><a href="#22-5-多态参数" class="headerlink" title="22.5 多态参数"></a>22.5 多态参数</h4><blockquote>
<p>方法定义的形参类型为父类类型，实参类型允许为子类类型。</p>
</blockquote>
<h3 id="23-Object类方法"><a href="#23-Object类方法" class="headerlink" title="23. Object类方法"></a>23. Object类方法</h3><h4 id="23-1-equals-与-x3D-x3D"><a href="#23-1-equals-与-x3D-x3D" class="headerlink" title="23.1 equals()与 &#x3D;&#x3D;"></a>23.1 equals()与 &#x3D;&#x3D;</h4><blockquote>
<p>&#x3D;&#x3D; :&#x3D;&#x3D;即可以判断基本类型，又可以判断引用类型。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;: 如果判断基本类型，判断的是值是否相等。</p>
<p>&#x3D;&#x3D;:如果判断引用类型，判断的是地址是否相等，即是不是同一个对象。（无论是否向上转型，只要地址相同就返回true）</p>
</blockquote>
<blockquote>
<p>equals: 是Object的方法，&#x3D;&#x3D;只能判断引用类型。&#x3D;&#x3D;</p>
<p>用于判断地址是否相等，子类中往往重写该方法，用于判断内容是否相等。</p>
<ul>
<li>Object中equals()判断地址是否相同。</li>
<li>其他重写后的equals()方法比较两个值是否相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.equals(obj);</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="23-2-hashCode"><a href="#23-2-hashCode" class="headerlink" title="23.2 hashCode"></a>23.2 hashCode</h4><blockquote>
<p>返回对象的哈希码值，支持此方法是为了提高哈希表的性能。(一般是通过该内部地址转换成一个整数来实现的)</p>
<p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</p>
<p>两个引用，如果指向的不是同一个对象，则哈希值是不一样的。</p>
<p>哈希值主要是根据地址号来的，不能完全将哈希值等价于地址。</p>
<p>hashCode()如果需要，也可以重写。使相同的类的对象返回hashCode码相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.hashCode()</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="23-3-toString"><a href="#23-3-toString" class="headerlink" title="23.3 toString()"></a>23.3 toString()</h4><blockquote>
<p>默认返回： 全类名(包名 + 类名 ) + @ + 哈希值的十六进制</p>
<p>子类往往会重写toString()方法来返回对象的属性信息。</p>
<p>当直接输出一个对象时，toString()会默认被调用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">object.toString()</span><br></pre></td></tr></table></figure>



<h4 id="23-4-finalize"><a href="#23-4-finalize" class="headerlink" title="23.4 finalize()"></a>23.4 finalize()</h4><blockquote>
<p>当对象被回收时，系统自动调用该对象的finalize()方法，默认处理。子类可以重写该方法，做一些释放资源的操作。</p>
<p>回收条件：当某个对象没有任何引用，则jvm就会认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finelize()方法。可以重写finalize()方法，释放资源。</p>
<p>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.cg();</span><br></pre></td></tr></table></figure>



<h3 id="24-类变量和类方法-static"><a href="#24-类变量和类方法-static" class="headerlink" title="24. 类变量和类方法(static)"></a>24. 类变量和类方法(static)</h3><blockquote>
<p>类变量又叫静态变量，该变量会被该类所有实例对象共享。</p>
<p>静态变量在类加载的时候就生成了，即使没有创建对象也可以使用。</p>
<p>定义类变量：</p>
<p>访问修饰符 static 数据类型 变量名；</p>
<p>static 访问修饰符 数据类型 变量名；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">xxx</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="type">int</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>访问变量：        —–类变量的访问，必须遵循相关的访问权限。</p>
<p>对象名.类变量名；</p>
<p>类名.类变量名；     </p>
</blockquote>
<blockquote>
<p>类方法也叫静态方法。</p>
<p>不创建实例也可以调用方法(当作工具使用),使用静态方法。</p>
<p>定义静态方法：</p>
<p>访问修饰符 static 返回数据类型 方法名；</p>
<p>static 访问修饰符 返回数据类型 方法名；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问方法：        —–类方法的访问，必须遵循相关的访问权限。</p>
<p>对象名.方法名；</p>
<p>类名.方法名； </p>
<p>注意事项：</p>
<ul>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法去，类方法中无this参数，普通方法隐含着this参数。</li>
<li>类方法不能使用和对象相关的关键字。</li>
<li>类方法可以通过类名调用，也可以通过对象名调用。</li>
<li>普通方法和对象有关，需要通过对象名调用。不能通过类名调用。</li>
<li>普通成员方法，既可以访问非静态成员，也可以访问静态成员。</li>
<li>&#x3D;&#x3D;静态成员方法，只能访问静态成员&#x3D;&#x3D;！</li>
</ul>
</blockquote>
<h3 id="25-main方法"><a href="#25-main方法" class="headerlink" title="25. main方法"></a>25. main方法</h3><blockquote>
<ol>
<li>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须时public。</li>
<li>java虚拟机在执行main方法时不创建对象，所以该方法必须是static</li>
<li>该方法接收Sting类型的数组参数，该数组中保存着执行java命令时传递给所运行的类的参数。</li>
</ol>
</blockquote>
<h3 id="26-代码块"><a href="#26-代码块" class="headerlink" title="26.代码块"></a>26.代码块</h3><blockquote>
<p>代码块又称初始化块，属于类中的成员[即类中的一部分]，类似方法，将逻辑语句封装在方法体中，通过{}包围起来。</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或者类显示调用，而是&#x3D;&#x3D;加载类时，或者创建对象时隐式&#x3D;&#x3D;调用。</p>
<p>先调用代码块，后调用构造器。</p>
<p>定义语法：</p>
<p>[修饰符]{</p>
<p>​	代码</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">代码；</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">代码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>修饰符可选，只能填写static</li>
<li>代码块分为静态代码块和非静态代码块</li>
<li>逻辑语句可以为任何逻辑语句。(输入，输出，方法调用，循环，判断)</li>
<li>； 号可以写上也可以省略。</li>
</ul>
<p>代码块细节：</p>
<ol>
<li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而加载，并且&#x3D;&#x3D;只会执行一次(类只加载一次)&#x3D;&#x3D;。如果时普通代码块，每创建一个对象就执行一次。</p>
</li>
<li><p>类加载：</p>
<ol>
<li>创建对象实例</li>
<li>创建子类对象实例，父类也会加载</li>
<li>使用类的静态成员</li>
</ol>
</li>
<li><p>普通代码块在创建对象实例时，会隐式调用，被创建一次就调用一次，如果只是使用类的静态成员，普通代码块不会执行。</p>
</li>
<li><p>创建一个对象时，在一个类的调用顺序：</p>
<ol>
<li>调用静态代码块和静态属性初始化(注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按照他们定义的顺序调用)</li>
<li>调用普通代码块和普通属性的初始化(注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按照定义顺序调用。)</li>
<li>调用构造方法</li>
</ol>
</li>
<li><p>构造方法的前面其实隐含了super()和调用普通代码块。静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优于构造器和普通代码块执行。</p>
<ol>
<li>&#96;&#96;&#96;java<br>public 构造器(){<br>super();<br>普通代码块;<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>静态代码块，静态属性，普通代码块，普通属性初始化，构造方法的调用顺序：</p>
<ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和普通属性初始化</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
</li>
<li><p>静态代码块只能调用静态成员，普通代码块可以调用任意成员。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 27. final关键字</span><br><span class="line"></span><br><span class="line">final可以修饰类，属性，方法，和局部变量。</span><br><span class="line"></span><br><span class="line">final的使用场景</span><br><span class="line"></span><br><span class="line">1. 不希望类被继承时，可以使用final修饰。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">final class A &#123;</span><br><span class="line"></span><br><span class="line">&#125; //这个类将无法被继承</span><br></pre></td></tr></table></figure>
</li>
<li><p>不希望父类的某个方法被重写&#x2F;覆盖时可以使用final关键字修饰。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;  <span class="comment">//此方法不能被修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>不希望类的某个属性的值被修改可以使用final修饰。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;  <span class="comment">//此方法不能被修改</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0.1</span>; <span class="comment">//此属性不能被修改</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>不希望某个局部变量被修改，可以使用final修饰。</li>
</ol>
<p>使用细节：</p>
<ul>
<li><p>final修饰的属性又叫常量，一般使用大写来命名。</p>
</li>
<li><p>final修饰的属性在定义时，必须赋初值，且以后不允许被修改，赋值可以在的位置：</p>
<ul>
<li>定义时： final int i &#x3D; x；</li>
<li>构造器中</li>
<li>代码块中</li>
</ul>
</li>
<li><p>如果final修饰的属性时静态的，则初始化位置只能在</p>
<ul>
<li>定义时</li>
<li>静态代码块中</li>
</ul>
</li>
<li><p>final类不能继承，但是可以实例化对象</p>
</li>
<li><p>如果类不是final类。但是含有final方法，则该类虽然不能重写但是可以被继承。</p>
</li>
<li><p>一般来说，一个类已经是final，就没必要将方法修饰成final方法了。</p>
</li>
<li><p>final不能修饰构造方法。</p>
</li>
<li><p>final和sitatic往往搭配使用，效率更高，底层编译器做了优化处理。</p>
<ul>
<li>&#96;&#96;&#96;java<br>public static int cun &#x3D; 1； &#x2F;&#x2F;只是用static修饰属性，使用时需要加载类<br>public final static int num &#x3D; 1;   &#x2F;&#x2F;将final和static一起使用，不需要加载类，直接加载属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>包装类(integer,Double,Float,Boolean等都是final)，String也是final类。</p>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 28. 抽象类</span><br><span class="line"></span><br><span class="line">使用abstract关键字修饰一个类时，这个类就是抽象类。</span><br><span class="line"></span><br><span class="line">抽象类不能被实例化。</span><br><span class="line"></span><br><span class="line">使用abstract关键字来修饰一个方法时，这个方法就是抽象方法。</span><br><span class="line"></span><br><span class="line">抽象方法不能有方法体。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">abstract class cat&#123;</span><br><span class="line">	public abstract void getInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类的价值更多作用在设计，设计者设计好后，让子类继承并实现抽象类。</p>
<p>抽象类细节：</p>
<ol>
<li>抽象类不能被实例化。</li>
<li>抽象类可以不包含抽象方法。</li>
<li>一旦一个类包含了抽象方法，则必须声明为从抽象类。</li>
<li>abstract只能修饰类和方法，不能修饰属性。</li>
<li>抽象类可以有任意成员(非抽象方法，构造器，静态属性)。</li>
<li>如果一个类继承了抽象类，则它必须实现(只要有方法体不管为不为空)抽象类的所有抽象方法，除非它自己也声明为抽象类。</li>
<li>抽象方法不能使用private，final，static来修饰，因为这些关键字都是和重写相违背的。</li>
</ol>
</blockquote>
<h3 id="29-接口"><a href="#29-接口" class="headerlink" title="29. 接口"></a>29. 接口</h3><blockquote>
<p>接口就是给出一些没有实现的方法，封装到一起，到某个要使用的时候。就根据具体情况把这些方法写出来。</p>
<p>在接口中可以省略abstract</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">属性；</span><br><span class="line">方法;    <span class="comment">//1.抽象方法   2.默认实现方法   3.静态方法</span></span><br><span class="line">&#125;</span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">实现的方法；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口在jdk7.0之前接口中所有方法都没有方法体，即都是抽象方法。</li>
<li>在jdk8.0及以后可以定义静态方法，和已经实现的方法，但是必须使用default修饰。</li>
</ul>
</blockquote>
<p>接口的细节：</p>
<ul>
<li><p>接口不能被实例化，</p>
</li>
<li><p>接口中的方法都是public修饰的方法，在接口中的抽象方法可以省略abstract。</p>
</li>
<li><p>一个普通类实现接口，就要把接口中的所有抽象方法都实现。</p>
</li>
<li><p>抽象类实现接口可以不用全部实现接口的抽象方法。</p>
</li>
<li><p>一个类可以同时实现多个接口。</p>
</li>
<li><p>&#x3D;&#x3D;接口中的属性只能是final，而且是public static final 修饰符&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> <span class="comment">//实际上是 public static final interesting a = 1；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;接口中的属性的访问方式： 接口名.属性名。&#x3D;&#x3D;</p>
</li>
<li><p>一个接口不能继承其他的类，但是可以继承多个别的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 extends 接口，接口；</span><br></pre></td></tr></table></figure>


</li>
<li><p>接口的修饰符只能是public和默认，这点和类相同。</p>
</li>
</ul>
<h4 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h4><ol>
<li>接口和继承所解决的问题不同：<ol>
<li>继承的价值主要在于：解决代码的复用性和可维护性。</li>
<li>接口的价值主要在于：设计。设计好各种规范(方法)，让其他类去实现这些方法。</li>
</ol>
</li>
<li>接口比继承更加灵活。</li>
<li>接口在一等程度上实现代码解耦。</li>
</ol>
<h4 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h4><blockquote>
<ol>
<li>多态参数。 接口参数可以接收实现了接口的实例。</li>
<li>多态数组。 可以定义接口类型的数组，存储实现接口的对象。</li>
<li>接口存在多态传递现象。</li>
</ol>
</blockquote>
<h3 id="30-内部类"><a href="#30-内部类" class="headerlink" title="30. 内部类"></a>30. 内部类</h3><blockquote>
<p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类被称为内部类。嵌套其它类的类被称为外部类，这是类的的第五大成员。(属性，方法，构造器，代码块，内部类)</p>
<p>内部类的最大特点就是可以直接访问私有属性，并且可以体现类于类之间的包含关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 外部类&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类分类：</p>
<ol>
<li>定义在外部类局部位置上(比如方法内，代码块中)<ol>
<li>局部内部类(有类名)</li>
<li>匿名内部类(没有类名)</li>
</ol>
</li>
<li>定义在外部类的成员位置上：<ol>
<li>成员内部类(没用static修饰)</li>
<li>静态内部类(使用static修饰)</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="30-1-局部内部类"><a href="#30-1-局部内部类" class="headerlink" title="30.1 局部内部类"></a>30.1 局部内部类</h4><blockquote>
<p>局部内部类时定义在外部类的局部位置，比如方法中，代码块中。并且有类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Outer01</span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以直接访问外部类的所有成员，包括私有的。</p>
</li>
<li><p>不能添加访问修饰符，因为他的地位就是一个局部变量。局部变量是不能使用修饰符的，但可以使用final修饰，因为局部变量也可以使用final。(使用final禁止继承)</p>
</li>
<li><p>作用域：&#x3D;&#x3D;仅仅在定义它的方法或代码块中。&#x3D;&#x3D;</p>
</li>
<li><p>局部内部类访问外部类的成员：直接访问。</p>
</li>
<li><p>外部类访问局部内部类的成员： 创建对象再访问(需要在作用域中)</p>
</li>
<li><p>外部类不能直接访问局部内部类(局部内部类是一个局部变量)</p>
</li>
<li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员 可以使用 外部类名.this.成员去访问。（&#x3D;&#x3D;外部类.this实质就是外部类的对象&#x3D;&#x3D;）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span><span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Outer01</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&#x27;内部类的n1&#x27;</span>+ n1 + <span class="string">&#x27;外部类的n1&#x27;</span>+ 				Outter02.<span class="built_in">this</span>.n1)</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="30-2-匿名内部类"><a href="#30-2-匿名内部类" class="headerlink" title="30.2 匿名内部类"></a>30.2 匿名内部类</h4><blockquote>
<p>本质是类，内部类，同时还是一个对象。</p>
<p>匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征。</p>
<p>可以直接访问外部类的所有成员包含私有的。</p>
<p>不能添加访问修饰符，因为它的地位就是一个局部变量。</p>
<p>作用域： 仅仅是在定义他的方法块中。</p>
<p>该类没有指定的名字，系统自动分配名字。(外部类名$1…)</p>
<p>匿名内部类定义在外部类的局部位置，比如方法中并且没有类名。</p>
<p>匿名内部类可以实现普通类，接口，抽象类，简化编程。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口(参数列表)&#123;</span><br><span class="line">类体；</span><br><span class="line">&#125;；</span><br><span class="line">接口或类类型 对象名  = <span class="keyword">new</span> 类名或接口(参数列表)&#123;</span><br><span class="line">类体</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//底层代码</span></span><br><span class="line"> <span class="number">1.</span> 实现指定接口或者类的方法</span><br><span class="line"> <span class="number">2.</span> 返回对象</span><br><span class="line"> <span class="number">3.</span> 销毁实现的类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>匿名内部类访问外部类成员： 直接访问。</p>
<p>外部其他类不能访问匿名内部类(匿名内部类的地位就是一个局部变量)</p>
<p>如果外部类和内部类的成员重名时，内部类的访问遵循就近原则，如果想访问内部类的成员可以使用 外部类.this.成员 去访问。( 外部类.this 表示指定类的实例 )</p>
<p>匿名内部类可以简化开发。</p>
<p>匿名内部类的编译类型就是指定的类型，运行类型就是系统自动指定的类型，匿名内部类使用一次后就销毁。(实现的类无法使用，对象可以重复使用)</p>
<p>使用方法数量由编译类型限定，方法内容由运行类型限定。</p>
<p>匿名内部类实践：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口和指定方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Doubao</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(Doubal doubao)</span>&#123;</span><br><span class="line">  doubao.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法</span></span><br><span class="line">f1(                             <span class="comment">//直接向方法种传入匿名内部类。</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Double</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;匿名内部类重写方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="30-3-成员内部类"><a href="#30-3-成员内部类" class="headerlink" title="30.3 成员内部类"></a>30.3 成员内部类</h4><blockquote>
<p>成员内部类定义在外部类的成员位置，并且没有static修饰。</p>
<p>可以直接访问外部类的所有成员，包含私有。</p>
<p>可以任意添加访问修饰符(public ，protected， 默认 ，private)，因为它就是类的一个成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Doubao</span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Dahei</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用域： 和外部类的其他成员一样。</p>
<p>成员内部类访问外部类： 直接访问</p>
<p>外部类访问内部类： 创建对象再访问</p>
<p>外部其他类访问成员内部类：</p>
<pre><code>   1. 外部类.成员内部类 对象名 = 外部类对象.new 内部类();
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义内部类和外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Doubao</span>&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Dahei</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用内部类</span></span><br><span class="line"><span class="type">Doubao</span> <span class="variable">doubao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doubao</span>()；</span><br><span class="line"></span><br><span class="line">Doubao.Dahei = doubao.<span class="keyword">new</span> <span class="title class_">Dahei</span>();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在外部类中编写方法，返回内部类的实例。</li>
</ol>
<p>外部类和内部类的成员重名时，内部类访问的话，遵循就近原则，如果向访问外部类的成员可以使用外部类.this.成员 去访问。( 外部类.this 表示指定类的实例）</p>
</blockquote>
<h4 id="30-4-静态内部类"><a href="#30-4-静态内部类" class="headerlink" title="30.4 静态内部类"></a>30.4 静态内部类</h4><blockquote>
<p>静态内部类是定义在外部类的成员位置，并且有static修饰。</p>
<p>可以直接访问外部类的所有静态成员，包含私有的，但是不能直接访问非静态成员。</p>
<p>可以添加任意访问修饰福(public,protected,默认,private),因为它的地位就是一个成员。</p>
<p>作用域：同其他成员，为整个类体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态内部类和外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Doubao</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dahei</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类访问外部类(比如静态属性)： 直接访问所有静态成员</p>
<p>外部类访问静态内部类 ： 创建对象再访问。</p>
<p>外部其他类访问静态内部类：</p>
<ol>
<li><p>外部类名.静态内部类名 对象名 &#x3D; new 外部类名.静态内部类名();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义静态内部类和外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Doubao</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dahei</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用静态内部类</span></span><br><span class="line">Doubao.Dahei 对象名 = <span class="keyword">new</span> <span class="title class_">Doubao</span>.Dahei();</span><br><span class="line"><span class="comment">//因为是静态内部类，是可以通过类名直接访问(前提满足访问权限)</span></span><br></pre></td></tr></table></figure>

<p>2.编写方法，返回静态内部类实例。</p>
</li>
</ol>
<p>如果外部类和静态内部类的成员重名，静态内部类访问的时候，默认遵循就近原则，如果向访问外部类的成员，则可以试用(外部类名.成员)去访问。</p>
</blockquote>
<h3 id="31-枚举-eunmeration"><a href="#31-枚举-eunmeration" class="headerlink" title="31 枚举(eunmeration)"></a>31 枚举(eunmeration)</h3><blockquote>
<p>把具体对象一个一个列举。</p>
<p>枚举是一组常量的集合。可以理解为：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</p>
<p>得到枚举类型的方法：</p>
<ol>
<li>自定义枚举类型</li>
<li>使用系统关键字得到枚举类型</li>
</ol>
</blockquote>
<h4 id="31-1-自定义实现枚举类型"><a href="#31-1-自定义实现枚举类型" class="headerlink" title="31.1 自定义实现枚举类型"></a>31.1 自定义实现枚举类型</h4><blockquote>
<p>不需要提供set方法，因此枚举对象值通常设置为只读。</p>
<p>枚举类的构造器是私有修饰符。</p>
<p>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化。</p>
<p>枚举对象名通常使用全部大写，常量的命名规范。</p>
<p>枚举根据需要，也可以有多个属性。</p>
<p>特点：</p>
<ul>
<li>构造器私有化</li>
<li>本类内部创建一组对象。</li>
<li>对外暴露对象(通过为对象添加public final static修饰符)</li>
<li>可以提供get方法，但是保护要提供set。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>构造器私有化防止外部创建对象。</span><br><span class="line"><span class="number">2.</span>去掉set方法，防止属性被修改。</span><br><span class="line"><span class="number">3.</span>再枚举类内部直接创建固定的对象。</span><br><span class="line"><span class="number">4.</span>优化，加入<span class="keyword">final</span>修饰符。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器需要私有，防止外部调用new创建对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-2-enum关键字实现枚举"><a href="#31-2-enum关键字实现枚举" class="headerlink" title="31.2 enum关键字实现枚举"></a>31.2 enum关键字实现枚举</h4><blockquote>
<p>使用enum关键字实现枚举类</p>
<ol>
<li><p>使用关键字enum代替class</p>
</li>
<li><p>将public static final Season SPRING &#x3D; new Season(“春天”,”温暖”);改为：</p>
<p>SPRING(“春天”,”温暖”);  （ 枚举类对象名(参数列表) ）</p>
</li>
<li><p>如果有多个常量(对象)，使用 ， 间隔即可。</p>
</li>
<li><p>如果使用enum来实现，需要将常量定义语句现在最前面。</p>
</li>
<li><p>&#x3D;&#x3D;使用enum关键字后不能继承其他类了&#x3D;&#x3D;，因为enum会隐式继承Enum，而java是单继承机制。</p>
</li>
<li><p>枚举类和普通类一样，可以实现接口。</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>)，     <span class="comment">//使用逗号间隔</span></span><br><span class="line">  	WINTER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;温暖&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season  WINTER = new Season(&quot;夏天&quot;,&quot;温暖&quot;);</span></span><br><span class="line">	<span class="comment">//构造器需要私有，防止外部调用new创建对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>当我们使用enum关键字开发一个枚举类时，&#x3D;&#x3D;默认会继承enum类&#x3D;&#x3D;。</li>
<li>传统的public static dinal Season2 SPEING &#x3D; new Seasonal(“春天”，“温暖”)；</li>
</ul>
<p>简化成SPRING(“春天”，“温暖”),这里必须知道，它调用的是哪个构造器。</p>
<ul>
<li><p>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>)，     <span class="comment">//使用逗号间隔</span></span><br><span class="line">  	WINTER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;温暖&quot;</span>),</span><br><span class="line">  	WUCAN;   <span class="comment">//等价于调用无参构造器WUCAN()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举对象必须放在枚举类的首行。</p>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>&#x3D;&#x3D;使用enum关键字会隐式继承Enum类，这样就可以使用Enum类的相关的 方法。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>valueOf</td>
<td>传递给方法枚举常量的字符串，得到相应常量名的对象。</td>
</tr>
<tr>
<td>toString</td>
<td>得到当前枚举常量的的名称。你可以通过重写这个方法使得到的结果更加易读。</td>
</tr>
<tr>
<td>equals</td>
<td>再枚举类型中直接使用“&#x3D;&#x3D;”判断枚举常量是否相等，equals为了在Set,List和Map中使用。equals()是不可变的。</td>
</tr>
<tr>
<td>hashCode</td>
<td>实现了hashCode和equals保持不变</td>
</tr>
<tr>
<td>getDeclanngClass</td>
<td>得到枚举常量所属枚举类型Class对象，可以用来判断两个枚举常量是否属于同一枚举类型。</td>
</tr>
<tr>
<td>name</td>
<td>得到当前枚举常量的名称。建议有限使用toString</td>
</tr>
<tr>
<td>ordinal</td>
<td>得到当前枚举常量的次序。从0开始编号。</td>
</tr>
<tr>
<td>compareTo</td>
<td>枚举类型实现Comparable接口，这样可以比较两个枚举常量&#x3D;&#x3D;编号&#x3D;&#x3D;大小</td>
</tr>
<tr>
<td>clone</td>
<td>枚举类型不能被Clone，为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedExcrption异常的不变Clone()</td>
</tr>
<tr>
<td>values</td>
<td>得到对应枚举类中的所有对象</td>
</tr>
</tbody></table>
<h3 id="31-注解"><a href="#31-注解" class="headerlink" title="31 注解"></a>31 注解</h3><blockquote>
<p>注解(Annotation)，用于修饰解释包，类，方法，属性，构造器，局部变量等数据信息。</p>
<p>和注释一样，注解不影响程序逻辑，但是注解可以被编译或者运行，相当于嵌入在代码中的补充信息。</p>
<p>在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在JavaEE中注解占据了更重要的角色，例如用来配置应用成秩序的任何切面，代替javaEE旧版中所遗留的繁荣代码和XML配置等。</p>
<p>使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符号使用，用于修饰它支持的程序元素</p>
<p>三个基本的Annotation：</p>
<ol>
<li><p>@Override：限定于某个方法，是重写父类方法，该注释只能用于方法。</p>
</li>
<li><p>@Deprecated：用于表示某个程序员元素(类，方法）已经过时。</p>
</li>
<li><p>@Suppress Warnings：抑制编译器警告。</p>
</li>
<li><p>@Target ：修饰注解的注解，被称为元注解。</p>
</li>
</ol>
</blockquote>
<h4 id="31-1-Override"><a href="#31-1-Override" class="headerlink" title="31.1 @Override"></a>31.1 @Override</h4><blockquote>
<p>如果写了@Override注释，编译器就会去检查该方法是否真的重写父类的方法，如果的确重写了 ，则编译通过，如果没有构成重写，则编译错误。 </p>
<p>@Override只能修饰方法。</p>
</blockquote>
<h4 id="31-2-Deprecated"><a href="#31-2-Deprecated" class="headerlink" title="31.2 @Deprecated"></a>31.2 @Deprecated</h4><blockquote>
<p>使用@Deprecated修饰某个元素，表示该元素已经过时</p>
<p>即不再推荐使用，但是仍然可以使用。</p>
<p>用于表示某个程序元素(类，方法等)已过时。</p>
<p>可以修饰方法，字段，包，参数，类等。</p>
<p>@Deprecated的作用可以做到新旧版本的兼容和过度。</p>
</blockquote>
<h4 id="31-3-Suppress-Warnings"><a href="#31-3-Suppress-Warnings" class="headerlink" title="31.3 @Suppress Warnings"></a>31.3 @Suppress Warnings</h4><blockquote>
<p>当不希望看到警告时，可以使用@Suppress Warnings抑制警告信息。</p>
<p>@Suppress Warnings({“警告信息”})</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Suppress</span> Warnings(&#123;<span class="string">&quot;指定警告&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>在方法前填写抑制范围为整个方法体。</p>
<p>在语句上填写一致范围为单独语句。</p>
</blockquote>
<h4 id="31-4-元注解"><a href="#31-4-元注解" class="headerlink" title="31.4 元注解"></a>31.4 元注解</h4><blockquote>
<p>JDK的元注解用于修饰其他的Annotation，元注释就是修饰其他注释的注释。</p>
<p>元注解的种类：</p>
<ol>
<li><p>Retention &#x2F;&#x2F;指定注解的作用范围： SOURCE,CLASS,RUNTIME</p>
<ol>
<li>RetentionPolicy.SOURCE:编译器使用后，直接丢弃这种策略的注释。</li>
<li>RetentionPolicy.CLASS：编译器将把注解记录在class文件中，当运行Java程序时，JVM不会保留注释，这是默认值。</li>
<li>RetentionPolicy.RUNTIME:编译器将把注释记录在class文件中，当运行java、程序时，JVM会保留注解，程序可以通过反射获取该注释。</li>
</ol>
</li>
<li><p>Target  &#x2F;&#x2F;指定注释可以在哪些地方使用。</p>
<ol>
<li>&#96;&#96;&#96;java<br>@Target(value&#x3D;{	CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE})<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. Documented  //指定该注释是否会在javadoc体现。</span><br><span class="line"></span><br><span class="line">4. Inherited   //子类会继承父类注释。</span><br><span class="line"></span><br><span class="line">   * 被它修饰的Annptation将具有继承性，如果某个类使用了被@inherited修饰的Annotation，则其子类将自动具有该注解。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 32. 异常</span><br><span class="line"></span><br><span class="line">将程序中发生的不正常情况称为“异常”，程序就会抛出异常 ：XXXXException</span><br><span class="line"></span><br><span class="line">可以使用  Ctrl + Alt + T 快捷处理</span><br><span class="line"></span><br><span class="line">执行过程中发生的异常可以分为两类：</span><br><span class="line"></span><br><span class="line">* Error(错误)： java虚拟机无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。</span><br><span class="line">* Exception(异常):其他因为编程错误或者偶然的外在因素所导致的一般性问题，可以使用针对的代码进行处理，例如空指针访问，试图读取不存在的文件，网络链接中断。Exception分为两大类：运行时异常和编译异常。</span><br><span class="line"></span><br><span class="line">==当程序抛出异常后程序就退出，下面的代码就不再执行了。==</span><br><span class="line"></span><br><span class="line">可以使用try-catch异常处理机制来捕获异常。保证程序的健壮性。</span><br><span class="line"></span><br><span class="line">使用了异常处理机制。即使出现了异常，也会继续执行。（从出现异常的try块中语句跳转到catch或finally中，不会继续执行try块中的语句）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">try&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="32-1-异常体系图"><a href="#32-1-异常体系图" class="headerlink" title="32.1 异常体系图"></a>32.1 异常体系图</h4><blockquote>
<p>所有异常的都继承了Serializable接口，继承了Object类</p>
</blockquote>
<p>[<a target="_blank" rel="noopener" href="https://imgtu.com/i/biOxl6"><img src="https://s4.ax1x.com/2022/02/24/biOxl6.md.png" alt="biOxl6.md.png"></a></p>
<blockquote>
<ol>
<li>异常分为两大类，运行时异常和编译时异常。</li>
<li>运行时异常，编译器检测不出来。编译器不要求强制处理的异常，一般只是编程时的逻辑错误，是成员需要应该避免其出现的异常。java.long.RuntimeException类及他的子类都是运行时异常。</li>
<li>对于运行时异常，可以不做处理，因为这列异常很普遍，如果全处理可能会对程序的可读性和运行效率产生影响，</li>
<li>编译时异常，是编译器要求必须处理的异常。&#x3D;&#x3D;方法抛出编译异常，使用方法时必须处理异常。&#x3D;&#x3D;</li>
</ol>
</blockquote>
<h4 id="31-2-常见的运行时异常"><a href="#31-2-常见的运行时异常" class="headerlink" title="31.2 常见的运行时异常"></a>31.2 常见的运行时异常</h4><blockquote>
<ol>
<li>NullPointerException 空指针异常</li>
<li>ArithmeticException 数学运算异常</li>
<li>ArrayIndexOutOfBundsException 数组下标越界异常</li>
<li>ClassCastException 类型转换异常</li>
<li>NumberFormatException 字符串不能转换为数字</li>
</ol>
</blockquote>
<h4 id="31-3-常见的编译异常"><a href="#31-3-常见的编译异常" class="headerlink" title="31.3 常见的编译异常"></a>31.3 常见的编译异常</h4><blockquote>
<p>编译异常是只在编译期间，就必须处理的异常，否则代码不能通过编译。</p>
<p>SQLException 操作数据库时，查询表可能发生异常。</p>
<p>IOException 操作文件时，发生的异常。</p>
<p>FileNotFoundException 当操作一个不存在的文件时，发生异常</p>
<p>ClassNotFoundException 加载类，而该类不存在时，发生异常。</p>
<p>EOFException 操作文件，到文件末尾。发生异常。</p>
<p>IllegalArguementException 参数异常</p>
</blockquote>
<h4 id="31-4-异常处理"><a href="#31-4-异常处理" class="headerlink" title="31.4 异常处理"></a>31.4 异常处理</h4><blockquote>
<p>异常处理就是当发生异常时，对异常处理的方式。</p>
<ol>
<li>try—catch—finally 程序员在代码中捕获发生的异常，自行处理。</li>
<li>throws 将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理就是JVM。(JVM的处理方法就是打印异常，终止程序)</li>
</ol>
</blockquote>
<p>try—catch—finally </p>
<blockquote>
<p>java提供try和catch块来处理异常，try块用于包含可能出错的代码，catch块用与处理try块中发生的异常，可以根据需要在程序中有多个try- catch块。</p>
<p>可以省略finally</p>
<p>细节：</p>
<ul>
<li><p>&#x3D;&#x3D;如果异常发生了，则异常发生后面的代码不会立即执行，直接进入到catch块中&#x3D;&#x3D;。</p>
</li>
<li><p>如果异常没有发生，则顺序执行try的代码块，不会进入到catch中。</p>
</li>
<li><p>如果希望不管是否发生异常，都执行某段代码，使用finally块。(当出现异常却抛出时，会优先执行finally再往外继续处理)</p>
</li>
<li><p>可以有多个catch语句，不同的异常(进行不同的业务处理)，要求父类异常在后，子类异常在前，如果发生异常，只会匹配一个catch。</p>
<ul>
<li>&#96;&#96;&#96;java<br>try {<br>String str &#x3D; “数字转换”;<br>}<br>catch (子类异常 e) {            &#x2F;&#x2F;同时可以捕获多种异常<br>&#x2F;&#x2F;处理异常代码<br>}<br>catch (父类异常 e) {<br>&#x2F;&#x2F;处理异常代码<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>可以直接进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉。但是finally中语句会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">try &#123;</span><br><span class="line">         可能有异常的代码</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">          //当系统发生异常时，系统将异常封装成Exception对象 e传递给catchS</span><br><span class="line"> 		  //得到异常对象后可以自己处理</span><br><span class="line">   	   //如果try代码块未产生异常，catch不会执行。</span><br><span class="line">       &#125;</span><br><span class="line">       finally &#123;</span><br><span class="line">           //不管try代码块是否有异常产生，始终要执行finally。</span><br><span class="line">           //通常将释放资源的代码放置</span><br><span class="line">       &#125;</span><br><span class="line">//例子：</span><br><span class="line">try &#123;</span><br><span class="line">         String str = &quot;数字转换&quot;;</span><br><span class="line">       &#125; </span><br><span class="line">catch (NumberFormatException e) &#123;            //同时可以捕获多种异常</span><br><span class="line">          int a = Integer.pareInt(str);</span><br><span class="line">       &#125;</span><br><span class="line">catch (Exception e) &#123;</span><br><span class="line">          int a = Integer.pareInt(str);</span><br><span class="line">       &#125;</span><br><span class="line">finally &#123;</span><br><span class="line">           System.out.println(&quot;输出&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p>throws</p>
<blockquote>
<p>使用throws抛出异常最终被抛出到JVM，JVM的处理方式为;输出异常信息，退出程序。</p>
<p>如果没有显示的处理异常，默认就是throws。(方法会有一个不显示的throws Exception)</p>
<p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<p>在方法声明中使用throws可以声明抛出异常的列表，throws后面的异常类型可以时方法中产生的异常类型，也可以是他的父类。</p>
<p>细节：</p>
<ul>
<li>对于编译异常，程序中必须处理，</li>
<li>对于运行时异常，方法中如果没有处理，默认就是throws的处理方式。</li>
<li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型。(&#x3D;&#x3D;子类不能扩大父类抛出异常的类型&#x3D;&#x3D;)</li>
<li>在throws中，如果有方法try-catch，就相当于处理异常，就可以不必throws。</li>
<li>方法抛出编译异常时，使用该方法必须处理编译时异常。</li>
<li>方法抛出运行时异常时，使用该方法不需要处理异常，由默认的处理异常机制。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  <span class="comment">//可以是父类也可以是发生的异常，也可以是一个异常的列表，可以抛出多个异常</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bFPsCF"><img src="https://s4.ax1x.com/2022/02/24/bFPsCF.md.png" alt="bFPsCF.md.png"></a></p>
<h4 id="31-5-自定义异常"><a href="#31-5-自定义异常" class="headerlink" title="31.5  自定义异常"></a>31.5  自定义异常</h4><blockquote>
<p>当程序中出现某些‘错误‘，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类用于描述该错误信息。</p>
<p>自定义异常的步骤</p>
<ol>
<li><p>定义类：自定义异常类名，继承Exception或者RuntimeException</p>
</li>
<li><p>如果继承Exception，属于编译异常。</p>
</li>
<li><p>如果继承RuntimeException，属于运行异常。(一般来说继承RunTimeException)</p>
</li>
<li><p>在自定义异常类中创建构造器，使用super()方法向父类构造器传递异常显示信息。(super方法接收的是一个字符串类型)</p>
</li>
<li><p>在方法体中，使用throw关键字手动调用异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类(异常输出字符)；</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;异常&quot;</span>);<span class="comment">//手动调用自定义异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义异常类，继承RuntimeException或者Exception</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后接</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h3 id="32-包装类"><a href="#32-包装类" class="headerlink" title="32 包装类"></a>32 包装类</h3><blockquote>
<p>针对八种基本数据类型的引用类型–包装类(wrapper)</p>
<p>有类的特点，就可以调用类中的方法。</p>
</blockquote>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td><strong>Boolean</strong></td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bFHbp6"><img src="https://s4.ax1x.com/2022/02/24/bFHbp6.md.png" alt="bFHbp6.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bFbi1f"><img src="https://s4.ax1x.com/2022/02/24/bFbi1f.md.png" alt="bFbi1f.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bFbkjS"><img src="https://s4.ax1x.com/2022/02/24/bFbkjS.md.png" alt="bFbkjS.md.png"></a></p>
<blockquote>
<p>Byte,Integer,Long,Float,Double,Short 都继承Number</p>
<p>Boolean，Character继承objhect</p>
</blockquote>
<h4 id="32-1-包装类和基本数据的转换"><a href="#32-1-包装类和基本数据的转换" class="headerlink" title="32.1 包装类和基本数据的转换"></a>32.1 包装类和基本数据的转换</h4><blockquote>
<p>包装类和基本数据类型可以互相转换。</p>
<p>jdk5 前的手动装箱和拆箱方式，装箱：基本类型 -&gt; 包装类型</p>
<p>拆箱和装箱有两种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;    </span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="type">int</span> i= integer.intValue();</span><br></pre></td></tr></table></figure>

<p>jdk5 以后(含jdk5)的自动拆箱和装箱方式。</p>
<p>自动装箱使用的ValueOf()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> i；  <span class="comment">//底层实际上使用Integer.valueOf(i);</span></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自动装箱底层调用的是valueOf方法。</p>
<p>Integer.valueOf()中接收的值如果在-128到127范围内，不会new Integer，直接使用缓存存储数据；在创建时就会创建一个IntegerCache.cache数组，数组范围在-128到127，只要在此范围内不需要重新new。</p>
<p>含有缓冲数组的包装类：Integer，Char，Short</p>
<p>&#x3D;&#x3D;包装类和基本类作比较，只要存在基本数据类型，“ &#x3D;&#x3D; ”号比较的就是值是否相等。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="comment">//IntegerCache.low 为-128 IntegerCache.high为 127</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>三元运算符补充：</p>
<blockquote>
<p>三元运算符为一个整体，会提升精度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">true</span>?<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>):<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>);</span><br><span class="line">        System.out.println(obj);<span class="comment">//输出为1.0</span></span><br></pre></td></tr></table></figure>

<h4 id="32-2-包装类和String数据类型的相互转换。"><a href="#32-2-包装类和String数据类型的相互转换。" class="headerlink" title="32.2 包装类和String数据类型的相互转换。"></a>32.2 包装类和String数据类型的相互转换。</h4><blockquote>
<p>包装类和String类型可以相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类 ----&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>；</span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> i.toString();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"><span class="comment">//方式三</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String ----&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s1);</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(s2);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="33-String类"><a href="#33-String类" class="headerlink" title="33. String类"></a>33. String类</h3><blockquote>
<ol>
<li>String 对象用于保存字符串，也就是一组字符序列。</li>
<li>字符串常量对象用双括号括起来的字符序列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;doubao&quot;</span>;字符串的字符使用Unicode字符编码，一个字符(不区分字母和汉字)占用两个字节。（<span class="type">char</span>占用两个字节）</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>String类是被final修饰的，不允许被继承。</li>
<li>String类有许多构造方法，常用的构造方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> statIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>String类实现了接口 Serializable说明String可以串行化。(可以在网络传输)</li>
<li>String类实现了接口Comparable说明String类可以比较。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bZ8B9K"><img src="https://s4.ax1x.com/2022/02/26/bZ8B9K.md.png" alt="bZ8B9K.md.png"></a></p>
</blockquote>
<blockquote>
<ol start="7">
<li>String类中有属性private final char value[]用于存放字符串内容。value是final类型的，不能修改。(value[]的地址不能修改)但是单个字符的内容可以修改。</li>
</ol>
</blockquote>
<h4 id="33-1-String创建"><a href="#33-1-String创建" class="headerlink" title="33.1 String创建"></a>33.1 String创建</h4><blockquote>
<p>String 创建对象的两种方式。</p>
<p>方式一： 直接赋值 String str &#x3D; “douabo”;</p>
<ul>
<li>先从常量池查看是否有“doubao”的数据空间，如果有，直接指向，如果没有则重新创建，然后指向，str最终指向的是常量池的空间地址。</li>
</ul>
<p>方式二：调用构造器 String s &#x3D; new String(“doubao”)；</p>
<ul>
<li>现在堆中创建空间，里面维护了value属性，指向常量池的“doubao”。如果常量池中没有“douabo”，重新创建，如果有，直接通过value指向，最终指向的是堆中的空间地址。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bZNo0e"><img src="https://s4.ax1x.com/2022/02/26/bZNo0e.md.png" alt="bZNo0e.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bZT3o4"><img src="https://s4.ax1x.com/2022/02/26/bZT3o4.md.png" alt="bZT3o4.md.png"></a></p>
<h4 id="33-2-String类的特性："><a href="#33-2-String类的特性：" class="headerlink" title="33.2 String类的特性："></a>33.2 String类的特性：</h4><blockquote>
<p>编译器会进行优化，不会浪费资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;dou&quot;</span> + <span class="string">&quot;bao&quot;</span>;<span class="comment">//两个常量相加看池中，</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> str2 + str3; <span class="comment">//两个变量相加看堆</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bZTsFH"><img src="https://s4.ax1x.com/2022/02/26/bZTsFH.md.png" alt="bZTsFH.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bZ7d9s"><img src="https://s4.ax1x.com/2022/02/26/bZ7d9s.md.png" alt="bZ7d9s.md.png"></a></p>
<h4 id="33-3-String类的常用方法"><a href="#33-3-String类的常用方法" class="headerlink" title="33.3 String类的常用方法"></a>33.3 String类的常用方法</h4><blockquote>
<p>String 类是保存字符串常量的，每次更新都需要开辟空间，效率较低，因此java设计者提供了StringBuilder和StringBuffer来增强String的功能，并提高效率。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>equals</td>
<td>判断内容是否相等</td>
<td></td>
</tr>
<tr>
<td>equalslgnoreCase</td>
<td>忽略大小写判断内容是否相等</td>
<td></td>
</tr>
<tr>
<td>length</td>
<td>获得字符的个数，字符串的长度</td>
<td></td>
</tr>
<tr>
<td>indexOf</td>
<td>获取字符在字符串中第一次出现的索引，索引从0开始</td>
<td>未找到返回-1</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>获取字符在字符串中最后一次出现的索引，索引从0开始</td>
<td>未找到返回-1</td>
</tr>
<tr>
<td>substring</td>
<td>截取指定范围的字串</td>
<td>包括开始，不包括结束</td>
</tr>
<tr>
<td>trim</td>
<td>去前后空格</td>
<td></td>
</tr>
<tr>
<td>charAt</td>
<td>获取某索引处的字符</td>
<td>不能使用Str[index]</td>
</tr>
<tr>
<td>toUpperCase</td>
<td>将字符串转换为大写</td>
<td></td>
</tr>
<tr>
<td>toLowerCase</td>
<td>将字符串转换为小写</td>
<td></td>
</tr>
<tr>
<td>concat</td>
<td>拼接字符串</td>
<td></td>
</tr>
<tr>
<td>compareTo</td>
<td>比较两个字符串的大小</td>
<td></td>
</tr>
<tr>
<td>toCharArray</td>
<td>转换成字符数组</td>
<td></td>
</tr>
<tr>
<td>format</td>
<td>使用占位符格式化字符串</td>
<td>有点像c语言</td>
</tr>
<tr>
<td>replace</td>
<td>替换字符串中的字符</td>
<td>对原本字符串无影响，返回替换后的字符串</td>
</tr>
<tr>
<td>split</td>
<td>分割字符串</td>
<td>传入分割依据为分隔参数</td>
</tr>
</tbody></table>
<hr>
<h3 id="34-StringBuffer"><a href="#34-StringBuffer" class="headerlink" title="34. StringBuffer"></a>34. StringBuffer</h3><blockquote>
<ul>
<li>java .long.StringBuffer代表可变字符序列。可以对字符串的内容进行增删。</li>
<li>&#x3D;&#x3D;StringBuffer是线程安全的&#x3D;&#x3D;。</li>
<li>很多方法与String相同，但&#x3D;&#x3D;是StringBuffer是可变长度的。&#x3D;&#x3D;</li>
<li>StringBuffer是一个容器。</li>
<li>StringBuffer实现了Serializable，即StringBuffer的对象是可以串行化的。</li>
<li>StringBuffer继承了父类AbstractStringBuilder，在父类中，有属性char[] value，不是final。</li>
<li>该value数组存放字符串内容，存放在堆中。(String存放在常量池)</li>
<li>StringBuffer是一个final类。不能被继承。</li>
<li><code>System.out.priintln(strBuffer)</code> 实际上就是调用StringBuilder的toString()方法。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bmDUUK"><img src="https://s4.ax1x.com/2022/02/27/bmDUUK.md.png" alt="bmDUUK.md.png"></a></p>
<h4 id="String类与StringBuffer类区别"><a href="#String类与StringBuffer类区别" class="headerlink" title="String类与StringBuffer类区别"></a>String类与StringBuffer类区别</h4><blockquote>
<p>String 保存的是字符串常量，里面的值不能修改，每次String类的更新实际上就是更改地址，效率较低。<code>private final char value[];</code></p>
<p>StringBuffer 存的是字符串变量，里面的值可以更改，每次StringBuffer 更新实际上可以更新内容，不用每次更新地址，效率比较高。<code>char[] value;</code>（空间大小不够时也会更新地址）</p>
</blockquote>
<h4 id="StringBuffer构造器"><a href="#StringBuffer构造器" class="headerlink" title="StringBuffer构造器"></a>StringBuffer构造器</h4><blockquote>
<p>StringBuffer()构造器</p>
</blockquote>
<ol>
<li>StringBuffer() 构造的字符串缓冲区，其初始容量为16个字符。</li>
<li>StringBuffer(CharSequence seq) 构造一个字符串缓冲区，他包含指定的CharSequence相同的字符。</li>
<li>StringBuffer(int 容量） 构造一个不带字符，但是具有指定初始容量的字符串缓冲区，即对char[]大小进行指定。</li>
<li>StringBuffer(String str) 构造一个字符串缓冲区。将其内容初始化为指定的字符串内容。    &#x2F;&#x2F;其中value数组的长度为str.length + 16</li>
</ol>
<h4 id="String-与StringBuffer互相进行转换"><a href="#String-与StringBuffer互相进行转换" class="headerlink" title="String 与StringBuffer互相进行转换"></a>String 与StringBuffer互相进行转换</h4><blockquote>
<p>String转换为stringBuffer</p>
<ul>
<li>调用new StringBuffer(str)构造器后如果传入字符为null则会报错。抛出空指针异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String----&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;douabo&quot;</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str); <span class="comment">//返回的才是StringBuffer类型的对象与原来字符串无影响</span></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">strb2.append(str);</span><br><span class="line"><span class="comment">//返回的才是StringBuffer类型的对象与原来字符串无影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer----&gt;String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strb.toString();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h4><blockquote>
<p>增加： append()  </p>
<p>删除：delete(start,end)</p>
<p>改：replace(start,end,string)</p>
<p>查找 ： indexOf(str) </p>
<p>插入： insert()</p>
<p>获取长度: length</p>
</blockquote>
<h5 id="append-增加"><a href="#append-增加" class="headerlink" title="append() 增加"></a>append() 增加</h5><blockquote>
<p>使用append()方法向指定的StringBuffer对象最后添加指定字符串。</p>
<ul>
<li>当append(str)&#x3D;&#x3D;添加的字符串为null时，不会报错&#x3D;&#x3D;，而是返回一个字符串长度为四的”null”。（调用构造方法时输入null会报错）</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">System.out.println(strb);</span><br><span class="line">strb.append(<span class="string">&quot;xin&quot;</span>);</span><br><span class="line">System.out.println(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="delete-删除"><a href="#delete-删除" class="headerlink" title="delete() 删除"></a>delete() 删除</h5><blockquote>
<p>使用delete(start,end)删除指定开始到指定末尾之间的元素。&#x3D;&#x3D;包括开始元素不包括结束元素。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">strb.delete(<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">//包含开始元素不包含结束元素</span></span><br><span class="line">System.out.println(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace() 替换"></a>replace() 替换</h5><blockquote>
<p>使用replace(start,end,replace) 将指定开始和指定结束之间的字符使用指定的字符进行替换。&#x3D;&#x3D;包含开始元素不包含结束元素。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">strb.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&quot;豆包&quot;</span>);</span><br><span class="line">System.out.println(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="indexOf-str"><a href="#indexOf-str" class="headerlink" title="indexOf(str)"></a>indexOf(str)</h5><blockquote>
<p>查找字符串中指定字符串第一次出现的索引。如果没有查找到返回-1.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(strb.indexOf(<span class="string">&quot;a&quot;</span>)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<h5 id="insert-start-string-插入"><a href="#insert-start-string-插入" class="headerlink" title="insert(start,string) 插入"></a>insert(start,string) 插入</h5><blockquote>
<p>在指定索引处插入指定字符串。原本指定索引位置的字符串后移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">strb.insert(<span class="number">3</span>,<span class="string">&quot;豆包&quot;</span>);</span><br><span class="line">System.out.println(strb);<span class="comment">//dou豆包abo</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="35-StringBuilder"><a href="#35-StringBuilder" class="headerlink" title="35. StringBuilder"></a>35. StringBuilder</h3><blockquote>
<p>一个可变字符序列，为此类提供一个与StringBuffer兼容的API，但不保证同步，该类被设计用作StringBuffer的一个建议替换，用在字符串缓冲区被&#x3D;&#x3D;单个线程使用的时候&#x3D;&#x3D;，如果可能，建议采用该类，因为在大多数实现中，StringBuilder要比StringBuffer要快。</p>
<p>但是StringBuilder不是线程安全。</p>
<p>StringBuilder是一个final类，是不可以被继承的。</p>
<p>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接收任意类型的数据。</p>
<ul>
<li>StringBuilder实现了Serializable，即StringBuilder的对象是可以串行化的。(对象可以网络传输，可以保存到文件)</li>
<li>StringBuilder继承了父类AbstractStringBuilder，在父类中，有属性char[] value，不是final。因此字符序列是存储在堆中的。</li>
<li>StringBuilder的方法，没有做互斥的处理，即没有synchronized关键字，因此在单线程的情况下使用。</li>
</ul>
</blockquote>
<h4 id="35-1-StringBuilder常用方法"><a href="#35-1-StringBuilder常用方法" class="headerlink" title="35.1 StringBuilder常用方法"></a>35.1 StringBuilder常用方法</h4><blockquote>
<p>StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。(StringBuilder和StringBuffer都继承了AbstractStringBuilder父类)</p>
</blockquote>
<blockquote>
<p>增加： append()  </p>
<p>删除：delete(start,end)</p>
<p>改：replace(start,end,string)</p>
<p>查找 ： indexOf(str) </p>
<p>插入： insert()</p>
<p>获取长度: length</p>
</blockquote>
<h5 id="append-增加-1"><a href="#append-增加-1" class="headerlink" title="append() 增加"></a>append() 增加</h5><blockquote>
<p>使用append()方法向指定的StringBuffer对象最后添加指定字符串。</p>
<ul>
<li>当append(str)添加的字符串为null时，不会报错，而是返回一个字符串长度为四的”null”。</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">System.out.println(strb);</span><br><span class="line">strb.append(<span class="string">&quot;xin&quot;</span>);</span><br><span class="line">System.out.println(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="delete-删除-1"><a href="#delete-删除-1" class="headerlink" title="delete() 删除"></a>delete() 删除</h5><blockquote>
<p>使用delete(start,end)删除指定开始到指定末尾之间的元素。&#x3D;&#x3D;包括开始元素不包括结束元素。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">strb.delete(<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">//包含开始元素不包含结束元素</span></span><br><span class="line">System.out.println(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="replace-替换-1"><a href="#replace-替换-1" class="headerlink" title="replace() 替换"></a>replace() 替换</h5><blockquote>
<p>使用replace(start,end,replace) 将指定开始和指定结束之间的字符使用指定的字符进行替换。&#x3D;&#x3D;包含开始元素不包含结束元素。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">strb.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">&quot;豆包&quot;</span>);</span><br><span class="line">System.out.println(strb);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="indexOf-str-1"><a href="#indexOf-str-1" class="headerlink" title="indexOf(str)"></a>indexOf(str)</h5><blockquote>
<p>查找字符串中指定字符串第一次出现的索引。如果没有查找到返回-1.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(strb.indexOf(<span class="string">&quot;a&quot;</span>)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<h5 id="insert-start-string-插入-1"><a href="#insert-start-string-插入-1" class="headerlink" title="insert(start,string) 插入"></a>insert(start,string) 插入</h5><blockquote>
<p>在指定索引处插入指定字符串。原本指定索引位置的字符串后移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">strb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;douabo&quot;</span>);</span><br><span class="line">strb.insert(<span class="number">3</span>,<span class="string">&quot;豆包&quot;</span>);</span><br><span class="line">System.out.println(strb);<span class="comment">//dou豆包abo</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="35-2-String-与-StringBuffer-与-StringBuilder的比较"><a href="#35-2-String-与-StringBuffer-与-StringBuilder的比较" class="headerlink" title="35.2 String 与 StringBuffer 与 StringBuilder的比较"></a>35.2 String 与 StringBuffer 与 StringBuilder的比较</h4><blockquote>
<p>StringBuilder 和 StringBuffer非常类似，均代表可变的字符序列，而且方法也一样。</p>
<p>String: 不可变字符序列，效率低，但是复用率高。</p>
<p>StringBuffer: 可变字符序列，效率较高(增删)，线程安全。</p>
<p>StringBuffer中的方法前加修饰符 synchronized（同步）</p>
<p>StringBuilder：可变字符序列，效率最高，线程不安全。</p>
</blockquote>
<h4 id="35-3-String-与-StringBuffer-与-StringBuilder的选择"><a href="#35-3-String-与-StringBuffer-与-StringBuilder的选择" class="headerlink" title="35.3 String 与 StringBuffer 与 StringBuilder的选择"></a>35.3 String 与 StringBuffer 与 StringBuilder的选择</h4><blockquote>
<p>如果字符串存在大量的修改操作，一般使用StringBuffer 与 StringBuilder。</p>
<p>如果字符串存在大量的修改操作，并在单线程的情况下，使用StringBuilder</p>
<p>如果字符串存在大量的修改操作，并且在多线程的情况下，使用StringBuffer</p>
<p>如果字符串很少修改，并且被多个对象引用，比如配置信息,使用String</p>
</blockquote>
<h3 id="36-Math"><a href="#36-Math" class="headerlink" title="36. Math"></a>36. Math</h3><blockquote>
<p>Math类包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数。</p>
</blockquote>
<p>常用方法：</p>
<blockquote>
<p>Math中的类大多数都是静态方法</p>
</blockquote>
<blockquote>
<p>abs() 绝对值</p>
<p>pow() 求幂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(<span class="number">2</span>,<span class="number">4</span>); 求<span class="number">2</span>的<span class="number">4</span>次方</span><br></pre></td></tr></table></figure>

<p>ceil() 向上取整</p>
<p>floor() 向下取整</p>
<p>round() 四舍五入</p>
<p>sqrt() 求开方</p>
<p>random() 求随机数,返回的是0–1之间的随机小数(能取到0不饿能取到1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求a--b之间的整数倍</span></span><br><span class="line">(<span class="type">int</span>)(a + Math.random() * (b-a +<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<p>max() 求两个数的最大值</p>
<p>min() 求两个数的最小值</p>
</blockquote>
<h3 id="37-Arrays"><a href="#37-Arrays" class="headerlink" title="37. Arrays"></a>37. Arrays</h3><blockquote>
<p>Arrays里面包含了一系列静态方法，用于管理或者操作数组。(比如排序和搜索)</p>
</blockquote>
<h4 id="37-1-Arrays常用方法"><a href="#37-1-Arrays常用方法" class="headerlink" title="37.1 Arrays常用方法"></a>37.1 Arrays常用方法</h4><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><blockquote>
<p>Arrays.toString(arr)</p>
<p>返回数组的字符串形式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(integers));</span><br></pre></td></tr></table></figure>





<h5 id="sort排序-自然排序和定制排序"><a href="#sort排序-自然排序和定制排序" class="headerlink" title="sort排序(自然排序和定制排序)"></a>sort排序(自然排序和定制排序)</h5><blockquote>
<p>Arrays.sort(arr)可以对传入的数组进行排序。</p>
<p>数组为引用类型，所以通过sort排序后，会直接影响到实参。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Arrays.sort(integers);</span><br><span class="line">System.out.println(Arrays.toString(integers));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sort是重载的，可以通过传入一个接口Comparator实现定制排序。</p>
<p>调用定制排序时，传入两个参数</p>
<ol>
<li>需要排序的数组</li>
<li>实现了Comparator接口的匿名内部类，要求实现compare方法</li>
<li>实现接口中compare()方法的返回值大于或者小于0会影响排序的内部逻辑。本质就是冒泡排序中控制顺序的语句由compare方法返回值控制。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.sort(integers, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer)o1;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer)o2;</span><br><span class="line">                <span class="keyword">return</span> i2-i1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="binarySeach-二分法查找"><a href="#binarySeach-二分法查找" class="headerlink" title="binarySeach 二分法查找"></a>binarySeach 二分法查找</h5><blockquote>
<p>通过二分搜索法进行查找，要求必须已经有顺序。</p>
<p>Arrays.binarySearch(数组,元素);</p>
<p>如果数组中不存在&#x3D;&#x3D;返回-(low + 1)&#x3D;&#x3D;。(应该存在的位置+1取负数)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     Integer[] integers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     Arrays.sort(integers);</span><br><span class="line"></span><br><span class="line">     Arrays.binarySearch(integers,<span class="number">1</span>);</span><br><span class="line">            			               			          System.out.println(Arrays.binarySearch(integers,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="copyOf-数组复制"><a href="#copyOf-数组复制" class="headerlink" title="copyOf 数组复制"></a>copyOf 数组复制</h5><blockquote>
<p>Arrays.copyOf(数组,元素个数);</p>
<p>从指定数组中复制指定个数个元素组成新的数组返回.</p>
<p>如果需要拷贝的个数大于原本的个数，则在多余的部分赋值为null。</p>
<p>如果需要拷贝的个数为负数，则抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">Integer[] newarr = Arrays.copyOf(arr,arr.length);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="fill-数组填充"><a href="#fill-数组填充" class="headerlink" title="fill 数组填充"></a>fill 数组填充</h5><blockquote>
<p>Arrays.fill(数组,元素);</p>
<p>向指定数组中填充数组，可以理解成替换原本的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">     Arrays.fill(integers,<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(Arrays.toString(integers));</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="equals-比较"><a href="#equals-比较" class="headerlink" title="equals 比较"></a>equals 比较</h5><blockquote>
<p>比较两个数组元素内容是否完全一致</p>
<p>Arrays.equals(数组,数组)</p>
<p>如果一致返回true如果不一致返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">     Integer[] integers1 = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">istrue</span> <span class="operator">=</span> Arrays.equals(integers,integers1);</span><br><span class="line"></span><br><span class="line">     System.out.println(istrue);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="asList-转换列表"><a href="#asList-转换列表" class="headerlink" title="asList 转换列表"></a>asList 转换列表</h5><blockquote>
<p>将一组值转换为list</p>
<p>Arrays.asList(1,2,3,4,5)</p>
<p>asList的运行类型为 java.util.Arrays#ArrayList,是内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; asList = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(asList);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="38-System"><a href="#38-System" class="headerlink" title="38. System"></a>38. System</h3><h4 id="38-1-System常见方法"><a href="#38-1-System常见方法" class="headerlink" title="38.1 System常见方法"></a>38.1 System常见方法</h4><h5 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h5><blockquote>
<p>退出当前程序</p>
<p>System.exit(退出状态)；</p>
<p>0：表示正常退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sysyem.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="arraycopy"><a href="#arraycopy" class="headerlink" title="arraycopy()"></a>arraycopy()</h5><blockquote>
<p>复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组。(Arrays.copyOf()底层使用arraycopy()方法完成数组的复制)</p>
<p>System.arraycopy(原数组,元素值索引,被拷贝数据,被拷贝数组开始索引,拷贝数量)</p>
<p>如果越界会被抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="currentTimeMillens"><a href="#currentTimeMillens" class="headerlink" title="currentTimeMillens"></a>currentTimeMillens</h5><blockquote>
<p>返回当前时间距离1970-1-1的毫秒数。</p>
<p>System.currentTimeMillens()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h5><blockquote>
<p>运行垃圾回收机制。</p>
<p>并不是百分之百运行垃圾回收机制。</p>
<p>System.gc()</p>
</blockquote>
<h3 id="39-BigInteger与BigDecimal"><a href="#39-BigInteger与BigDecimal" class="headerlink" title="39. BigInteger与BigDecimal"></a>39. BigInteger与BigDecimal</h3><blockquote>
<p>BigInteger适合保存比较大的整型。</p>
<p>BigDecimal适合保存精度更高的浮点数(小数)。</p>
</blockquote>
<h4 id="39-1-BigInteger"><a href="#39-1-BigInteger" class="headerlink" title="39.1 BigInteger"></a>39.1 BigInteger</h4><blockquote>
<p>在编程中可能需要处理很长的整数，long把不够用。</p>
<p>BigInteger bigInteger &#x3D; new BigInteger(数字);</p>
<p>BigInteger bigInteger &#x3D; new BigInteger(“数字”);</p>
<p>可以向BigInteger中传入字符串，底层会将字符串转换为数据类型。</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">123456789123456789</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(“<span class="number">123456789123456789</span>”);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="39-2-BigInteger方法"><a href="#39-2-BigInteger方法" class="headerlink" title="39.2 BigInteger方法"></a>39.2 BigInteger方法</h4><blockquote>
<p>在BigInteger中进行加减乘除时，不能直接进行，需要使用对应的方法。</p>
</blockquote>
<p>add() 加法</p>
<blockquote>
<p>BigInteger.add(数字)；</p>
<p>可以与BigInteger类型相加也可以和long类型相加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12435680987&quot;</span>);</span><br><span class="line">     <span class="type">BigInteger</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12435680987&quot;</span>);</span><br><span class="line">     bg = bg.add(bg1);</span><br><span class="line">     System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>subtract() 减法</p>
<blockquote>
<p>BigInteger.subtract(数字)；</p>
<p>可以与BigInteger类型相减也可以和long类型相减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12435680987&quot;</span>);</span><br><span class="line">     <span class="type">BigInteger</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12435680987&quot;</span>);</span><br><span class="line">     bg = bg.subtract(bg1);</span><br><span class="line">     System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>multiply() 乘法</p>
<blockquote>
<p>BigInteger.add(数字)；</p>
<p>可以与BigInteger类型相乘也可以和long类型相乘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12435680987&quot;</span>);</span><br><span class="line">     <span class="type">BigInteger</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">     bg = bg.multiply(bg1);</span><br><span class="line">     System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>divide() 除法</p>
<blockquote>
<p>BigInteger.divide(数字)；</p>
<p>可以与BigInteger类型相加也可以和long类型相加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12435680987&quot;</span>);</span><br><span class="line">     <span class="type">BigInteger</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">     bg = bg.divide(bg1);</span><br><span class="line">     System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="39-3-BigDicimal"><a href="#39-3-BigDicimal" class="headerlink" title="39.3 BigDicimal"></a>39.3 BigDicimal</h4><blockquote>
<p>当需要存储精度特别大的小数时可以使用BigDecimal来存储。</p>
</blockquote>
<blockquote>
<p>BigDicimal bigdicimal &#x3D; new BigDicimal(数字);</p>
<p>BigDicimal bigdicimal &#x3D; new BigDicimal(“数字”);</p>
<p>可以向BigDicimal 中传入字符串，底层会将字符串转换为数据类型。</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.23242354235454&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="39-3-BigDicimal方法"><a href="#39-3-BigDicimal方法" class="headerlink" title="39.3 BigDicimal方法"></a>39.3 BigDicimal方法</h4><blockquote>
<p>不能直接对BigDicimal进行加减运算，只能调用相应的方法。</p>
</blockquote>
<p>add() 加法</p>
<blockquote>
<p>BigDicimal.add(数字)；</p>
<p>只能与BigDicimal类型相加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDicimal</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2435680987&quot;</span>);</span><br><span class="line">     <span class="type">BigDicimal</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2435680987&quot;</span>);</span><br><span class="line">     bg = bg.add(bg1);</span><br><span class="line">     System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>subtract() 减法</p>
<blockquote>
<p>BigDicimal.subtract(数字)；</p>
<p>只能与BigDicimal类型相减。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDicimal</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2435680987&quot;</span>);</span><br><span class="line"><span class="type">BigDicimal</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2435680987&quot;</span>);</span><br><span class="line">bg = bg.subtract(bg1);</span><br><span class="line">System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>multiply() 乘法</p>
<blockquote>
<p>BigDicimal.add(数字)；</p>
<p>只能与BigDicimal类型相乘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDicimal</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2435680987&quot;</span>);</span><br><span class="line"><span class="type">BigDicimal</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">bg = bg.multiply() (bg1);</span><br><span class="line">System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>divide() 除法</p>
<blockquote>
<p>BigDicimal.divide(数字)；</p>
<p>只能与BigDicimal类型相加也可以和long类型相加。</p>
<p>可能会抛出异常ArithmeticException，精度太高可能会一直除下去无限循环。</p>
<p>可以在调用BigDicimal.divide()方法时添加精度。如果有无限循环小数，&#x3D;&#x3D;就会保留分子的精度。&#x3D;&#x3D;</p>
<p>BigDicimal.divide(数字，BigDecimal.ROUND_CEILING)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDicimal</span> <span class="variable">bg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;1.2435680987&quot;</span>);</span><br><span class="line"><span class="type">BigDicimalr</span> <span class="variable">bg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDicimal</span>(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">bg = bg.divide(bg1);</span><br><span class="line">System.out.println(bg);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="40-日期类"><a href="#40-日期类" class="headerlink" title="40. 日期类"></a>40. 日期类</h3><h4 id="40-1-Date"><a href="#40-1-Date" class="headerlink" title="40.1 Date"></a>40.1 Date</h4><blockquote>
<p>Date:精确到毫秒，代表特定的瞬间。</p>
<p>SimpleDateFormat： 格式和解析日期的类。允许将进行格式化。</p>
<p>(日期 —&gt; 文本)(文本 —&gt; 日期)和规范化。</p>
</blockquote>
<p>构造器</p>
<blockquote>
<p>Date类中有三个构造器</p>
</blockquote>
<blockquote>
<p>无参构造器：</p>
<ol>
<li>返回的格式时国外的格式，通常需要对格式进行转换。</li>
<li>使用SimpleDateFormat类中的format()方法进行格式转换。</li>
<li>获取当前的系统时间。</li>
<li>在使用SimpleDateFormat类中的format()方法进行格式转换时，需要获取字符串的格式和传入SimpleDateFormat类构造器的格式一致，否则会抛出异常：ParseException.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//格式转换</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>毫秒数构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过毫秒数得到时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(毫秒数);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>字符串构造器</p>
<ol>
<li>可以将一个格式化的String转换成对应的Date</li>
<li>得到的Date仍然在输出时还是国外的形式。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;Wed Mar 02 19:43:55 CST 2022&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(time);</span><br><span class="line"><span class="comment">//格式转换</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">times</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(times);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="40-2-Calendar类"><a href="#40-2-Calendar类" class="headerlink" title="40.2 Calendar类"></a>40.2 Calendar类</h4><blockquote>
<p>Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，</p>
<p>DAR_OF_MONTH,HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。</p>
<p>Calendar的&#x3D;&#x3D;构造器是private，可以通过getInstance()获取。&#x3D;&#x3D;</p>
<p>Calendar提供了大量方法和字段提供调用。</p>
<p>&#x3D;&#x3D;返回月份时按照0开始编号。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cale</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//获取日历对象的某个日历字段</span></span><br><span class="line">System.out.println(<span class="string">&quot;年:&quot;</span> + cale.get(Calendar.YEAR));</span><br><span class="line"><span class="comment">//返回月份时，是 按照0编号的，需要返回值加一</span></span><br><span class="line">System.out.println(<span class="string">&quot;月:&quot;</span> + cale.get(Calendar.MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;日:&quot;</span> + cale.get(Calendar.DAY_OF_MONTH));</span><br><span class="line"><span class="comment">//返回以12进制小时数</span></span><br><span class="line">System.out.println(<span class="string">&quot;小时:&quot;</span> + cale.get(Calendar.HOUR));</span><br><span class="line">System.out.println(<span class="string">&quot;分钟:&quot;</span> + cale.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒:&quot;</span> + cale.get(Calendar.SECOND));</span><br><span class="line"><span class="comment">//返回以24进制小时数</span></span><br><span class="line">System.out.println(<span class="string">&quot;小时:&quot;</span> + cale.get(Calendar.HOUR_OF_DAY));</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>缺点：</p>
<ol>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：date中的年份从1900年开始，月份都是从零开始。</li>
<li>格式化: 格式化只对Date有用，Calendar则不行。</li>
<li>Date和Calender都不是线程安全的，不能处理闰秒。(每隔两天，多出1s)</li>
</ol>
</blockquote>
<h4 id="40-3-LocalDate，LocalTime，LocalDateTime"><a href="#40-3-LocalDate，LocalTime，LocalDateTime" class="headerlink" title="40.3 LocalDate，LocalTime，LocalDateTime"></a>40.3 LocalDate，LocalTime，LocalDateTime</h4><blockquote>
<p>LocalDate返回日期，可以获取日期字段。</p>
<p>LocalTime返回时间，可以获取时间字段。</p>
<p>LocalDateTime返回日期时间，可以获取日期和时间字段。</p>
<p>这些时间类是在JDK8中加入的。</p>
<ul>
<li>使用plus方法测试增加时间的某个日期。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="comment">//获取指定天数后的对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> ldt.plusDays(<span class="number">875</span>);</span><br><span class="line"><span class="comment">//转换格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt2);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用minus方法测试查看减少时间的某个日期</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="comment">//获取指定天数前的对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> ldt.minusDays(<span class="number">875</span>);</span><br><span class="line"><span class="comment">//转换格式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt2);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取日期和时间字段。</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">//获取日期字段。</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="comment">//获取时间字段。</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;年:&quot;</span>  + ldt.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月(英文):&quot;</span>  + ldt.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月(数字):&quot;</span>  + ldt.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日:&quot;</span>  + ldt.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时:&quot;</span>  + ldt.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分:&quot;</span>  + ldt.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒:&quot;</span>  + ldt.getSecond());</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;可以使用DateTimeFormatter对象的ofPattern方法&#x3D;&#x3D;来进行格式化。类似于SimpleDateFormat。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(format);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>时间戳</p>
<blockquote>
<p>类似于Date，提供了一系列和Date类转换的方式。</p>
<p>Instant —-&gt; Date</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.new();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br></pre></td></tr></table></figure>

<p>Date —&gt; Instant</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="41-集合"><a href="#41-集合" class="headerlink" title="41. 集合"></a>41. 集合</h3><blockquote>
<p>保存数据可以使用数组也可以使用集合。</p>
<p>数组：</p>
<ul>
<li>长度开始时必须指定，而且一旦指定，不能更改。</li>
<li>保存的必须为同一类型的元素。</li>
<li>使用数组进行增加元素比较麻烦。(创建新的数组，然后将原本数组复制到新的数组)</li>
</ul>
<p>集合：</p>
<ul>
<li>可以动态保存任意多个对象，使用比较方便。</li>
<li>提供了一系列方便的操作对象方法：add，remove，set，get。</li>
<li>集合主要是两组(单列集合，双列集合)</li>
<li>Collection接口有两个重要的子接口List，Set，他们的实现子类都是单列集合。</li>
<li>Map接口的实现子类是双列集合，存放的键值对形式。</li>
</ul>
</blockquote>
<h4 id="41-1-集合继承图"><a href="#41-1-集合继承图" class="headerlink" title="41.1 集合继承图"></a>41.1 集合继承图</h4><blockquote>
<p>集合主要是两组(单列集合，双列集合)</p>
<p>Collection接口有两个重要的子接口List，Set，他们的实现子类都是单列集合。</p>
<p>Map接口的实现子类是双列集合，存放的键值对形式。</p>
</blockquote>
<h4 id="-1"><a href="#-1" class="headerlink" title></a><a target="_blank" rel="noopener" href="https://imgtu.com/i/btnYcj"><img src="https://s4.ax1x.com/2022/03/03/btnYcj.md.png" alt="btnYcj.md.png"></a></h4><h4 id="-2"><a href="#-2" class="headerlink" title></a><a target="_blank" rel="noopener" href="https://imgtu.com/i/btmwfe"><img src="https://s4.ax1x.com/2022/03/03/btmwfe.md.png" alt="btmwfe.md.png"></a></h4><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/btn2uR"><img src="https://s4.ax1x.com/2022/03/03/btn2uR.md.png" alt="btn2uR.md.png"></a></p>
<h4 id="41-2-Collection接口"><a href="#41-2-Collection接口" class="headerlink" title="41.2 Collection接口"></a>41.2 Collection接口</h4><blockquote>
<p>Collection接口的实现子类可以存放多个元素，每个元素可以是Object。</p>
<p>有些Collection的实现类，可以存放重复的元素，有些不可以。</p>
<p>有些Collection的实现类，是有序的(list),有些不是有序的(set)。</p>
<p>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现。</p>
</blockquote>
<p>接口中的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>添加单个元素(其中元素为对象)</td>
<td>放置基本数据类型自动装箱</td>
</tr>
<tr>
<td>remove(索引\值)</td>
<td>删除指定元素</td>
<td></td>
</tr>
<tr>
<td>contains(值)</td>
<td>查找元素是否存在</td>
<td></td>
</tr>
<tr>
<td>size()</td>
<td>获取元素个数</td>
<td></td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断是否为空</td>
<td></td>
</tr>
<tr>
<td>clear()</td>
<td>清空</td>
<td></td>
</tr>
<tr>
<td>addAll(集合)</td>
<td>添加多个元素</td>
<td>可以添加实现了Collection接口的集合</td>
</tr>
<tr>
<td>containsAll(集合)</td>
<td>查找多个元素是否都存在</td>
<td>可以添加实现了Collection接口的集合</td>
</tr>
<tr>
<td>removeAll(集合)</td>
<td>删除多个元素</td>
<td>可以添加实现了Collection接口的集合</td>
</tr>
</tbody></table>
<p>Collection遍历元素方式</p>
<blockquote>
<p>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。</p>
<p>&#x3D;&#x3D;所有实现了Collection接口的集合都有一个iterator()方法，&#x3D;&#x3D;可以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</p>
<p>Iterator仅仅用于遍历集合，&#x3D;&#x3D;Iterator本身并不存放对象&#x3D;&#x3D;。</p>
<p>Iterator细节：</p>
<ul>
<li>使用迭代器得到下一个元素之前必须使用迭代器的hasNext方法判断是否有下一个元素。</li>
<li>如果没有使用hasNext方法判断，调用Next方法且已经没有下一个元素会抛出异常：NoSuchElementException。</li>
<li>可以使用iterator.Next()将指向下移并且得到当前指向的元素。</li>
<li>当退出while循环后，这是iterator迭代器还是指向最后的元素，不能再次调用Next，否则会指向超出集合长度，抛出异常：NoSuchElementException。</li>
<li>&#x3D;&#x3D;如果希望再次遍历，可以重新得到迭代器&#x3D;&#x3D;，不能使用原有迭代器：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//第一次构造迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="comment">//重新构造迭代器</span></span><br><span class="line">iterator = arrayList.iterator();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>); <span class="comment">//其中有自动装箱</span></span><br><span class="line"><span class="comment">//得到迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line"><span class="comment">//使用迭代器得到下一个元素之前必须使用迭代器的hasNext方法判断是否有下一个元素</span></span><br><span class="line"><span class="comment">//如果没有使用hasNext方法判断，调用Next方法且已经没有下一个元素会抛出异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  		<span class="comment">//</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>增强for</p>
<blockquote>
<p>增强for循环，可以替代iterator迭代器，增强for就是简化版的iterator，本质一样们&#x3D;&#x3D;只能用于遍历集合或者数组。&#x3D;&#x3D;</p>
<p>增强for的底层也是使用了迭代器。</p>
<p>语法：for(元素类型 元素名 : 集合名或数组 ){ 访问元素 }</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>); <span class="comment">//其中有自动装箱</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(Object ob : arrayList)&#123;</span><br><span class="line">         System.out.println(ob);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>普通for</p>
<blockquote>
<p>也可以使用普通for循环进行遍历集合</p>
<p>普通for循环只能用作有顺序集合的遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>); <span class="comment">//其中有自动装箱</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arrayList.size();i++)&#123;</span><br><span class="line">         System.out.println(arrayList.get(i));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="41-3-List-接口"><a href="#41-3-List-接口" class="headerlink" title="41.3 List 接口"></a>41.3 List 接口</h4><blockquote>
<p>List接口是Collection接口的子接口。</p>
<ul>
<li>List集合中的元素有序(即添加顺序和取出顺序一致)，且可重复。</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，&#x3D;&#x3D;可以根据序号存取容器中的元素&#x3D;&#x3D;。</li>
</ul>
</blockquote>
<p>List常用方法:</p>
<p>add() 添加</p>
<blockquote>
<p>add(索引,元素);</p>
<p>向指定索引处添加指定元素，如果不指定索引默认添加到最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">0</span>,<span class="string">&quot;索引0元素&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>addAll() 添加</p>
<blockquote>
<p>addAll(集合);</p>
<p>向指定索引处添加指定所有元素(集合)，如果不指定索引默认添加到最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">List</span> <span class="variable">arrayList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.addAll(arrayList1);</span><br><span class="line">arrayList.addAll(<span class="number">0</span>,arrayList1);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>get() 获得</p>
<blockquote>
<p>get(索引);</p>
<p>返回指定索引位置的元素。</p>
<p>如果超出索引长度会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">arrayList.get(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>indexOf() 查找</p>
<blockquote>
<p>indexOf(元素);</p>
<p>返回指定元素在当前集合中首次出现的位置索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>);</span><br><span class="line">arrayList.indexOf(<span class="string">&quot;元素&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>laseindexOf() 添加</p>
<blockquote>
<p>laseindexOf()(元素);</p>
<p>返回指定元素在当前集合中最后出现的位置索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>);</span><br><span class="line">arrayList.laseindexOf(<span class="string">&quot;元素&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>remove() 删除</p>
<blockquote>
<p> remove(索引)；</p>
<p> 移除指定index位置的元素，并且返回此元素。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>  arrayList.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>set() 设置(替换)</p>
<blockquote>
<p>set(索引,元素)；</p>
<p>设置指定索引位置为指定元素，相当与替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">arrayList.add(<span class="string">&quot;元素&quot;</span>);</span><br><span class="line">arrayList.set(<span class="number">0</span>,<span class="string">&quot;元素&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>subList()</p>
<blockquote>
<p>subList(开始索引，结束索引)；</p>
<p>截取指定范围的集合元素返回一个新的集合，包含开始索引，不包含结束索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">arrayList.add(<span class="string">&quot;元素0&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;元素1&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;元素2&quot;</span>);</span><br><span class="line"><span class="comment">//获取第零个元素和第一个元素</span></span><br><span class="line"><span class="type">List</span> <span class="variable">arrayList2</span> <span class="operator">=</span> arrayList.subList(<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="41-4-ArrayList"><a href="#41-4-ArrayList" class="headerlink" title="41.4 ArrayList"></a>41.4 ArrayList</h4><blockquote>
<p>ArrayList可以加入Null，并且多个。</p>
<p>ArrayList由数组实现数据的存储。</p>
<p>ArrayList基本等同于Vector，除了ArrayList是线程不安全的(执行效率高)在多线程情况下，不建议使用ArrayList。多线程推荐使用Vector。(ArrayList没有使用synchronized修饰)</p>
<p>分析：</p>
<ul>
<li>ArrayList中&#x3D;&#x3D;维护了一个Object类型的数组elementData。&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;  <span class="comment">//transient表示短暂的，瞬间，保证该属性不会被序列化。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当创建对象时，如果使用的是无参构造器，则初始elementData的容量为0.(jdk 8为10)</li>
<li>当添加元素时，先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适的位置。</li>
<li>如果使用的是无参构造器，如果是第一次添加，需要扩容的话，扩容后的elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍。(第一次为10，第二次为15)</li>
<li>如果使用的是指定容量capacity的构造器，则初始elementData容量为caoacity。</li>
<li>如果使用的是只当容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍。</li>
</ul>
</blockquote>
<h4 id="41-5-Vector"><a href="#41-5-Vector" class="headerlink" title="41.5 Vector"></a>41.5 Vector</h4><blockquote>
<p>Vector底层也是一个对象数组，Protected Object[] elementData；</p>
<p>Vector的对象是有固定顺序且可以重复的。</p>
<p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> elementData(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在开发中，需要线程同步安全时，考虑使用Vector。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>同步，效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>jdk1.2</td>
<td>不安全，效率高</td>
<td>如果有参数构造为传入参数大小，扩容1.5倍；无参数默认是0，第一次10，第二次1.5倍</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>jdk1.0</td>
<td>安全，效率低</td>
<td>如果是无参，默认10，满后按照2倍扩容，如果指定大小，则每次直接按照2倍扩容</td>
</tr>
</tbody></table>
<h4 id="41-6-LinkedList"><a href="#41-6-LinkedList" class="headerlink" title="41.6 LinkedList"></a>41.6 LinkedList</h4><blockquote>
<p>LinkedList实现了双向链表和双端队列特点。</p>
<p>可以添加任意元素(元素可以重复),包括null。</p>
<p>线程不安全，没有实现同步。</p>
<ul>
<li>LinkedList底层维护了一个双向链表。</li>
<li>LinkedList中维护了两个属性first和last分别指向首节点和尾节点。</li>
<li>每个节点(Node对象)，里面又维护了prev，next，item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表。</li>
<li>所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。</li>
</ul>
</blockquote>
<h5 id="LinkedListCRUD"><a href="#LinkedListCRUD" class="headerlink" title="LinkedListCRUD"></a>LinkedListCRUD</h5><p>add()</p>
<blockquote>
<p>add(元素)；</p>
<p>向指定LinkedList对象中添加元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">lkl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        lkl.add(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>remove()删除</p>
<blockquote>
<p>remove();   remove(节点位置);</p>
<p>remove默认删除的是第一个节点，可以指定删除哪一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">lkl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         lkl.add(i);</span><br><span class="line">     &#125;</span><br><span class="line">     lkl.remove();</span><br><span class="line">	    lkl.remove(<span class="number">1</span>);</span><br><span class="line">     System.out.println(lkl);</span><br></pre></td></tr></table></figure>


</blockquote>
<p>set() 设置</p>
<blockquote>
<p>set(节点位置，元素);    （节点索引也是从零开始）</p>
<p>将指定节点位置的元素更换为指定元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">lkl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         lkl.add(i);</span><br><span class="line">     &#125;</span><br><span class="line">     lkl.set(<span class="number">1</span>,<span class="number">9999</span>);</span><br><span class="line">     System.out.println(lkl);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>get() 获取</p>
<blockquote>
<p>get(节点位置)；</p>
<p>获取指定节点的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">lkl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         lkl.add(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> lkl.get(<span class="number">1</span>);</span><br><span class="line">     System.out.println(obj);</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删的效率</th>
<th>改查的效率</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低，数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高，通过链表追加</td>
<td>较低</td>
</tr>
</tbody></table>
<ul>
<li>如果改查的操作比较多，选择ArrayList。</li>
<li>如果我们该删的操作多，选择LinkedList。</li>
<li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList。<ul>
<li>允许在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另一个模块是LinkedList。</li>
</ul>
</li>
</ul>
<h4 id="41-7-Set接口"><a href="#41-7-Set接口" class="headerlink" title="41.7 Set接口"></a>41.7 Set接口</h4><blockquote>
<p>无序(添加和取出来的顺序不一致，但是取出来的顺序是固定的)，所以没有索引。</p>
<p>如果添加的元素有重复只会存储一个。</p>
<p>不允许重复元素，所以最多包含一个null。</p>
<p>JDK API中set的实现类为：HashSet ，TreeSet。</p>
<p>Set和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection的接口一样。</p>
</blockquote>
<h5 id="set接口的遍历方式"><a href="#set接口的遍历方式" class="headerlink" title="set接口的遍历方式"></a>set接口的遍历方式</h5><blockquote>
<p>同Collection的遍历遍历一样，因为Set接口是Collection接口的子接口：</p>
<ol>
<li>可以使用迭代器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">            hashSet.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>增强for</li>
<li>&#x3D;&#x3D;不能使用索引的方式来获取元素&#x3D;&#x3D;，因为set接口不支持索引，没有顺序。</li>
</ol>
</blockquote>
<h4 id="41-8-HashSet"><a href="#41-8-HashSet" class="headerlink" title="41.8 HashSet"></a>41.8 HashSet</h4><blockquote>
<p>HashSet实现了Set接口。</p>
<p>&#x3D;&#x3D;HashSet实际上是HashMap&#x3D;&#x3D;。(只是将HashMap的value处放固定值)</p>
<p>HashSet不允许重复元素。可以存放null值，但是只能有一个null。</p>
<p>HashSet不保证元素是有序的，取决与hash后，再确定索引的结果。</p>
<p>不能有重复元素&#x2F;对象，再前面Set接口使用已经讲过。</p>
<ul>
<li><p>不能加入相同对象的真正含义：</p>
<ul>
<li>HashSet底层是HashMap,维护了一个table和双链表。</li>
<li>添加一个元素时，先得到hash值，会转成索引值。</li>
<li>找到保存数据表table，看这个索引位置是否已经存放有元素。</li>
<li>如果没有，直接加入，如果有调用equals比较，如果相同，就放弃添加，如果不同，则添加到最后。</li>
<li>再java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)并且table的大小&gt;&#x3D;MIN_CAPACITY(默认是64)，就会进行树化(红黑树)</li>
<li>可以重写hashCode方法和equlas方法来控制不能重复的范围。</li>
</ul>
</li>
<li><p>相同元素的定义：</p>
<ul>
<li>准备加入的和已经加入的节点是同一个对象。</li>
<li>准备加入的节点和已经加入的执行equals()方法。</li>
<li>&#x3D;&#x3D;重点是指定对象equals方法被重写后的机制&#x3D;&#x3D;</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;java<br>HashSet hashSet &#x3D; new HashSet();<br>hashSet.add(“字符串”);<br>hashSet.add(“字符串”); &#x2F;&#x2F;同一个对象添加失败<br>hashSet.add(new Dog(“doubao”));<br>hashSet.add(new Dog(“doubao”));  &#x2F;&#x2F;非同一个对象添加成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>hashSet.add(new String(“字符串”));<br>hashSet.add(new String(“字符串”));&#x2F;&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HashSet的底层机制：</span><br><span class="line"></span><br><span class="line">* HashSet底层是HashMap，==第一次添加时，table数组扩容到16==，临界值(threshold)是0.75 = 12.（并不是到达极限再扩容）</span><br><span class="line">  * 只要数组和链表中加入一个元素就算做加一，加到临界值会触发扩容。</span><br><span class="line">* 如果table数组使用到了临界值12，就会扩容到16*2 = 32 ，新的临界值就是32 * 0.75 = 24，以此类推。</span><br><span class="line">* 再java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)并且table的大小&gt;=MIN_CAPACITY(默认是64)，就会进行树化(红黑树)，否则仍然采用数组的扩容机制。</span><br><span class="line">* 如果单条链的长度到达8且数组长度未到达64，则会将数组按照规则扩容，每次这条链多追加元素一便扩容一次。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line"></span><br><span class="line">添加指定对象，返回一个boolean的值。</span><br><span class="line"></span><br><span class="line">如果添加成功返回true，如果添加失败返回false。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">remove()</span><br><span class="line"></span><br><span class="line">remove(对象)；</span><br><span class="line"></span><br><span class="line">删除指定对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 41.9  LinkedHashSet</span><br><span class="line"></span><br><span class="line">LinkedHashSet 时HashSet的子类。实现了有顺序的存储。</span><br><span class="line"></span><br><span class="line">==LinkedHashSet底层是一个LinkedHashMap==，是HashMap的子类，底层维护了一个数组+双向链表。</span><br><span class="line"></span><br><span class="line">LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时用链表维护元素的次序，这使得元素看起来是以处插入顺序保存的。</span><br><span class="line"></span><br><span class="line">LinkedHashSet不允许出现重复元素。</span><br><span class="line"></span><br><span class="line">* 在LinkedHashSet中维护了一个hash表和双向链表(LinkedHashSet有head和tail)</span><br><span class="line"></span><br><span class="line">* 每一个节点有before和after属性，这样可以形成双向链表。</span><br><span class="line"></span><br><span class="line">* 在添加一个元素时。先求hash值，再求索引，确定该元素再hashtable的位置，然后将添加的元素加入到双向链表(如果已经存在，不添加)</span><br><span class="line"></span><br><span class="line">* 这样的话，遍历时可以确保插入顺序和遍历顺序一致。</span><br><span class="line"></span><br><span class="line">* 添加第一次时，直接将数组table扩容到16，存放的节点类型是LinkedHashMap$Entry。</span><br><span class="line"></span><br><span class="line">* 底层维护着一个HashMap\$Node[]，存放的元素是LinkedHashMap$Entry类型。(多态数组)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 41.10 TreeSet</span><br><span class="line"></span><br><span class="line">可以使用TreeSet集合将添加元素==按照指定顺序排列==；</span><br><span class="line"></span><br><span class="line">1. 如果使用无参构造器创建TreeSet时，仍然时无顺序的。但是也会去除重复，使用添加元素实现的Compareable接口的compareTo去重。</span><br><span class="line">   1. 如果使用无参构造器且传入的实现类并没有实现对应compareTo方法，则会在底层报错：ClassCastExcepotion。</span><br><span class="line">2. 使用提供的传入一个比较器(匿名内部类)时可以按照指定顺序排序。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">TreeSet set = new TreeSet(new Comparator() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Object o1, Object o2) &#123;</span><br><span class="line"></span><br><span class="line">          //根据字符串大小排序</span><br><span class="line">            return ((String)o1).compareTo(((String)o2));</span><br><span class="line">          //根据字符串长度排序</span><br><span class="line">          //return ((String)o1).length - ((String)o2).length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>TreeSet的底层就是TreeMap。</p>
<p>构造器会将出传入的比较器传入到TreeMap对象。当调用add()方法时，会执行传入的比较器，然后根据返回值存放元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parent = t;</span><br><span class="line">       cmp = cpr.compare(key, t.key);</span><br><span class="line">       <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">           t = t.left;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">           t = t.right;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> t.setValue(value);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="41-11-Map接口"><a href="#41-11-Map接口" class="headerlink" title="41.11 Map接口"></a>41.11 Map接口</h4><blockquote>
<p>Map与Collection并列存在(其中并没有关系)，用于保存具有映射关系的数据:Key-Value。</p>
<p>&#x3D;&#x3D;Map对象底层也维护着table和一个双链表Node。&#x3D;&#x3D;</p>
<p>Map中的key和value可以时任何引用类型的数据，会封装到HashMap$Node对象中。</p>
<p>Map中的key不允许重复。(原因和HashSet一样，HashSet也是key-value结构但是value是固定值)</p>
<p>Map中的value可以重复，可以为空和重复。</p>
<p>Map中的Key可以为null，value也可以为null，注意key为null，只能有一个。value为null，可以多个。如果有多个相同的key会采取替换机制。</p>
<p>常用String类作为Map的key,可以使用object类型作为Key。</p>
<p>key和value之间存在单项一对一关系，通过指定的key总能找到对应的value。但是value无法找到key。</p>
<p>Map存放数据的key-value，一对key-value是放在一个HashMap$Node中的，是因为Node实现了Entry接口。 </p>
<ul>
<li><p>key-value最后是HashMap$Node node &#x3D; newNode(hash,key,value,null);</p>
</li>
<li><p>key-value为了方便遍历，还会创建EntrySet集合，该集合存放的元素的类型Entry，而一个Entry对象就有key,value,EntrySet&lt;Entry&lt;K,V&gt;&gt; entrySet;</p>
</li>
<li><p>EntrySet 中，定义的类型是Map.Entry,但是实际上存放的还是HashMap$Node,这是因为<code>static class Node&lt;K,Y&gt; implements Map.Entry&lt;K,V&gt;</code>利用接口的多态。</p>
</li>
<li><p>当把HashMap$Node对象存放到EntrySet就方便遍历，因为Entry接口提供了重要方法：<code>getKey</code>和 <code>getValue</code></p>
</li>
<li><p>Entry中存储着指定数据在HashMap$Node中的地址，实际上数据还是在HashMap$Node中存储。</p>
</li>
<li><p>使用EntrySet结构为了访问方便。</p>
</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bDOTnf"><img src="https://s1.ax1x.com/2022/03/06/bDOTnf.md.png" alt="bDOTnf.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b6ZYG9"><img src="https://s1.ax1x.com/2022/03/07/b6ZYG9.png" alt="b6ZYG9.png"></a></p>
<h5 id="put-添加"><a href="#put-添加" class="headerlink" title="put() 添加"></a>put() 添加</h5><blockquote>
<p>put(“键”，“值”);</p>
<p>使用put()方法可以添加键值对到指定的Map对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>get() 获得</p>
<blockquote>
<p>get(“key”)；</p>
<p>通过get()方法可以返回指定key的value值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.get(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>remove()</p>
<blockquote>
<p>remove(“key”);</p>
<p>根据键值对删除映射关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.remove(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>size()</p>
<blockquote>
<p>size()</p>
<p>获取元素个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> map.size();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>isEmpty()</p>
<blockquote>
<p>isEmpty();</p>
<p>判断个数是否为0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">i</span> <span class="operator">=</span> map.isEmpty();</span><br></pre></td></tr></table></figure>





<p>clear()</p>
<blockquote>
<p>clear();</p>
<p>清除所有元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.clear();</span><br></pre></td></tr></table></figure>





<p>containsKey()</p>
<blockquote>
<p>containsKey(“key”);</p>
<p>查找键是否存在。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">i</span> <span class="operator">=</span> map.containsKey(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="map遍历方式"><a href="#map遍历方式" class="headerlink" title="map遍历方式"></a>map遍历方式</h5><blockquote>
<p>Map接口存放着key和value，分别放在keySet和values中。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/brCB3F"><img src="https://s1.ax1x.com/2022/03/06/brCB3F.png" alt="brCB3F.png"></a></p>
<p>一.增强for循环</p>
<blockquote>
<p>通过增强for获得keySet中的key，可以调用get方法得到对应的值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="comment">//取出所有key再通过Key去除对应的Value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Object key : keyset)&#123;</span><br><span class="line">     System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二.迭代器</p>
<blockquote>
<p>存放key的是set类型的keySet集合，可以使用迭代器得到key再调用get方法获得对应key的value。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line">      <span class="comment">//取出所有key再通过Key去除对应的Value</span></span><br><span class="line">      <span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//获得set集合的迭代器</span></span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//获得keySet的key，调用Map的get方法获得值</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">          System.out.println(map.get(next));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<p>三. 获得Values</p>
<blockquote>
<p>存储value的是collection类型的values集合。可以直接使用values方法获得value的集合。</p>
<p>获得collection类型的values集合后可以使用迭代器，增强for循环。</p>
<p>不能使用普通for循环，不提供get方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="comment">//调用values方法获得value的集合</span></span><br><span class="line">      <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">      <span class="comment">//获取其中元素可以使用迭代器，增强for循环</span></span><br></pre></td></tr></table></figure>



<p>四. EntrySet</p>
<blockquote>
<p>可以使用map中维护的Entry集合的方法获取。</p>
<ol>
<li>调用entrySet获得EntrySet对象，增强for后得到的是HashMap$Node类型的对象，但是实现了Map.Entry接口，也可以向上转型后使用getKey和getValue方法。</li>
<li>获得Entry集合后，因为Entry也是Set类型的也可以使用迭代器。使用迭代器返回的是HashMap$Node类型但是实现了Map.Entry接口，也可以向上转型后使用getKey和getValue方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获得entryset</span></span><br><span class="line">      <span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">      <span class="keyword">for</span>(Object entry : entryset)&#123;</span><br><span class="line">          <span class="comment">//entry实现了Map.Entry接口</span></span><br><span class="line">          Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">          System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获得entryset</span></span><br><span class="line">      <span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entryset.iterator();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) iterator.next();</span><br><span class="line">          System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="41-12-HashMap"><a href="#41-12-HashMap" class="headerlink" title="41.12 HashMap"></a>41.12 HashMap</h4><blockquote>
<p>Map接口的常用实现类：HashMap ,Hashtable和Properties。</p>
<p>HashMap是Map接口使用频率最高的实现类。</p>
<p>HashMap是以key-val对的方式存储的。</p>
<p>key不能重复，但是值可以重复，允许使用null键和null值。</p>
<p>如果添加相同的key，则会覆盖原来的key-val，等同于修改(key不会替换，val会替换)</p>
<p>与HashSet一样，不保证映射顺序，因为底层是以hash表的方式来存储的。</p>
<p>HashMap没有实现同步，因此是线程不安全的。方法上没有做同步互斥。(synchronized)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b6pZOH"><img src="https://s1.ax1x.com/2022/03/07/b6pZOH.png" alt="b6pZOH.png"></a></p>
<ol>
<li>(k,v)是一个Node实现了Map.Entry&lt;K,V&gt;。</li>
<li>jdk7.0的hashmap底层实现[数组+链表]，jdk8.0底层[数组+链表+红黑树]</li>
</ol>
<p>扩容机制：</p>
<ul>
<li>HashMap底层维护了Node类型的数组table，默认为null。</li>
<li>当创建对象时，将加载因子(loadfactor)初始化为0.75。</li>
<li>当添加key-val时，通过key的哈希值得到在table上的索引，然后判断索引处是否有元素，如果没有元素直接添加，如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等直接替换val；如果不相等需要判断树结构还是链表结构，做出相应的处理，如果添加时发现容量不够用，则需要扩容。</li>
<li>第一次添加，则需要扩容table容量为16，临界值为(threshold)为12.</li>
<li>以后再次扩容，则需要扩容的容量为原来的2倍。临界值为原来的两倍，即24，以此类推。</li>
<li>在java8中如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY(默认64)，就会进项树化(红黑树)。&#x3D;&#x3D;如果小于会先扩容再树化。&#x3D;&#x3D;</li>
</ul>
<h4 id="41-13-Hashtable"><a href="#41-13-Hashtable" class="headerlink" title="41.13 Hashtable"></a>41.13 Hashtable</h4><blockquote>
<p>存放的元素时键值对：即k-y</p>
<p>&#x3D;&#x3D;hashtable的键和值不能为null。&#x3D;&#x3D; 否则还会抛出异常：NullPointerException</p>
<p>hashTable使用方法基本上和HashMap一样。</p>
<p>&#x3D;&#x3D;HashTable是线程安全的&#x3D;&#x3D;，hashMap是线程不安全的。<a target="_blank" rel="noopener" href="https://imgtu.com/i/b6ZYG9"><img src="https://s1.ax1x.com/2022/03/07/b6ZYG9.png" alt="b6ZYG9.png"></a></p>
</blockquote>
<p>扩容机制：</p>
<blockquote>
<p><code>(oldCaoacity &lt;&lt;1)+1</code></p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
<th>线程安全</th>
<th>效率</th>
<th>允许null</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>1.2</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>Hashtable</td>
<td>1.0</td>
<td>安全</td>
<td>较低</td>
<td>不可以</td>
</tr>
</tbody></table>
<h4 id="41-14-Properties"><a href="#41-14-Properties" class="headerlink" title="41.14 Properties"></a>41.14 Properties</h4><blockquote>
<p>Properties类继承自Hashtable类并且实现Map接口，也是使用一种键值对的形式保存数据。</p>
<p>&#x3D;&#x3D;继承Hashtable所以key和value不能为Null。&#x3D;&#x3D;</p>
<p>存放是无顺序的。</p>
<p>Properties还可以用于从xxx.Properties文件中，加载数据到Prorerties类对象。</p>
</blockquote>
<p>常用方法：</p>
<p>put() 添加修改</p>
<blockquote>
<p>put(“key”,”vale”);</p>
<p>可以通过put方法向指定Properties对象中添加键值对，如果有相同的键则会替换对应的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>remover()</p>
<blockquote>
<p>remover(“key”);</p>
<p>可以通过remover方法向指定Properties对象中删除对应键值对。如果删除成功会返回对应的值，如果没有找到会返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> properties.remove(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>get() 查</p>
<blockquote>
<p>get(“key”);</p>
<p>可以通过get方法向指定Properties对象中查找对应键值对。如果查找成功会返回对应的值，如果没有找到会返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> properties.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="41-15-TreeMap"><a href="#41-15-TreeMap" class="headerlink" title="41.15 TreeMap"></a>41.15 TreeMap</h4><blockquote>
<p> TreeMap使用默认构造器是没有排序的存储。</p>
<p> 调用TreeMap类传入比较器的构造器会按照指定比较器来对添加的元素的&#x3D;&#x3D;key进行排序&#x3D;&#x3D;。(找到适当的位置差插入)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">         <span class="comment">//根据字符串大小排序</span></span><br><span class="line">         <span class="keyword">return</span> ((String)o1).compareTo(((String)o2));</span><br><span class="line">       <span class="comment">//根据字符串长度排序</span></span><br><span class="line">       <span class="comment">//return ((String)o1).length - ((String)o2).length;</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parent = t;</span><br><span class="line">           cmp = cpr.compare(key, t.key);</span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">               t = t.left;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">               t = t.right;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> t.setValue(value);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次添加元素时，直接将k-y封装到Entry对象中，放入root；</li>
<li>第二次添加时候才使用比较器，将加入的key找到适当的位置存储。</li>
</ul>
<h4 id="41-16-集合选择"><a href="#41-16-集合选择" class="headerlink" title="41.16 集合选择"></a>41.16 集合选择</h4><blockquote>
<p>在开发中，选择集合实现类主要取决于业务操作特点，然后跟根据集合实现类特性进行选择：</p>
<p>先判断存储的类型(一组对象[单列]或一组键值对)</p>
<ul>
<li>一组对象：Collection接口：<ul>
<li>允许重复： list接口<ul>
<li>增删多：LinkedList  (底层维护了一个双向链表)</li>
<li>改查多：ArrayList   (底层维护Object类型的可变数组)</li>
<li>线程安全： Vector</li>
</ul>
</li>
<li>不允许重复：set接口：<ul>
<li>无序： HashSet (底层是HashMap，维护了一个哈希表)</li>
<li>排序： TreeSet</li>
<li>插入和取出顺序一致：LinkedHashSet (维护数组+双向链表)</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对： Map接口<ul>
<li>键无顺序：HashMap (底层是哈希表：数组 + 链表 + 红黑树)</li>
<li>键排序：TreeMap</li>
<li>键插入和键取出LinkedHashMap</li>
<li>读取文件： Properties</li>
<li>线程安全： Hashtable</li>
</ul>
</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b6GqSK"><img src="https://s1.ax1x.com/2022/03/07/b6GqSK.png" alt="b6GqSK.png"></a></p>
<h3 id="42-Collections工具类"><a href="#42-Collections工具类" class="headerlink" title="42. Collections工具类"></a>42. Collections工具类</h3><blockquote>
<p>Collections是一个操作Set,List和Map等集合的工具类</p>
<p>Collections中提供了一些列静态的和方法对集合元素进行排序，查找，修改等操作。</p>
</blockquote>
<h4 id="42-1-排序操作："><a href="#42-1-排序操作：" class="headerlink" title="42.1 排序操作："></a>42.1 排序操作：</h4><blockquote>
<p>排序操作均为static方法。</p>
<ol>
<li>reverse(List): 反转List中元素的顺序。</li>
<li>shuffle(List):对List集合元素进行随机排序。</li>
<li>sort(List):根据元素的自然顺序对只当List集合按照升序排序。</li>
<li>sort(List,Comparator);根据指定的Conmparator产生的顺序对List集合元素进行排序。</li>
<li>swap(List,int,int); 将指定List集合中的i处元素和j处元素进行交换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">li</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">li.add(<span class="number">1</span>);</span><br><span class="line">li.add(<span class="number">3</span>);</span><br><span class="line">li.add(<span class="number">2</span>);</span><br><span class="line">System.out.println(li);</span><br><span class="line">Collections.reverse(li);</span><br><span class="line">System.out.println(li);</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="42-2-查找，替换"><a href="#42-2-查找，替换" class="headerlink" title="42.2 查找，替换"></a>42.2 查找，替换</h4><blockquote>
<ol>
<li>Object max(Collection); 根据元素的自然顺序，返回给定结合中最大的元素。</li>
<li>Object max(Collection,Comparator);根据Comparator指定的顺序，返回给定集合中的最大元素。</li>
<li>Object min(Collection); 根据元素的自然顺序，返回给定结合中最小的元素。</li>
<li>Object min(Collection,Comparator);根据Comparator指定的顺序，返回给定集合中的最小元素。</li>
<li>int frequency(Collection,Object); 返回指定集合中指定元素的出现次数。</li>
<li>void copy(List dest,List src):将src中的内容赋值到dest中。</li>
<li>boolean replaceAll(List list,Object oldVal,Object newVal);使用新值替换List对象的所有旧值。</li>
</ol>
</blockquote>
<h3 id="43-泛型"><a href="#43-泛型" class="headerlink" title="43. 泛型"></a>43. 泛型</h3><blockquote>
<p>泛型又称参数化类型，是jdk5.0中出现的新特性，解决数据类型的安全性问题。</p>
<p>在类声明或者实例化是只要指定需要的具体的类型即可。该类型会在定义对象时指定，在编译期间确定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>java泛型可以保证程序在编译时没有发生警告，运行时就不会产ClassCastException异常，同时代码更加简洁，健壮。</p>
<p>泛型的作用：可以在类声明时通过一个&lt;&gt;表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">doubao</span>&lt;E&gt;&#123;</span><br><span class="line"> E id; <span class="comment">//E 表示数据类型，该数据类型时在定义对象时指定，在编译期间会确定E的类型。</span></span><br><span class="line"> String name;</span><br><span class="line"> <span class="keyword">public</span> E <span class="title function_">getId</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> id;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型 在编译时，检查添加元素的类型，提高了安全性。减少了类型转换的次数，提高了效率。不再提示编译警告。</p>
</blockquote>
<h4 id="43-1-泛型使用"><a href="#43-1-泛型使用" class="headerlink" title="43.1 泛型使用:"></a>43.1 泛型使用:</h4><blockquote>
<p>泛型语法:</p>
<p>interface 接口<T>{} 和class 类 &lt;K,V&gt;{}</T></p>
<ul>
<li>其中T,K,V不代表值,而是表示类型.</li>
<li>任意字母都可以,常用T表示,是Type的缩写.</li>
</ul>
<p>泛型实例化:</p>
<p>在类名后指定参数类型的值(类型):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Iterator&lt;Customer&gt; iterator = customers.iterator();</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>细节:</p>
<ol>
<li>interface List<T>{}, public class HashSet<E>{}等<ul>
<li>&#x3D;&#x3D;T,E只能是引用类型.&#x3D;&#x3D;</li>
</ul>
</E></T></li>
<li>&#x3D;&#x3D;在泛型指定具体类型后,可以传入该类型或者其子类类型.&#x3D;&#x3D;</li>
<li>泛型的使用形式和简写形式:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = <span class="keyword">new</span> <span class="title class_">List</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//简写形式 编译器会进行类型推断</span></span><br><span class="line">List&lt;Integer&gt; strings = <span class="keyword">new</span> <span class="title class_">List</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果不指定具体的泛型类型时,默认是object类型.</p>
</li>
<li><p>&#96;&#96;&#96;java<br>List strings &#x3D; new List();<br>&#x2F;&#x2F;不指定具体的泛型类型时,默认是object类型.<br>List<Object> strings &#x3D; new List&lt;&gt;();</Object></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 43.2 自定义泛型类</span><br><span class="line"></span><br><span class="line">基础语法；</span><br><span class="line"></span><br><span class="line">class 类名&lt;T,R…&gt;&#123; 成员 &#125; </span><br><span class="line"></span><br><span class="line">细节：</span><br><span class="line"></span><br><span class="line">1. 普通成员可以使用泛型(属性，方法).</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   class Genericclass&lt;T,R,M&gt;&#123;</span><br><span class="line">       String name;</span><br><span class="line">       R r;                    //属性使用泛型</span><br><span class="line">       M m;</span><br><span class="line">       T t;</span><br><span class="line">   </span><br><span class="line">   	public Genericclass(String name, R r, M m, T t) &#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">           this.r = r;</span><br><span class="line">           this.m = m;</span><br><span class="line">           this.t = t;</span><br><span class="line">       &#125;</span><br><span class="line">      public R getR() &#123;    //方法使用泛型</span><br><span class="line">           return r;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>&#x3D;&#x3D;使用泛型的数组，不能初始化。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组在创建的时候不能初始化，只能定义</span></span><br><span class="line">T[] ts;</span><br><span class="line"><span class="comment">//  T[] te = new T[3]  无法初始化数组。因为不能确定创建空间的类型以及大小。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型标识符可以有多个。</p>
</li>
<li><p>&#x3D;&#x3D;静态方法中和静态属性不能使用类的泛型&#x3D;&#x3D;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态方法不能使用类的泛型，因为静态方法可能在类实例化之前就被调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型类的类型，是在创建对象时确定的(因为创建对象时，需要指定确定类型)</p>
</li>
<li><p>如果创建对象时，没有指定类型，默认为Object类型。</p>
</li>
</ol>
</blockquote>
<h4 id="43-3-自定义泛型接口"><a href="#43-3-自定义泛型接口" class="headerlink" title="43.3 自定义泛型接口"></a>43.3 自定义泛型接口</h4><blockquote>
<p>基础语法；</p>
<p>interface 类名&lt;T,R…&gt;{ 成员 } </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>  <span class="title class_">GenericInt</span>&lt;U,R&gt;&#123;</span><br><span class="line"> R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line"> <span class="keyword">default</span>  R <span class="title function_">method</span><span class="params">(U u)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Genclass</span> <span class="keyword">implements</span> <span class="title class_">GenericInt</span>&lt;String,Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">setU</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Integer <span class="title function_">method</span><span class="params">(String s)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ol>
<li>接口中，静态成员也不能使用泛型。(接口中的属性都是静态属性)</li>
<li>泛型接口的类型，在继承接口或者实现接口时确定。</li>
<li>&#x3D;&#x3D;没有指定类型，默认为Object。&#x3D;&#x3D;</li>
</ol>
</blockquote>
<h4 id="43-4-自定义泛型方法"><a href="#43-4-自定义泛型方法" class="headerlink" title="43.4 自定义泛型方法"></a>43.4 自定义泛型方法</h4><blockquote>
<p>基本语法：</p>
<p>修饰符 &lt;T,R…&gt; 返回类型 方法名(参数列表){}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;&#125;;   <span class="comment">//使用泛型的普通方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T,R&gt; <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">(T t,R r)</span>&#123;&#125;  <span class="comment">//泛型方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法：</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">car.fly(<span class="number">100</span>,<span class="string">&quot;&quot;</span>);    <span class="comment">//当调用方法时，传入参数，编译器会确定类型</span></span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ul>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li>当泛型方法被调用时，类型会确定。</li>
<li>public void 方法名(E e){} 修饰符后没有&lt;T,R,…&gt; 该方法不是泛型方法，而是使用了泛型。</li>
<li>泛型方法可以使用类声明的泛型，也可以使用自己声明的泛型。</li>
</ul>
</blockquote>
<h4 id="43-5-泛型的继承和通配符"><a href="#43-5-泛型的继承和通配符" class="headerlink" title="43.5 泛型的继承和通配符"></a>43.5 泛型的继承和通配符</h4><blockquote>
<p>&#x3D;&#x3D;泛型不具备继承性&#x3D;&#x3D;</p>
<?> : 支持任意类型函数。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List&lt;父类&gt; strings = new List&lt;子类&gt;(); 不被允许</span></span><br></pre></td></tr></table></figure>

<? extends A> :支持A类以及A类的子类，规定泛型的上限。

<? super A>: 支持A类以及A类的父类，不限于直接父类，规定了泛型的下限。
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法允许传入一个泛型列表类，且其泛型可以是任意</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintGeneric</span><span class="params">(List&lt;?&gt; l)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//该方法允许传入一个泛型列表类，但其类型必须是A类及其子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintGeneric</span><span class="params">(List&lt;? extends A&gt; l)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//该方法允许传入一个泛型列表类，但其类型必须是A类及其父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PrintGeneric</span><span class="params">(List&lt;? <span class="built_in">super</span> A&gt; l)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>





<h3 id="44-JUnit"><a href="#44-JUnit" class="headerlink" title="44. JUnit"></a>44. JUnit</h3><blockquote>
<p>一个类有功能代码需要测试，就需要写入到一个main方法中。</p>
<p>如果有多个功能代码需要测试就需要来回注释，解开注释，切换很麻烦。</p>
<p>如果可以直接运行一个方法们就会方便很多，并且可以给出相关信息。</p>
</blockquote>
<h3 id="45-java绘图"><a href="#45-java绘图" class="headerlink" title="45. java绘图"></a>45. java绘图</h3><h4 id="java绘图体系"><a href="#java绘图体系" class="headerlink" title="java绘图体系"></a>java绘图体系</h4><blockquote>
<p>java中坐标系，坐标远点位于左上角，以像素为单位。在java坐标系中，第一个是x坐标，表示当前位置为水平方向。距离坐标原点x个像素，第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素。</p>
<p>符合计算机图形学知识体系。</p>
<p>像素是一个密度单位，并不是长度单位。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/b4G1SJ"><img src="https://s1.ax1x.com/2022/03/10/b4G1SJ.png" alt="b4G1SJ.png"></a></p>
<blockquote>
<p>java中画图过程：</p>
<ol>
<li>定义一个画板类，继承Jpanel类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mypanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.paint(g);  <span class="comment">//调用父类方法完成初始化。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>重写父类的paint方法。在paint方法中调用绘制图像的方法。</li>
<li>将主方法所在类继承窗口框架类 JFram。</li>
<li>在主方法创建画板对象。</li>
<li>实例化继承窗口框架类对象，将画板添加至窗口框架类对象。</li>
<li>设置窗口参数。</li>
</ol>
</blockquote>
<h4 id="Component类"><a href="#Component类" class="headerlink" title="Component类"></a>Component类</h4><blockquote>
<p>Component类提供了两个和绘图相关的最重要的方法；</p>
<ol>
<li>paint(Graphics g)绘制组件的外观</li>
<li>repaint()刷新组件的外观。</li>
</ol>
</blockquote>
<h4 id="paint方法"><a href="#paint方法" class="headerlink" title="paint方法"></a>paint方法</h4><blockquote>
<p>paint(Graphics g)绘制组件的外观。</p>
<p>以下情况paint()方法会再次被调用。</p>
<ol>
<li>当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。</li>
<li>窗口最小化，再最大化。</li>
<li>窗口的大小发生变化。</li>
<li>repaint方法被调用。</li>
</ol>
</blockquote>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">draw</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">Mypanel</span> <span class="variable">mp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">draw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//初始化面板</span></span><br><span class="line">        mp = <span class="keyword">new</span> <span class="title class_">Mypanel</span>();</span><br><span class="line">        <span class="comment">//将面板放入窗口框架中</span></span><br><span class="line">        <span class="built_in">this</span>.add(mp);</span><br><span class="line">        <span class="comment">//设置窗口大小</span></span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">       <span class="comment">//当点击关闭窗口时退出程序</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);  <span class="comment">//可以显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mypanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.paint(g);  <span class="comment">//调用父类方法完成初始化。</span></span><br><span class="line">        <span class="comment">//调用方法绘制图像</span></span><br><span class="line">        g.drawOval(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Graphics类"><a href="#Graphics类" class="headerlink" title="Graphics类"></a>Graphics类</h4><blockquote>
<p>Graphics类中提供了各种各样绘制图形的方法。</p>
<ol>
<li><p>画直线：drawLine(int x1,int y1,int x2,int y2);</p>
</li>
<li><p>画矩形边框: drawRect(int x1,int y1,int width,int height);</p>
</li>
<li><p>画椭圆边框: drawOval(int x1,int y1,int width,int height);</p>
</li>
<li><p>填充矩形: fillRect(int x,int y,int width,int height); </p>
</li>
<li><p>填充矩椭圆: fillOval(int x,int y,int width,int height); </p>
</li>
<li><p>画图片：drawimage(imge img,int x,int y,…)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Image</span> <span class="variable">img</span> <span class="operator">=</span> Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(<span class="string">&quot;/doubao.jpg&quot;</span>));</span><br><span class="line">g.drawImage(img,<span class="number">10</span>,<span class="number">10</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>


</li>
<li><p>画字符串: drawString(String str,int x,int y); &#x2F;&#x2F;这里设置的位置是字符串的左下角。</p>
</li>
<li><p>设置画笔的字体 setFont(Font font);</p>
<p><code>g.setFont(new Font(&quot;字体&quot;,颜色,大小));</code></p>
</li>
<li><p>设置画笔的颜色: setColor(Color c);</p>
</li>
</ol>
</blockquote>
<h3 id="46-java事件处理机制"><a href="#46-java事件处理机制" class="headerlink" title="46. java事件处理机制"></a>46. java事件处理机制</h3><blockquote>
<p>java种事件处理采取的是”委派事件模型”。当事件发生时，产生事件的对象，会把此类 “信息” 传递给 “事件的监听者处理” ，这里的 “信息” 实际上就是java.aet.event 事件类库里某个类所创建的对象，把它称为事件的对象。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bIOnED"><img src="https://s1.ax1x.com/2022/03/11/bIOnED.md.png" alt="bIOnED.md.png"></a></p>
<blockquote>
<p>事件处理机制分为：事件源，事件，事件监听器。</p>
<ul>
<li>事件源：事件源是一个产生事件的对象，比如按钮，窗口。</li>
<li>事件：事件就是承载事件源状态改变的对象，比如当键盘事件，鼠标事件，窗口事件等等。会生成一个事件对象，该对象保存这当前事件很多信息，比如KeyEvent对象有被按下键的Code值。java.awt.event包和javax.swing.event包种定义了各种事件类型。</li>
<li>事件监听器接口：<ol>
<li>当事件源产生一个事件，可以传送给事件监听者处理。</li>
<li>事件监听者实际上就是一个类，给类实现了某个事件监听器接口。</li>
<li>事件监听器接口有多种，不同的事件监听器接口可以监听不同的事件，一个类可以实现多个接口。</li>
<li>这些接口在java.awt.event包和javax.swing.event包中定义。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="47-多线程基础"><a href="#47-多线程基础" class="headerlink" title="47.  多线程基础"></a>47.  多线程基础</h3><blockquote>
<p>线程相关概念：</p>
<ol>
<li>程序(program)：是为了完成特定的任务，用某种语言编写的一组指令的集合。</li>
<li>进程：进程就是运行中的程序，启动一个进程，操作系统就会为该进程分配内存空间。进程是程序的一次执行过程，或者是正在运行的一个程序，是动态的过程：它有自身的产生，存在和消亡。</li>
<li>线程：线程是由进程创建的，是进程的一个实体。一个进程可以拥有多个线程。<ol>
<li>单线程：同一时刻，只允许执行一个线程。</li>
<li>多线程：同一时刻是可执行多个线程。</li>
<li>并发：同一时刻，多个任务交替执行，造成一种”貌似同时“的错觉，单核cpu实现的多任务就是并发。</li>
<li>并行：同一时刻，多个任务同时执行，多核cpu可以实现并行。并发和并行可以同时存在。</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="47-1-创建线程"><a href="#47-1-创建线程" class="headerlink" title="47.1 创建线程"></a>47.1 创建线程</h4><blockquote>
<ol>
<li>继承Thread类，重写run方法。</li>
<li>实现Runnable接口，重写run方法。</li>
</ol>
<p>run方法是实现了Runnable接口的run方法。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bosvh4"><img src="https://s1.ax1x.com/2022/03/11/bosvh4.png" alt="bosvh4.png"></a></p>
<h5 id="继承thread类"><a href="#继承thread类" class="headerlink" title="继承thread类"></a>继承thread类</h5><blockquote>
<p>当主线程执行子线程时主线程不会阻塞</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">     cat.start();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.当一个类继承了Thread类，该类就可以当作线程使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;线程正在执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//线程休眠</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><blockquote>
<ol>
<li>创建类实现Runnable接口,实现run方法.</li>
<li>创建对应类的对象.</li>
<li>创建Thread类的对象,将实现Runnable接口类的对象传入Thread的构造方法.</li>
<li>使用Thread类对象调用start()方法创建新的线程.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Cat2</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ca);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;次要线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将实现Runnable的类的对象传入Thread类的构造方法,是使用了静态代理模式.</p>
</blockquote>
<h4 id="47-2-调用线程"><a href="#47-2-调用线程" class="headerlink" title="47.2 调用线程"></a>47.2 调用线程</h4><blockquote>
<ul>
<li>创建线程后实例化对象,再调用对应对象的start方法进行使用线程.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadClass</span> <span class="variable">tc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadClass</span>();</span><br><span class="line">        tc.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>将实例化的对象传入Thread构造方法中,调用Tread类对象的start方法进行使用进程.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat2</span> <span class="variable">ca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat2</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ca);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>start()方法调用开启一个新的线程,和主线程轮转运行.</p>
<p>run()方法调用,run()方法只是一个普通的方法,不开启新的线程,还是主线程调用run()中的代码.</p>
</blockquote>
<blockquote>
<p>start()方法调用底层start0()方法后.&#x3D;&#x3D;该线程并不会立即执行,只是将该线程变成可运行状态,具体什么事件执行,取决于cpu由cpu统一调度.&#x3D;&#x3D;</p>
<ul>
<li>start0()是本地方法,是JVM调用,底层是C&#x2F;C++实现,真正实现多线程的效果是start0(),而不是run();</li>
</ul>
</blockquote>
<h4 id="47-3-线程终止"><a href="#47-3-线程终止" class="headerlink" title="47.3 线程终止"></a>47.3 线程终止</h4><blockquote>
<p>当线程完成任务时自动退出.</p>
<p>可以通过使用变量来控制run方法退出的方式停止线程,即通知方式.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Threade</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Threade</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.setLoop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thsda</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//定义私有变量控制线程的for循环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//私有属性的set方法,可以控制通知变量.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="47-4-线程常用方法"><a href="#47-4-线程常用方法" class="headerlink" title="47.4 线程常用方法"></a>47.4 线程常用方法</h4><blockquote>
<p>SetName()  &#x2F;&#x2F;设置线程名称</p>
<p>getName() &#x2F;&#x2F;获得该线程的名称</p>
<p>start()   &#x2F;&#x2F;使该线程开始执行</p>
<p>run()  &#x2F;&#x2F;调用线程对象run方法</p>
<p>setPriority()  &#x2F;&#x2F;更改线程的优先级</p>
<p>getPriority()   &#x2F;&#x2F;获取线程的优先级</p>
<p>sleep() &#x2F;&#x2F;在指定的毫秒数内让正在执行的线程休眠.&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p>
<p>interrupt()  &#x2F;&#x2F;中断线程,并不是结束线程,抛出InterruptedExcepotion异常.</p>
<p>yield:线程的礼让.让出cpu,让其他线程执行,但礼让的事件不确定,所以也不一定礼让的事件不确定,所以也不一定礼让成功.</p>
<p>join: 线程的插队,插队的线程一旦插队成功,则肯定限制运行插入线程的所有的任务.(再被插队的线程中调用插队线程的join方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程中</span></span><br><span class="line"><span class="type">Thead1</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thead1</span>();</span><br><span class="line">th.start();		<span class="comment">//主线程和th分线程交替执行</span></span><br><span class="line">th.join()  <span class="comment">//将th分线程插入到主线程前，先执行完分线程再执行主线程。</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p> 用户线程和守护线程</p>
<ol>
<li>用户线程：也叫工作线程，当线程的任务执行完成，或者通知方式结束</li>
<li>守护线程：一般是为工作线程服务的，&#x3D;&#x3D;当所有的用户线程结束，守护线程自动结束&#x3D;&#x3D;。  (垃圾回收机制)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程中</span></span><br><span class="line"><span class="type">Thead1</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thead1</span>();</span><br><span class="line"><span class="comment">//设置指定线程为守护线程，在启动相应的线程</span></span><br><span class="line">th.setDeamon(<span class="literal">true</span>);</span><br><span class="line">th.start();	</span><br></pre></td></tr></table></figure>



<h4 id="47-5-线程的生命周期"><a href="#47-5-线程的生命周期" class="headerlink" title="47.5. 线程的生命周期"></a>47.5. 线程的生命周期</h4><blockquote>
<p>JDK中使用Thread.State枚举表示了线程的几种状态。</p>
<ul>
<li>New: 尚未启动的线程处于此状态。</li>
<li>Runnable: 启动或者正在Java虚拟机中执行的线程处于此状态</li>
<li>Teminated:  线程终止。</li>
<li>Time_Waiting: 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</li>
<li>Warting: 正在等待另一个线程执行特定动作的线程处于此状态。</li>
<li>Blocked: 被阻塞等待监视器锁定的线程处于此状态。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bqPoM6"><img src="https://s1.ax1x.com/2022/03/13/bqPoM6.png" alt="bqPoM6.png"></a></p>
<h4 id="47-6-线程同步机制"><a href="#47-6-线程同步机制" class="headerlink" title="47.6. 线程同步机制"></a>47.6. 线程同步机制</h4><blockquote>
<p>在多线程编程中，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何任何时刻，最多有一个线程访问，以保证数据的完整性。</p>
<p>线程同步：即当有一个线程对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。</p>
</blockquote>
<h5 id="同步方法：Synchronized"><a href="#同步方法：Synchronized" class="headerlink" title="同步方法：Synchronized"></a>同步方法：Synchronized</h5><ol>
<li><p>同步代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;  <span class="comment">//得到对象的锁，才能操作同步代码</span></span><br><span class="line">            <span class="comment">//需要被同步的代码</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Synchronized 还可以放到方法声明中，表示整个方法为同步方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;  </span><br><span class="line">            <span class="comment">//需要被同步的代码</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><blockquote>
<ul>
<li><p>java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</p>
<ul>
<li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只有一个线程访问该对象。</li>
</ul>
<p>				</p>
</li>
<li><p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，&#x3D;&#x3D;表明该对象在任一时刻只能由一个线程访问&#x3D;&#x3D;。</p>
</li>
<li><p>同步的局限性：导致程序的执行效率要降低。</p>
</li>
<li><p>同步方法(非静态的) 的锁可以是this，也可以是其他对象(&#x3D;&#x3D;要求是同一个对象&#x3D;&#x3D;)</p>
</li>
<li><p>同步方法(静态的) 的锁为当前类本身，不是this。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 	start <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;  </span><br><span class="line">  		<span class="keyword">synchronized</span> (当前类名.class)&#123;  </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步代码块的锁可以是this也可以是其他对象。</p>
</li>
<li><p>同步方法如果没有使用static修饰，默认锁对象为this。</p>
</li>
<li><p>如果方法使用static修饰，默认锁对象：&#x3D;&#x3D;当前类.class&#x3D;&#x3D;</p>
</li>
</ul>
</blockquote>
<h4 id="47-7-线程的死锁"><a href="#47-7-线程的死锁" class="headerlink" title="47.7. 线程的死锁"></a>47.7. 线程的死锁</h4><blockquote>
<p>多个线程都占用了对方的锁资源，但是都不肯相让，导致了死锁，在编程是一定要避免死锁的发生。</p>
</blockquote>
<h4 id="47-8-释放锁"><a href="#47-8-释放锁" class="headerlink" title="47.8 释放锁"></a>47.8 释放锁</h4><blockquote>
<p>下面的操作会释放锁：</p>
<ul>
<li>当前线程的同步方法，同步代码块结束。</li>
<li>当前线程在同步代码块，同步方法中遇到break，return。</li>
<li>当前线程在同步代码块，同步方法中出现了未处理的Error和Excepotion，导致异常结束，</li>
<li>当前线程在同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ul>
<p>下面的操作不会释放锁：</p>
<ul>
<li>线程执行同步代码块或者同步方法时，程序调用Thread.sleep(),Thread.yield()方法暂停当前线程的执行，不会释放锁。</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起。</li>
</ul>
</blockquote>
<h3 id="48-IO流"><a href="#48-IO流" class="headerlink" title="48. IO流"></a>48. IO流</h3><blockquote>
<p>文件：文件就是保存数据的地方。 </p>
<p>文件流： 文件在程序中是以流的形式来操作的。</p>
<ul>
<li>流：数据在数据源(文件)和程序(内存)之间经历的路径。</li>
<li>输入流：数据从数据源(文件)到程序(内存)的路径。</li>
<li>输出流：数据从程序(内存)到数据源(文件)的路径。</li>
<li>File实现了Serializable和Comparable接口可以串行化和排序。</li>
</ul>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/io接口图.png"></p>
<h4 id="File创建文件对象相关构造器"><a href="#File创建文件对象相关构造器" class="headerlink" title="File创建文件对象相关构造器"></a>File创建文件对象相关构造器</h4><blockquote>
<p>File中的路径中不同系统中路径分隔符不同。</p>
</blockquote>
<blockquote>
<p>构造器：</p>
<ul>
<li><p>new File(String pathname)  &#x2F;&#x2F;根据路径构建一个File对象。</p>
</li>
<li><p>使用createNewFile()方法可以创建对应文件。</p>
<ul>
<li>&#96;&#96;&#96;java<br>String filePath &#x3D; “D:\writ\news1.txt”;<br>File file &#x3D; new File(filePath);<br>try {<br>file.createNewFile();<br>} catch (IOException e) {<br>e.printStackTrace();<br>}<br>System.out.println(“文件创建成功”);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- new File(File parent,String child)  //根据父目录文件 + 子路径构建</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String parentFilestr = &quot;D:\\writ\\&quot;;</span><br><span class="line">String fileName = &quot;new2.txt&quot;;</span><br><span class="line"></span><br><span class="line">	 File parentFile = new File(parentFilestr,fileName1);</span><br><span class="line">File file = new File(parentFile,fileName2);</span><br><span class="line">try &#123;</span><br><span class="line">file.createNewFile();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;文件创建成功&quot;);</span><br></pre></td></tr></table></figure>



<ul>
<li><p>new File(String parent,String child) &#x2F;&#x2F;根据父目录路径 + 子路径构建</p>
<ul>
<li>&#96;&#96;&#96;java<br>String parentFile &#x3D; “D:\writ\“;<br>String filePath &#x3D; “new3.txt”;<br>File file &#x3D; new File(parentFile,filePath);<br>try {<br>file.createNewFile();<br>} catch (IOException e) {<br>e.printStackTrace();<br>}<br>System.out.println(“文件创建成功”);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 常用文件的操作</span><br><span class="line"></span><br><span class="line">getName:  获取文件的名字</span><br><span class="line"></span><br><span class="line">getAbsolutePath:  获取文件的据对路径</span><br><span class="line"></span><br><span class="line">getParent:  获取文件的父级目录</span><br><span class="line"></span><br><span class="line">Iength: 获取文件的大小(字节)</span><br><span class="line"></span><br><span class="line">exists:   是否存在文件</span><br><span class="line"></span><br><span class="line">isFile:  是否是一个文件</span><br><span class="line"></span><br><span class="line">isDiectory:  是否是一个路径；</span><br><span class="line"></span><br><span class="line">mkdir:创建一级目录。</span><br><span class="line"></span><br><span class="line">- 创建单级目录，返回一个boolean值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  String parentFile = &quot;D:\\writ\\newFile&quot;;</span><br><span class="line">  File file = new File(parentFile);</span><br><span class="line">  if (file.mkdir()) &#123;</span><br><span class="line">  System.out.println(&quot;成功&quot;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">  System.out.println(&quot;失败&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdirs:创建多级目录</span><br><span class="line"></span><br><span class="line">- 返回多级目录，返回一个boolean值</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">String parentFile = &quot;D:\\writ\\newFile\\jbz\\cql&quot;;</span><br><span class="line">File file = new File(parentFile);</span><br><span class="line">if (file.mkdirs()) &#123;</span><br><span class="line">System.out.println(&quot;成功&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">delete:==删除空目录==或者文件</span><br><span class="line"></span><br><span class="line">在java编程中目录被当作特殊的文件。</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h4><ul>
<li><p>Java IO流原理：</p>
<ul>
<li>IO是Input&#x2F;Output的缩写，IO技术是非常实用的技术，用于处理数据传输。如读写文件，网络通讯。</li>
<li>Jave程序中，对于数据的输入输出操作以流(stream)的方式进行。</li>
<li>java.io包下提供了各种流类和接口，用以获取不同种类的数据，并通过方法输入或者输出数据。</li>
<li>输入input：读取外部数据(磁盘，光盘等存储设备的数据)到程序(内存)中。</li>
<li>输出output: 将程序(内存)数据输出到磁盘，光盘等存储设备中。</li>
</ul>
</li>
<li><p>流的分类：</p>
<ul>
<li>按照操作数据的单位不同分为： 字节流(8bit，对二进制文件如声音文件比较好),字符流(按字符对文本文件操作比较好)</li>
<li>按照数据流的流向不同分为：  输入流，输出流</li>
<li>按照流的角色的不同分为：节点流，处理流&#x2F;包装流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<ol>
<li>java的io流共涉及40多个类，实际上非常规则，都是从如上四个抽象基类中派生的。</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li>
</ol>
</li>
</ul>
<h4 id="InputStream-字节输入流"><a href="#InputStream-字节输入流" class="headerlink" title="InputStream 字节输入流"></a>InputStream 字节输入流</h4><blockquote>
<p>inputStream抽象类是所有类字节输入流的超类。</p>
<p>inputStream常用子类：</p>
<ul>
<li>FileInputStream： 文件输入流</li>
<li>BufferedInputStream ：处理字节输入流</li>
<li>ObjectInputStream： 对象字节输入流</li>
</ul>
</blockquote>
<h4 id="OutputStream-字节输出流"><a href="#OutputStream-字节输出流" class="headerlink" title="OutputStream 字节输出流"></a>OutputStream 字节输出流</h4><blockquote>
<p>OutputStream 抽象类是所有类字节输出流的超类。</p>
<p>OutputStream 常用子类：</p>
<ul>
<li>FileOutputStream ： 文件输出流</li>
<li>BufferedOutputStream  ： 处理字节输出流</li>
<li>ObjectOutputStream ： 对象字节输出流</li>
</ul>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/Inputstream父类图.png"></p>
<h4 id="FileInputStream-文件字节输入流"><a href="#FileInputStream-文件字节输入流" class="headerlink" title="FileInputStream  文件字节输入流"></a>FileInputStream  文件字节输入流</h4><blockquote>
<p>构造器：</p>
<p>​	FileInputStream  f &#x3D; new FileInputStream(文件路径);</p>
<p>方法：</p>
<ul>
<li><p>read();</p>
<ul>
<li>对指定文件读入单个字节。</li>
<li>如果读取完毕返回-1,正常读取返回char的码值。</li>
</ul>
</li>
<li><p>read(byte[] b)</p>
<ul>
<li><p>传入一个字符数组，对指定文件读入指定字符数组的长度存储在传入的字符数组中。</p>
</li>
<li><p>如果读取完毕返回-1，未到结尾返回读取的个数；</p>
</li>
<li><p>这个返回的数组只是存储读取到的字符，如果到达尽头没有读取到数组长度的字符，则之前读取过的字符不会刷新还是维持之前保存的字符。</p>
</li>
<li><p>可以结合new String(字节数组，开始，结束)构造器得到字符。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------read()---------------</span></span><br><span class="line"><span class="type">int</span> readData;</span><br><span class="line"><span class="type">String</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\jbz.txt&quot;</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(parentFile);</span><br><span class="line">  <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)readData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//关闭输入流</span></span><br><span class="line"> fileInputStream.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------read(byte[] buf)---------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> readLen;</span><br><span class="line"><span class="type">String</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\jbz.txt&quot;</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(parentFile);</span><br><span class="line"><span class="comment">//正常读取返回读取到的字节数，已经到达结束未读取到字节返回-1</span></span><br><span class="line"><span class="comment">//如果读取到的长度不到指定字节数组的长度则再下一次读取返回-1，此次读取只返回读取的字节长度。</span></span><br><span class="line">	<span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">   		<span class="comment">//利用返回的长度使用String构造器读取字符串。</span></span><br><span class="line">        System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">//关闭输入流</span></span><br><span class="line">	fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="FileOutputStream-文件字节输出流"><a href="#FileOutputStream-文件字节输出流" class="headerlink" title="FileOutputStream  文件字节输出流"></a>FileOutputStream  文件字节输出流</h4><blockquote>
<p>构造器：</p>
<p>​	FileOutputStream  file &#x3D; new FileOutputStream (文件路径);</p>
<p>​	FileOutputStream  file &#x3D; new FileOutputStream (文件路径，是否以添加形式);   &#x2F;&#x2F;当是否以添加形式为true时，写入的字节将添加到文件的末尾，而不是替换。</p>
<p>方法：</p>
<p>​	write( byte );  将指定字节写入指定文件中 </p>
<p>​	write( str.getBytes() );  </p>
<p>​	write( str.getBytes() ,开始，结尾); </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fil</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\jbz.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置将字符添加到文件末尾</span></span><br><span class="line">            fil = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(parentFile,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ddddd&quot;</span>;</span><br><span class="line">            fil.write(str.getBytes());</span><br><span class="line">            fil.write(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="FileReader-文件字符输入流"><a href="#FileReader-文件字符输入流" class="headerlink" title="FileReader  文件字符输入流"></a>FileReader  文件字符输入流</h4><blockquote>
<p>FileReader 和 FileWrite是字符流，即按照字符来操作io。</p>
<p>构造器：</p>
<p>​	FileReader(文件路径)；</p>
<p>方法：</p>
<p>​	read()每次读取单个字符，返回该字符，如果到文件末尾返回-1；</p>
<p>​	read(char[]): 批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1.</p>
<p>​	&#x3D;&#x3D;返回的char数组重复使用的时候不会清空而是只覆盖获得数组长度的位置。&#x3D;&#x3D;</p>
<p>相关API：</p>
<p>​	new String(char[]):将char[]转换为String；</p>
<p>​	new String(char[],off,len):将char[]的指定部分转换成String。</p>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/read类.png"></p>
<h4 id="FileWrite-文件字符输出流"><a href="#FileWrite-文件字符输出流" class="headerlink" title="FileWrite  文件字符输出流"></a>FileWrite  文件字符输出流</h4><blockquote>
<p>FileReader 和 FileWrite是字符流，即按照字符来操作io。</p>
<p>构造器：</p>
<p>​	FileWrite(文件路径);    &#x2F;&#x2F;覆盖模式，相当于流的指针在首端。</p>
<p>​	FileWrite(文件路径，true); &#x2F;&#x2F;追加模式，相当于流的指针在尾端。</p>
<p>方法：</p>
<p>​	write(int); 写入单个字符。</p>
<p>​	write(char[]); 写入指定数组。</p>
<p>​	write(char[],off,len) 写入指定数组的指定部分。</p>
<p>​	write(String)；  写入整个字符串</p>
<p>​	 write(String,off,len) 写入指定字符串的指定部分。</p>
<p>相关API：</p>
<p>​	toCharArray 将指定String转换成char[];</p>
<p>注意：&#x3D;&#x3D;FileWriter使用后，必须要关闭(close)或者刷新(flush)，否则写入不到指定的文件。&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/filrwrite类.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">char</span>[] str = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">le</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">filp</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\jbz.txt&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filp);</span><br><span class="line">      <span class="keyword">while</span> ((le = fr.read(str)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(str,<span class="number">0</span>,le));</span><br><span class="line">      &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          fr.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="节点流和处理流区别"><a href="#节点流和处理流区别" class="headerlink" title="节点流和处理流区别"></a>节点流和处理流区别</h4><blockquote>
<p>节点流可以从一个特定的数据源读写数据。(FileRead,FileWriter)</p>
<p>处理流(包装流)是链接已经存在的流(处理流或节点流)之上，为程序提供更为强大的读写功能。(BufferedReader,BufferedWriter，BufferedOutputStream，BufferedInputStream)</p>
</blockquote>
<p>节点流和处理流的区别和联系：</p>
<ol>
<li>节点流是底层流，低级流，可以直接和数据源相接。</li>
<li>处理流包装节点流，即可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</li>
<li>处理流(包装流)，对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连。</li>
</ol>
<p>处理 流功能：</p>
<ul>
<li>性能的提高：&#x3D;&#x3D;主要以增加缓冲的方式来提高输入输出的效率。&#x3D;&#x3D;</li>
<li>操作的便捷：处理流可以提供一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便。</li>
</ul>
<h4 id="BufferedReader-字符输入处理流"><a href="#BufferedReader-字符输入处理流" class="headerlink" title="BufferedReader 字符输入处理流"></a>BufferedReader 字符输入处理流</h4><blockquote>
<p>BufferedReader 和 BufferedWrite 属于字符流，是按照字符来读取数据。&#x3D;&#x3D;关闭时，只需要关闭外层流既可&#x3D;&#x3D;。</p>
<p>不要使用字符流来读取二进制文件。</p>
<p>构造器：</p>
<p>​	BufferedReader(reader流)</p>
<p>方法：</p>
<p>​	readLine()； 按行返回字符串，如果已经到达流的结尾返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\Bufferedtest.txt&quot;</span>;</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line"> <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">      System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;&#x3D;只需要关闭处理流(外层)，就可以在底层代码中关闭节点流。&#x3D;&#x3D;</li>
</ul>
</blockquote>
<h4 id="BufferedWriter-字符输出处理流"><a href="#BufferedWriter-字符输出处理流" class="headerlink" title="BufferedWriter 字符输出处理流"></a>BufferedWriter 字符输出处理流</h4><blockquote>
<p>BufferedReader 和 BufferedWrite 属于字符流，是按照字符来读取数据。&#x3D;&#x3D;关闭时，只需要关闭外层流既可&#x3D;&#x3D;。</p>
<p>不要使用字符流来读取二进制文件。</p>
<p>构造器：</p>
<p>​	BufferedWriter(Writer流);</p>
<p>​	BufferedWriter( Writer流(文件路径,true) );</p>
<p>方法：</p>
<p>​	writer( String );  &#x2F;&#x2F;插入指定字符串,不会换行.</p>
<p>​	newLine();  &#x2F;&#x2F;插入一个换行，与系统相关的换行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;开始的开始我们都是孩子&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\Bufferedtest.txt&quot;</span>;</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">bufferedWriter.write(line);</span><br><span class="line">bufferedWriter.close();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="BufferedInputStream-字节输入处理流"><a href="#BufferedInputStream-字节输入处理流" class="headerlink" title="BufferedInputStream 字节输入处理流"></a>BufferedInputStream 字节输入处理流</h4><blockquote>
<p>BufferedInputStream是字节流，在创建BufferedInputStream时，会创建一个内部缓冲区数组。</p>
<p>构造器：</p>
<p>​	BufferedInputStream( InputStream流 )；</p>
<p>​	BufferedInputStream( InputStream流 ，size)；</p>
</blockquote>
<h4 id="BufferedOutputStream-字节输出处理流"><a href="#BufferedOutputStream-字节输出处理流" class="headerlink" title="BufferedOutputStream 字节输出处理流"></a>BufferedOutputStream 字节输出处理流</h4><blockquote>
<p>BufferedOutputStream是字节流，在创建BufferedOutputStream 时，会创建一个内部缓冲区数组。</p>
<p>构造器：</p>
<p>​	BufferedOutputStream(OutputStream流);</p>
<p>​	BufferedOutputStream(OutputStream流(路径,true));</p>
</blockquote>
<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><blockquote>
<p>能够将基本数据类型或者对象进行序列化。使用修饰者模式。</p>
<ul>
<li><p>序列化：保存数据时，保存数据的值和数据类型。</p>
</li>
<li><p>反序列化： 将保存的数据回复值和数据类型。</p>
</li>
<li><p>序列化后，保存的文件格式，不以保存文件后缀保存，以自身的格式来保存。</p>
</li>
<li><p>需要让某个对象支持序列化机制，则必须让其类时可序列化的，为了让某个类时可序列化的，&#x3D;&#x3D;该类必须实现如下两个接口之一&#x3D;&#x3D;：</p>
<ul>
<li>Serializable   &#x2F;&#x2F;标记接口，没有任何方法</li>
<li>Externalizable  &#x2F;&#x2F;该接口有方法需要实现</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>writeInt(100);  		&#x2F;&#x2F;保存int类型</li>
<li>writeBoolean(true);  &#x2F;&#x2F;保存boolean类型</li>
<li>writeDouble(1.2);   &#x2F;&#x2F;保存double</li>
<li>writeUTF(“你好”);  &#x2F;&#x2F;保存字符串</li>
<li>writeChar(‘s’);  &#x2F;&#x2F;保存char</li>
<li>oos.writeObject(对象);  &#x2F;&#x2F;保存实现接口的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\wht.txt&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> 			 						<span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line"></span><br><span class="line">        oos.writeInt(<span class="number">100</span>);  <span class="comment">//自动进行装箱操作</span></span><br><span class="line">        oos.writeBoolean(<span class="literal">true</span>);  <span class="comment">//自动进行装箱操作</span></span><br><span class="line">        oos.writeDouble(<span class="number">1.2</span>);   <span class="comment">//自动进行装箱操作</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><blockquote>
<p>能够将基本数据类型或者对象进行反序列化。使用修饰者模式。</p>
<ul>
<li><p>序列化：保存数据时，保存数据的值和数据类型。</p>
</li>
<li><p>反序列化： 将保存的数据回复值和数据类型。</p>
</li>
<li><p>需要让某个对象支持序列化机制，则必须让其类时可序列化的，为了让某个类时可序列化的，该类必须实现如下两个接口之一：</p>
<ul>
<li>Serializable   &#x2F;&#x2F;标记接口，没有任何方法</li>
<li>Externalizable  &#x2F;&#x2F;该接口有方法需要实现</li>
</ul>
</li>
<li><p>方法：</p>
</li>
<li><p>readInt();  &#x2F;&#x2F;保存int类型</p>
</li>
<li><p>readBoolean();  &#x2F;&#x2F;保存boolean类型</p>
</li>
<li><p>readDouble();   &#x2F;&#x2F;保存double</p>
</li>
<li><p>readUTF();  &#x2F;&#x2F;保存字符串</p>
</li>
<li><p>readChar();  &#x2F;&#x2F;保存char</p>
</li>
<li><p>&#x3D;&#x3D;读取的顺序需要和序列化的顺序一致。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;反序列化对象，对应的类应该被定义。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">System.out.println(ois.readInt());</span><br><span class="line">System.out.println(ois.readBoolean());</span><br><span class="line">System.out.println(ois.readDouble());</span><br><span class="line">System.out.println(ois.readUTF());</span><br><span class="line">System.out.println(ois.readChar());</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<blockquote>
<p>注意细节:</p>
<ol>
<li><p>&#x3D;&#x3D;读写顺序需要一致.&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;要求实现序列化或者反序列化对象,需要实现Serializable&#x3D;&#x3D;</p>
</li>
<li><p>序列化的类中添加SerialVersionUID,为了提高版本的兼容性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//序列化的版本号,实现兼容性.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化对象时,默认将里面的所有属性都进行序列化但是除了static和transient修饰的成员.</p>
</li>
<li><p>序列化对象时,要求里面的属性的类型也需要实现对应的序列化接口了.</p>
</li>
<li><p>序列化具备可继承性,也就是如果某类已经实现了序列化,则它的所有子类也已经默认实现序列化.</p>
</li>
</ol>
</blockquote>
<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><blockquote>
<p>in 编译类型: InputStream 运行类型: BufferedInputStream</p>
<p>out 编译类型: PrintStream 运行类型: PrintStream</p>
</blockquote>
<table>
<thead>
<tr>
<th>标准输入输出流</th>
<th>类型</th>
<th>默认设备</th>
</tr>
</thead>
<tbody><tr>
<td>System.in</td>
<td>InputSteam</td>
<td>键盘</td>
</tr>
<tr>
<td>System.out</td>
<td>PrintStream</td>
<td>显示器</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Systeam.out.println();</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">san</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>





<h4 id="转换流定义"><a href="#转换流定义" class="headerlink" title="转换流定义"></a>转换流定义</h4><blockquote>
<p>字符流的默认编码是UTF-8,如果文件使用的编码不是默认的UTF-8则使用字符流读取会出现乱码现象。</p>
<p>转换流InputStreamReader 和 OutputStreamWriter可以实现字节流向字符流的转换&#x3D;&#x3D;并且实现指定编码方式。&#x3D;&#x3D;</p>
<p>InputStreamReader是Reader的子类，可以将InputStream(字节流)包装称为Reader(字符流)，并且指定编码方式;</p>
<p>OutputStreamWriter是Writer的子类，可以将 OutputStream(字节流)包装为Writer(字符流)，并且指定编码方式；</p>
<p>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流。</p>
<p>可以在使用时指定编码格式： utf-8,gbk,gb2312,iso8859-1</p>
</blockquote>
<h4 id="InputStreamReader-转换输入流"><a href="#InputStreamReader-转换输入流" class="headerlink" title="InputStreamReader 转换输入流"></a>InputStreamReader 转换输入流</h4><blockquote>
<p>构造器：</p>
<p>​	InputStreamReader(inputStream流 , 编码); 传入一个inputStream.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\wht.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">//创建一个字节流，使用转换流转换为字符流，再将字符流包装为处理流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath),<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((str = bfr.readLine()) !=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        bfr.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h4 id="OutputStreamWriter-转换输出流"><a href="#OutputStreamWriter-转换输出流" class="headerlink" title="OutputStreamWriter  转换输出流"></a>OutputStreamWriter  转换输出流</h4><blockquote>
<p>构造器：</p>
<p>​	OutputStreamWriter(OutputStream流，编码); 传入一个OutputStream.</p>
<p>可以用该种方式创建指定编码方式的文件。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\wht.txt&quot;</span>;</span><br><span class="line">     <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;歌谣的歌谣，藏着童话的影子&quot;</span>;</span><br><span class="line">  <span class="comment">//创建一个字节流使用转换流转换为字符流，再将该字符流包装为处理流</span></span><br><span class="line">     <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath,<span class="literal">true</span>),<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">     bw.newLine();</span><br><span class="line">     bw.write(str);</span><br><span class="line">     bw.close();</span><br><span class="line">     System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="打印流定义"><a href="#打印流定义" class="headerlink" title="打印流定义"></a>打印流定义</h4><blockquote>
<p>打印流没有输入流只有输出流。</p>
<p>在默认情况下输出数据的位置是显示器。</p>
<p>PrintStream</p>
<p>PrintWriter</p>
</blockquote>
<h4 id="PrintStream-字节打印流"><a href="#PrintStream-字节打印流" class="headerlink" title="PrintStream 字节打印流"></a>PrintStream 字节打印流</h4><blockquote>
<p>构造器：</p>
<p>​	PrintStream(文件路径);</p>
<p>​	PrintStream( InputStream流 )；</p>
<p>方法：</p>
<p>​	System.setOut(new PrintStream(文件路径)); &#x2F;&#x2F;设置输出的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\wht.txt&quot;</span>;</span><br><span class="line"><span class="comment">//设置打印位置</span></span><br><span class="line">     System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(filePath));</span><br><span class="line">     System.out.println(<span class="string">&quot;最后的最后&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="PrintWriter-字符打印流"><a href="#PrintWriter-字符打印流" class="headerlink" title="PrintWriter 字符打印流"></a>PrintWriter 字符打印流</h4><blockquote>
<p>构造器：</p>
<p>​	PrintWriter( Writer流 )</p>
<p>方法：</p>
<p>​	print() &#x2F;&#x2F;向指定位置输出字符</p>
<p>​	close() &#x2F;&#x2F;关闭打印流。</p>
<p>&#x3D;&#x3D;如果不关闭打印流，不会刷新不会打印进去。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\writ\\wht.txt&quot;</span>;</span><br><span class="line">     <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">     pw.println(<span class="string">&quot;开始的开始&quot;</span>);</span><br><span class="line">     pw.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h4><blockquote>
<p>专门用于读写配置文件的集合类。配置文件的格式”</p>
<p>​				<code>键=值</code></p>
<p>​				<code>键=值</code></p>
<p>键值对不需要有空格，值不需要用引号引起来，默认类型是String。</p>
<p>方法：</p>
<ul>
<li>load() : 加载配置文件的键值对到Properties对象。</li>
<li>list() : 将数据显示到指定设备。</li>
<li>getProperty(key) : 根据键获取值。</li>
<li>setProperty(key,value): 设置键值对到Properties对象。如果没有就是创建，如果有就是替换。</li>
<li>store( InputStream流，注释)：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取配置文件的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;src\\myProperties.properties&quot;</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        ps.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">        ps.list(System.out);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> ps.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;src\\myProperties2.properties&quot;</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pr.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;cql&quot;</span>);</span><br><span class="line">        pr.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;nnn&quot;</span>);</span><br><span class="line">        pr.setProperty(<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;10086&quot;</span>);</span><br><span class="line">        pr.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath),<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;配置成功&quot;</span>);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>



<h4 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">while ((readLean = bufferedInputStream.read(by)) != -1)&#123;</span><br><span class="line">    bos.write(by,0,readLean);</span><br><span class="line">&#125;</span><br><span class="line">byte[] array = bos.toByteArray();</span><br></pre></td></tr></table></figure>







<h3 id="49-网络编程"><a href="#49-网络编程" class="headerlink" title="49.网络编程"></a>49.网络编程</h3><h4 id="ip地-址："><a href="#ip地-址：" class="headerlink" title="ip地 址："></a>ip地 址：</h4><blockquote>
<p>概念：用于唯一表示网络中的每台计算机&#x2F;主机。</p>
<p>查看ip地址： ipconfig</p>
<p>ip地址的表示形式：点分十进制。(每个十进制的范围0~255)</p>
<p>IPv4使用四个字节，IPv6使用十六个字节</p>
<p>IP地址的组成 &#x3D; 网络地址 + 主机地址</p>
<p>IPv6是互联网工程任务组设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界任何一粒沙子编上一个地址。</p>
<p>因为IPv4的最大问题在于网络地址资源有限，严重制约了互联网的应用和发展，IPv6的使用，不仅能解决网络资源数量的问题，而且也解决了多种接入设备连入互联网的障碍。</p>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/ipv4.png"></p>
<p>特殊： 127.0.0.1</p>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><blockquote>
<p>概念：将ip地址映射为域名。方面记忆，解决ip的记忆困难。</p>
</blockquote>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><blockquote>
<p>概念：用于标识计算器上某个特定的网络程序。</p>
<p>表示形式：使用整数形式，范围0~65535(2个字节)</p>
<p>0 ~ 1024已经被占用，比如ssh 22，ftp 21 ， smtp 25，http 80</p>
</blockquote>
<h4 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h4><p>TCP&#x2F;IP中文译名为传输控制协议&#x2F;因特网互联协议，又叫网络通讯协议，这个协议是Internet最基本的协议，Internet国际互联网络的基础，简单的说，就是网络层的ip协议和传输层的TCP协议组成的。</p>
<p>TCP协议：传输控制协议</p>
<ol>
<li>使用TCP协议前，需要建立TCP链接，形成传输数据通道。</li>
<li>传输前，采用三次握手方式，是可靠的。</li>
<li>TCP协议进行通信的两个应用进程：客户端，服务器</li>
<li>在链接中可以进行大量数据的传输。</li>
<li>传输完毕，需要释放已经建立的链接，效率低。</li>
</ol>
<p>UDP协议：</p>
<ol>
<li><p>将数据，源，目的封装成数据包，&#x3D;&#x3D;不需要建立链接&#x3D;&#x3D;。</p>
</li>
<li><p>因为是无需连接的，所以是不可靠的。</p>
</li>
<li><p>每个数据报的大小限制在64k内。</p>
</li>
<li><p>发送数据结束后无需释放资源(因为不是面向链接的)，速度快。</p>
</li>
</ol>
<h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><blockquote>
<p>InetAddress类实现了Serializable接口所以可以实现串行化。</p>
<p>获取InetAddress类对象：</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前主机的InetAddress类</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localhost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line"><span class="comment">//获取指定域名的InetAddress类</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localhost</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;网址&quot;</span>)</span><br><span class="line"><span class="comment">//获取指定主机名的InetAddress类</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localhost</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;主机名&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过  InetAddress对象获得ip地址</span></span><br><span class="line">localhost.getHostAddress();</span><br><span class="line"><span class="comment">//通过  InetAddress对象获得域名</span></span><br><span class="line">localhost.getHostName()</span><br><span class="line"><span class="comment">//输出本机的ip地址和本机名</span></span><br><span class="line">System.out.println(localhost);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><ol>
<li>套接字(Socket)开发网络应用程序被广泛采用，以至于称为事实上的标准。</li>
<li>通信的两端都要有Socket，这是两台机器间通信的端点。</li>
<li>网络通信其实就是socket间的通信。</li>
<li>socket允许程序把网络链接当成一个流，数据在两个socket间通过IO传输。</li>
<li>一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端。</li>
</ol>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/socket图解.png"></p>
<h4 id="TCP网络通信编程"><a href="#TCP网络通信编程" class="headerlink" title="TCP网络通信编程"></a>TCP网络通信编程</h4><blockquote>
<p>当客户端连接到服务端后，实际上也是通过一个端口和服务端进行通讯的，这个端口是TCP&#x2F;IP来分配的，是不确定的，是随机的。</p>
</blockquote>
<h5 id="TCP字节流编程"><a href="#TCP字节流编程" class="headerlink" title="TCP字节流编程"></a>TCP字节流编程</h5><blockquote>
<p>TCP字节流编程步骤：</p>
<p>服务器：                                       </p>
<ol>
<li>设置监听端口获得ServerSocket对象。<ul>
<li><code>ServerSocket serverSocket = new ServerSocket(监听端口号);</code></li>
</ul>
</li>
<li>获得socket对象<ul>
<li><code>Socket socket = serverSocket.accept();</code>   &#x2F;&#x2F;如果监听到数据会执行，如果没有阻塞。</li>
</ul>
</li>
<li>通过使用socket对象获得输入流，将数据通道的数据取出。<ul>
<li><code>InputStream inputStream = socket.getInputStream();</code></li>
<li><code>inputStream.read()</code></li>
</ul>
</li>
<li>通过使用socket对象获得输出流，像数据通道写入数据。<ul>
<li><code>OutputStream outputStream = socket.getOutputStream();</code></li>
<li><code>outputStream.write(字符)</code></li>
</ul>
</li>
<li>设置写入结束标记。<ul>
<li><code>socket.shutdownOutput();</code>   &#x2F;&#x2F;如果不设置结束标记Socket对象会一直等待</li>
</ul>
</li>
<li>关闭输入输出流，socket对象，ServerSocket对象。<ul>
<li><code>outputStream.close();</code></li>
<li><code>inputStream.close();</code></li>
<li><code>socket.close();</code></li>
<li><code>serverSocket.close();</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//建立端口监听</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------服务器监听中……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------服务器客户端通道建立&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用cocket对象向数据通道读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(by)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(by,<span class="number">0</span>,readLen)；</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器得到数据：&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用cocket对象向数据通道写入数据</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;$$$$服务器向客户端返回的数据&quot;</span>.getBytes());</span><br><span class="line">		socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------客户端返回数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流和socket</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>客户端：</p>
<ol>
<li>连接指定InetAddress的服务器，设置端口。获得Socket对象<ul>
<li><code>Socket socket = new Socket(InetAddress对象, 端口);</code></li>
</ul>
</li>
<li>通过使用socket对象获得输出流，像数据通道写入数据。<ul>
<li><code>OutputStream outputStream = socket.getOutputStream();</code></li>
<li><code>outputStream.write(字符)</code></li>
</ul>
</li>
<li>设置写入结束标记。<ul>
<li><code>socket.shutdownOutput();</code>   &#x2F;&#x2F;如果不设置结束标记Socket对象会一直等待</li>
</ul>
</li>
<li>通过使用socket对象获得输入流，将数据通道的数据取出。<ul>
<li><code>InputStream inputStream = socket.getInputStream();</code></li>
<li><code>inputStream.read()</code></li>
</ul>
</li>
<li>关闭输入输出流，socket对象。<ul>
<li><code>outputStream.close();</code></li>
<li><code>inputStream.close();</code></li>
<li><code>socket.close();</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//连接指定服务器的指定端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用socket对象向数据通道中写入数据(字节流)</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        outputStream.write(<span class="string">&quot;￥￥￥￥客户端发送的数据&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端向服务器发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用socket对象向数据通道中读取数据(字符流)</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((readLen = inputStream.read(by)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(by,<span class="number">0</span>,readLen)</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器返回的数据：&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------客户端返回数据&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭流也socket对象</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="TCP字符流编程"><a href="#TCP字符流编程" class="headerlink" title="TCP字符流编程"></a>TCP字符流编程</h5><blockquote>
<p>TCP字符流编程步骤：</p>
<p>服务器：                                       </p>
<ol>
<li>设置监听端口获得ServerSocket对象。<ul>
<li><code>ServerSocket serverSocket = new ServerSocket(监听端口号);</code></li>
</ul>
</li>
<li>获得socket对象<ul>
<li><code>Socket socket = serverSocket.accept();</code></li>
</ul>
</li>
<li>通过使用socket对象获得输入流，将数据通道的数据取出，使用转换流和处理流得到相应的字符流。<ul>
<li><code>InputStream inputStream = socket.getInputStream();</code></li>
<li><code>BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); </code>   &#x2F;&#x2F;使用转换流和处理流</li>
<li><code>bufferedReader.read()</code></li>
</ul>
</li>
<li>通过使用socket对象获得输出流，像数据通道写入数据，使用转换流和处理流得到相应的字符流。<ul>
<li><code>OutputStream outputStream = socket.getOutputStream();</code></li>
<li><code>BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));</code>     &#x2F;&#x2F;使用转换流和处理流</li>
<li><code>bufferedWriter.write(字符)</code></li>
</ul>
</li>
<li>设置写入结束标记,刷新流。<ul>
<li><code>bufferedWriter.newLine();</code>   &#x2F;&#x2F;如果不设置结束标记Socket对象会一直等待</li>
<li><code>bufferedWriter.flush();</code>    &#x2F;&#x2F;如果不设置刷新则不会写入数据</li>
</ul>
</li>
<li>关闭输入输出流，socket对象，ServerSocket对象。<ul>
<li><code>bufferedReader.close();</code></li>
<li><code>bufferedWriter.close();</code></li>
<li><code>socket.close();</code></li>
<li><code>serverSocket.close();</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//建立端口监听</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------服务器监听中……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------服务器客户端通道建立&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用cocket对象向数据通道读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器得到数据：&quot;</span> + str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用cocket对象向数据通道写入数据</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;$$$$服务器向客户端返回的数据&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------客户端返回数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流和socket</span></span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>客户端：</p>
<ol>
<li>连接指定InetAddress的服务器，设置端口。获得Socket对象<ul>
<li><code>Socket socket = new Socket(InetAddress对象, 端口);</code></li>
</ul>
</li>
<li>通过使用socket对象获得输出流，像数据通道写入数据，使用转换流和处理流得到相应的字符流。<ul>
<li><code>OutputStream outputStream = socket.getOutputStream();</code></li>
<li><code>BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(outputStream));</code>     &#x2F;&#x2F;使用转换流和处理流</li>
<li><code>bufferedWriter.write(字符)</code></li>
</ul>
</li>
<li>设置写入结束标记,刷新流。<ul>
<li><code>bufferedWriter.newLine();</code>   &#x2F;&#x2F;如果不设置结束标记Socket对象会一直等待</li>
<li><code>bufferedWriter.flush();</code>    &#x2F;&#x2F;如果不设置刷新则不会写入数据</li>
</ul>
</li>
<li>通过使用socket对象获得输入流，将数据通道的数据取出，使用转换流和处理流得到相应的字符流。<ul>
<li><code>InputStream inputStream = socket.getInputStream();</code></li>
<li><code>BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); </code>   &#x2F;&#x2F;使用转换流和处理流</li>
<li><code>bufferedReader.read()</code></li>
</ul>
</li>
<li>关闭输入输出流，socket对象。<ul>
<li><code>bufferedReader.close();</code></li>
<li><code>bufferedWriter.close();</code></li>
<li><code>socket.close();</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//连接指定服务器的指定端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用socket对象向数据通道中写入数据(字符流)</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;￥￥￥￥客户端发送的数据&quot;</span>);</span><br><span class="line">        <span class="comment">//设置写入数据结束标记</span></span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        <span class="comment">//刷新数据，如果不刷新不会将指定数据写入通道</span></span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端向服务器发送数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用socket对象向数据通道中读取数据(字符流)</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器返回的数据：&quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------客户端返回数据&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流与socket对象</span></span><br><span class="line"></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a>netstat指令</h4><blockquote>
<ol>
<li>netstat - an 可以查到当前主机网络情况，包括端口监听情况和网络连接情况。</li>
<li>netstat - an | more 可以分页显示。</li>
<li>要求在dos控制台下执行。</li>
</ol>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/netstat.png"></p>
<ul>
<li>LISTENING表示某个端口在监听。</li>
<li>如果有一个外部程序(客户端)连接到该端口，就会显示一天连接信息。</li>
</ul>
<h4 id="UDP网络通信编程"><a href="#UDP网络通信编程" class="headerlink" title="UDP网络通信编程"></a>UDP网络通信编程</h4><blockquote>
<ol>
<li>类DatagramSocket和DatagramPacket 实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以到达。</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的ip地址和端口号以及接收端的ip地址和端口号。</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的来连接。</li>
</ol>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/UDO图解.png"></p>
<p>说明：</p>
<ul>
<li>没有明确的服务端和客户端，演变成数据的发送端和接收端。</li>
<li>接收数据和发送数据是通过DatagramSocket对象完成。</li>
<li>将数据封装到DatagramPacket对象(装包)。</li>
<li>当接收到DatagramPacket对象，需要进行拆包，取出数据。</li>
<li>DatagramSocket可以指定在那个端口接收数据。</li>
<li>接收端和服务端都可以设定使用的接口。</li>
</ul>
<blockquote>
<p>构造器：</p>
<ul>
<li><p>DatagramSocket(端口号)；</p>
</li>
<li><p>DatagramPacket(数据, 数据长度,接收端InetAddress对象,端口号);   &#x2F;&#x2F;用于发送数据</p>
</li>
<li><p>DatagramPacket(数据, 数据长度);  &#x2F;&#x2F;用于接收数据</p>
<p>UDP编程步骤：</p>
</li>
</ul>
<ol>
<li>创建DatagramSocket对象，在指定端口等待接收数据<ul>
<li><code>DatagramSocket socket = new DatagramSocket(9998);</code></li>
</ul>
</li>
<li>将需要发送的数据封装为DatagramPacket对象。<ul>
<li><code>byte[] data = &quot;发送端封装的数据&quot;.getBytes();</code></li>
<li><code>DatagramPacket packet = new DatagramPacket(data, data.length,InetAddress.getLocalHost(),9999);</code> &#x2F;&#x2F;DatagramPacket(数据,数据长度,IP地址对象,端口);</li>
</ul>
</li>
<li>发送数据。<ul>
<li><code>socket.send(packet);</code></li>
</ul>
</li>
<li>构造接收数据的DatagramPacket对象。<ul>
<li><code>byte[] datas = new byte[64*1024];</code></li>
<li><code>DatagramPacket repacket = new DatagramPacket(datas, datas.length);</code> &#x2F;&#x2F;DatagramPacket(数据,数据长度);</li>
</ul>
</li>
<li>接收数据。<ul>
<li><code>socket.receive(repacket);</code></li>
</ul>
</li>
<li>将接收的数据报拆包。<ul>
<li><code>int length = repacket.getLength();</code></li>
<li><code>byte[] redata = repacket.getData();</code></li>
<li><code>String str = new String(redata,0,length);</code></li>
</ul>
</li>
<li>关闭资源<ul>
<li><code>socket.close();</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建DatagramSocket对象准备返回和接收数据</span></span><br><span class="line">        <span class="comment">//准备在指定端口接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.将需要发送的数据封装到DatagramPacket</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;发送端封装的数据&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//DatagramPacket(数据,数据长度,IP地址,端口);</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length,InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.发送数据</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------------------</span></span><br><span class="line">        <span class="comment">//5.构造接收datagramPacket对象</span></span><br><span class="line">        <span class="type">byte</span>[] datas = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>*<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">repacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(datas, datas.length);</span><br><span class="line">        <span class="comment">//6.接收数据</span></span><br><span class="line">        socket.receive(repacket);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据……&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.拆包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> repacket.getLength();</span><br><span class="line">        <span class="type">byte</span>[] redata = repacket.getData();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(redata,<span class="number">0</span>,length);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;B端退出……&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先接收端</p>
<ol>
<li>创建DatagramSocket对象，在指定端口等待接收数据<ul>
<li><code>DatagramSocket socket = new DatagramSocket(9998);</code></li>
</ul>
</li>
<li>构造接收数据的DatagramPacket对象。<ul>
<li><code>byte[] datas = new byte[64*1024];</code></li>
<li><code>DatagramPacket repacket = new DatagramPacket(datas, data.length);</code> &#x2F;&#x2F;DatagramPacket(数据,数据长度);</li>
</ul>
</li>
<li>接收数据。<ul>
<li><code>socket.receive(repacket);</code></li>
</ul>
</li>
<li>将接收的数据报拆包。<ul>
<li><code>int length = repacket.getLength();</code></li>
<li><code>byte[] redata = repacket.getData();</code></li>
<li><code>String str = new String(redata,0,length);</code></li>
</ul>
</li>
<li>将需要发送的数据封装为DatagramPacket对象。<ul>
<li><code>byte[] data = &quot;发送端封装的数据&quot;.getBytes();</code></li>
<li><code>DatagramPacket packet = new DatagramPacket(data, data.length,InetAddress.getLocalHost(),9999);</code> &#x2F;&#x2F;DatagramPacket(数据,数据长度,IP地址,端口);</li>
</ul>
</li>
<li>发送数据。<ul>
<li><code>socket.send(packet);</code></li>
</ul>
</li>
<li>关闭资源<ul>
<li><code>socket.close();</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个DatagramSocket对象，准备在指定端口接收数据，</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.构建一个DatagramPacket对象，准备接收数据.</span></span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf,buf.length);</span><br><span class="line">        <span class="comment">//3.调用接收方法。将通过网络传输的DatagramPacket对象填充到packet对象中。</span></span><br><span class="line">        <span class="comment">//当有数据报发送到本机指定端口时，会接收数据。如果没有数据发送到指定端口，就会阻塞等待。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正在9999端口等待数据到来……&quot;</span>);</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据进行拆包……&quot;</span>);</span><br><span class="line">        <span class="comment">//4.将packet进行拆包，取出数据，并显示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> packet.getLength(); <span class="comment">//实际接收到的数据长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = packet.getData();<span class="comment">//接收到数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//--------------------------</span></span><br><span class="line">        <span class="comment">//5.创建datagrampacketu对象封装数据。</span></span><br><span class="line">        <span class="type">byte</span>[] rebuf = <span class="string">&quot;重新发送的数据&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(rebuf, rebuf.length, InetAddress.getLocalHost(),<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//6.发送数据</span></span><br><span class="line">        socket.send(packets);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A端退出……&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="50-项目开发流程"><a href="#50-项目开发流程" class="headerlink" title="50. 项目开发流程"></a>50. 项目开发流程</h3><blockquote>
<p>需求分析 - 设计阶段 - 实现阶段 - 测试阶段 - 实施阶段 - 维护阶段</p>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/项目开发流程图.png"></p>
<h3 id="51-反射"><a href="#51-反射" class="headerlink" title="51. 反射"></a>51. 反射</h3><blockquote>
<p>通过外部文件配置，在不修改源码情况下，来控制程序，也符合设计模式ocp(开闭原则：不修改源码，扩容功能)</p>
<p>优点：</p>
<ul>
<li>可以动态的创建和使用对象(是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用反射基本是解释执行，对执行速度有影响。</li>
</ul>
</blockquote>
<h4 id="反射机制-java-reflection-："><a href="#反射机制-java-reflection-：" class="headerlink" title="反射机制(java reflection)："></a>反射机制(java reflection)：</h4><blockquote>
<p>反射机制允许程序在执行期借助于reflectionAPI取得任何类的内部信息(比如成员变量，构造器，成员方法等)，并能操作对象的属性以及方法。反射在设计模式和框架底层都会用到。</p>
<p>加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个CLass对象)，这个对象包含了类的完整结构信息，通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以称之为：反射。</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时得到任意一个类的所育有的成员变量的方法。</li>
<li>在运行时调用任意一个对象的成员变量和方法。</li>
<li>生成动态代理。</li>
</ul>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/反射机制.png" alt="反射机制图"></p>
<h4 id="反射机制相关类"><a href="#反射机制相关类" class="headerlink" title="反射机制相关类"></a>反射机制相关类</h4><blockquote>
<p>java.lang.Class  代表一个类，Class对象表示某个类加载后在堆中的对象。</p>
<p>java.lang.reflect.Method 代表类的方法 </p>
<p>java.lang.reflect.Field  代表类的成员变量</p>
<p>java.lang.reflect.Constructor 代表类的构造方法</p>
</blockquote>
<h4 id="反射操作对象"><a href="#反射操作对象" class="headerlink" title="反射操作对象"></a>反射操作对象</h4><blockquote>
<ol>
<li><p>使用Properties类操作配置文件，取出类的路径和方法名，属性名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pr.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;ClassName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;MethodName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fieldname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;FieldName&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>使用类的路径名，类名，构造出相应类的Class对象。<ul>
<li><code>Class cls = Class.forName(classname);</code></li>
</ul>
</li>
<li>通过Class类的对象加载类的实例<ul>
<li><code>Object o = cls.newInstance();</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//构造Properties类获取配置文件中的属性</span></span><br><span class="line">   		<span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pr.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;Username&quot;</span>);</span><br><span class="line">        <span class="comment">//加载类，返回Class类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classname);</span><br><span class="line">        <span class="comment">//通过cls得到加载类的实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o的运行类型为=&quot;</span> + o.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">Username=com.qn.resd.DouBao</span><br><span class="line">method=cry</span><br></pre></td></tr></table></figure>



<h4 id="反射操作方法"><a href="#反射操作方法" class="headerlink" title="反射操作方法"></a>反射操作方法</h4><blockquote>
<ol>
<li><p>使用Properties类操作配置文件，取出类的路径和方法名，属性名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pr.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;ClassName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;MethodName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fieldname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;FieldName&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>使用类的路径名，类名，构造出相应类的Class对象。<ul>
<li><code>Class cls = Class.forName(classname);</code></li>
</ul>
</li>
<li>通过Class类的对象加载类的实例<ul>
<li><code>Object object = cls.newInstance();</code></li>
</ul>
</li>
<li>通过Class类的对象加载对应方法对象<ul>
<li><code>Method cryMethod = cls.getMethod(cry);</code></li>
</ul>
</li>
<li>通过Method的对象调用方法，传入方法对应的实例对象<ul>
<li><code>cryMethod.invoke(object);</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//构造Properties类获取配置文件中的属性</span></span><br><span class="line">   		<span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pr.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;Username&quot;</span>);</span><br><span class="line">        <span class="comment">//加载类，返回Class类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classname);</span><br><span class="line">        <span class="comment">//通过cls得到加载类的实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o的运行类型为=&quot;</span> + o.getClass());</span><br><span class="line">  		<span class="comment">//获得对应方法的对象</span></span><br><span class="line">  		<span class="type">Method</span> <span class="variable">cryMethod</span> <span class="operator">=</span> cls.getMethod(cry);</span><br><span class="line">  		<span class="comment">//调用方法  </span></span><br><span class="line">  		cryMethod.invoke(object);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">Username=com.qn.resd.DouBao</span><br><span class="line">method=cry</span><br></pre></td></tr></table></figure>





<h4 id="反射操作属性"><a href="#反射操作属性" class="headerlink" title="反射操作属性"></a>反射操作属性</h4><blockquote>
<p>无法访问私有属性。</p>
</blockquote>
<blockquote>
<ol>
<li><p>使用Properties类操作配置文件，取出类的路径和方法名，属性名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">pr.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;ClassName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">methodname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;MethodName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fieldname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;FieldName&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>使用类的路径名，类名，构造出相应类的Class对象。<ul>
<li><code>Class cls = Class.forName(classname);</code></li>
</ul>
</li>
<li>通过Class类的对象加载类的实例<ul>
<li><code>Object object = cls.newInstance();</code></li>
</ul>
</li>
<li>通过Class类的对象加载对应属性对象<ul>
<li><code>Field fieldname = cls.getField(&quot;fieldname&quot;);</code></li>
</ul>
</li>
<li>通过Field的对象调用方法，传入方法对应的实例对象<ul>
<li><code>fieldname.get(object);</code></li>
</ul>
</li>
<li>通过Field对象更改属性值<ul>
<li><code>fieldname.get(object,&quot;值&quot;);</code></li>
</ul>
</li>
<li>遍历所有的属性<ul>
<li><code>Field[] fieldname = cls.getFields();</code></li>
<li><code>for(Field f : filelds)&#123; f.getName()&#125;</code></li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//构造Properties类获取配置文件中的属性</span></span><br><span class="line">   		<span class="type">Properties</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pr.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> pr.getProperty(<span class="string">&quot;Username&quot;</span>);</span><br><span class="line">        <span class="comment">//加载类，返回Class类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classname);</span><br><span class="line">        <span class="comment">//通过cls得到加载类的实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o的运行类型为=&quot;</span> + o.getClass());</span><br><span class="line">  		<span class="comment">//通过Class类的对象加载对应属性对象</span></span><br><span class="line">  		<span class="type">Field</span> <span class="variable">fieldname</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;fieldname&quot;</span>);</span><br><span class="line">  		<span class="comment">//通过Method的对象调用方法，传入方法对应的实例对象</span></span><br><span class="line">  		fieldname.get(object);</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">Username=com.qn.resd.DouBao</span><br><span class="line">method=cry</span><br></pre></td></tr></table></figure>



<h4 id="反射机制优化"><a href="#反射机制优化" class="headerlink" title="反射机制优化"></a>反射机制优化</h4><blockquote>
<p>Method和Field,Constructor对象都有setAccessible()方法。</p>
<p>setAccessible作用是启动和禁用访问安全检查的开关。</p>
<p>参数值为true表示反射的对象在使用时取消访问检查，提高反射的效率，参数值未false则表示对反射执行访问检查。(但是效果并不明显)</p>
</blockquote>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><blockquote>
<p>Class类继承Object类。</p>
<p>&#x3D;&#x3D;Class类对象不是new出来的，而是系统创建的。&#x3D;&#x3D;</p>
<p>对于每个类的Class对象，在内存中只有一份，因为类只加载一次。</p>
<p>每个类的实例都会记的自己是哪个Class实例所生成。</p>
<p>通过Class可以完整的得到一个类的完整的结构，通过一系列API。</p>
<p>Class对象是存放在堆中的。</p>
<p>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据。</p>
</blockquote>
<blockquote>
<p>如下类型有Class对象</p>
<ol>
<li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li>
<li>interface ：接口</li>
<li>数组</li>
<li>enum ： 枚举</li>
<li>annottation ： 注解</li>
<li>基本数据类型</li>
<li>void</li>
</ol>
</blockquote>
<blockquote>
<p>获取Class类对象</p>
<ol>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法fotName()获取，可能抛出ClassNotFoundExcepotion </p>
<ul>
<li>多用于配置文件</li>
</ul>
<p><code>Class cls = Class.forName(&quot;java.long.Cat&quot;)</code></p>
</li>
<li><p>前提：已知具体的类，通过类名.class获取，该方式最为安全可靠，程序性能最高。</p>
<ul>
<li>多用于参数传递</li>
</ul>
<p><code>Class cls = Cat.class</code></p>
</li>
<li><p>前提：一直某个类的实例，调用该实例的getClass()方法获取Class对象。也是获得运行类型的方法。</p>
<p><code>Class cls = 对象.getClass();</code></p>
</li>
<li><p>通过类加载器获得类的Class的对象</p>
<p><code>Class cls = classLoader.loadClass(classAllPath)</code></p>
</li>
<li><p>基本数据类型(int,double,char,boolean,long,float,byte,short)可以通过 基本数据类型.class 得到对应的Class类对象。</p>
<p><code>Class cls = 基本数据类型.class</code></p>
</li>
<li><p>基本数据类型对应的包装类，可以通过 包装类.TYPE得到对应的Class类对象</p>
<p><code>Class cls = 包装类.TYPE</code></p>
<p>5和6得到的Class类相同</p>
</li>
</ol>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/class类图.png"></p>
<blockquote>
<p>常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>static Class forName(String name)</td>
<td>返回指定类名的class对象</td>
</tr>
<tr>
<td>getName（）</td>
<td>获取全类名(类名+包名)</td>
</tr>
<tr>
<td>getSimpleName()</td>
<td>获取简单类名(类名)</td>
</tr>
<tr>
<td>getField()</td>
<td>返回所有public修饰的属性，包含本类以及父类的</td>
</tr>
<tr>
<td>getDeclaredField()</td>
<td>返回本类中的所有属性</td>
</tr>
<tr>
<td>getMethod()</td>
<td>获取所有public修饰的方法，包含本类以及父类</td>
</tr>
<tr>
<td>getDeclaredMethod()</td>
<td>获取本类中的所有方法。</td>
</tr>
<tr>
<td>getConstructor()</td>
<td>返回一个包含本类public修饰Constructor对象的数组</td>
</tr>
<tr>
<td>getDeclaredConstructor()</td>
<td>获取本类中的所有构造器</td>
</tr>
<tr>
<td>getPackage()</td>
<td>以package得到类的包名</td>
</tr>
<tr>
<td>Class getSuperClass()</td>
<td>返回当前Class对象的父类Class对象</td>
</tr>
<tr>
<td>Class [] getInterface()</td>
<td>返回当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Class getSuperclass()</td>
<td>返回此Class所表示实体的超类的Class</td>
</tr>
<tr>
<td>getAnnontations()</td>
<td>以Annotation[] 形式返回注释信息</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h4><blockquote>
<p>常用方法：</p>
<ul>
<li>getModifiers()：以int形式返回修饰符<ul>
<li>默认修饰符为 0；public 为 1；private为2;protected为4</li>
<li>static 为8；final为 16</li>
<li>多个修饰符返回相加的值</li>
</ul>
</li>
<li>getType()以Class形式返回类型</li>
<li>getName() 返回属性名</li>
</ul>
</blockquote>
<h4 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h4><blockquote>
<p>常用方法：</p>
<ul>
<li>getModifiers()以int形式返回修饰符<ul>
<li>默认修饰符为 0；public 为 1；private为2;protected为4</li>
<li>static 为8；final为 16</li>
<li>多个修饰符返回相加的值</li>
</ul>
</li>
<li>getRetrunType() : 以Class形式获取返回类型</li>
<li>getName() ： 返回方法名</li>
<li>getParameterType() ： 以Class[]返回参数类型数组</li>
</ul>
</blockquote>
<h4 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h4><blockquote>
<p>常用方法：</p>
<ul>
<li>getModifiers()以int形式返回修饰符<ul>
<li>默认修饰符为 0；public 为 1；private为2;protected为4</li>
<li>static 为8；final为 16</li>
<li>多个修饰符返回相加的值</li>
</ul>
</li>
<li>getName() ： 返回构造器名(全类名)</li>
<li>getParameterTypes (): 以Class[]返回参数类型数组</li>
</ul>
</blockquote>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><blockquote>
<p>反射机制是java动态语言的关键，也就是通过反射实现类的动态加载。</p>
<ol>
<li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强。</li>
<li>动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性。</li>
</ol>
<p>类加载时机：</p>
<ul>
<li>当创建对象时(new)         ————–静态加载</li>
<li>当子类被加载时，父类加载       ————–静态加载</li>
<li>调用类中的静态成员时   ————–静态加载</li>
<li>通过反射     ——-动态加载</li>
</ul>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/类加载.png"></p>
<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="1-类加载"><a href="#1-类加载" class="headerlink" title="1. 类加载"></a>1. 类加载</h4><blockquote>
<p>  JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件，也可能是jar包，甚至网络)转化二进制字节流加载到内存中，并生成一个代表类的java.lang.Class对象。</p>
</blockquote>
<h4 id="2-连接阶段-验证"><a href="#2-连接阶段-验证" class="headerlink" title="2. 连接阶段-验证"></a>2. 连接阶段-验证</h4><blockquote>
<ol>
<li>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li>
<li>包括：文件格式验证(是否以obcafebabe开头)，元数据验证，字节码验证和符号引用验证。</li>
<li>可以考虑使用——Xverify：none参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。</li>
</ol>
</blockquote>
<h4 id="3-连接阶段-准备"><a href="#3-连接阶段-准备" class="headerlink" title="3.连接阶段-准备"></a>3.连接阶段-准备</h4><blockquote>
<ol>
<li>JVM会在该阶段对静态变量，匹配内存并&#x3D;&#x3D;默认初始化&#x3D;&#x3D;(对应数据类型的默认初始值，如0,0L,null,false)。这些变量所使用的内存都将在方法区中进行分配。</li>
<li>只有静态变量才会分配内存，默认初始化。</li>
<li>static final的常量，它和静态变量不同，因为一旦赋值就不变，所以会直接赋值。</li>
</ol>
</blockquote>
<h4 id="3-连接阶段-解析"><a href="#3-连接阶段-解析" class="headerlink" title="3.连接阶段-解析"></a>3.连接阶段-解析</h4><blockquote>
<p> 虚拟机将常量池中的符号引用替换为直接引用的过程。</p>
</blockquote>
<h4 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h4><blockquote>
<ol>
<li>到初始化阶段，才是真正开始执行类中定义的java程序代码。此阶段是执行<clinit>()方法的过程。</clinit></li>
<li><clinit>()方法是由编译器按语句在源文件中出现的顺序，一次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并。</clinit></li>
<li>虚拟机会保证一个类<clinit>()方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只有一个线程回去执行这个类的<clinit>()方法，其他线程都会被阻塞等待，直到活动线程执行<clinit>()方法完成。</clinit></clinit></clinit></li>
</ol>
</blockquote>
<h4 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h4><blockquote>
<p>方式一：调用类中的public修饰的无参构造器</p>
<p>方式二：调用类中的指定构造器</p>
<p>相关方法：</p>
<p>Class类：</p>
<ul>
<li>newInstance() : 调用类中的无参构造器，获取对应的对象。</li>
<li>getConstructor(Class class)根据参数列表，获取对应的public构造器对象</li>
<li>getDecalaredConstructor(Class class):根据参数列表，获取对应的所有构造器对象。</li>
</ul>
<p>Constructor类相关方法。</p>
<ul>
<li>setAccessible 	&#x2F;&#x2F;爆破，使用反射可以访问private的构造器&#x2F;方法&#x2F;属性</li>
<li>newInstance(Object obj):调用构造器</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;com.qn.xc.User&quot;</span>;</span><br><span class="line">        <span class="comment">//1.获取到指定类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过public的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过public的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//先得到对应的构造器，再创建实例</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = aClass.getConstructor(String.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;实参&quot;</span>);</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        <span class="comment">//4.通过非public的有参构造器创建实例</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = aClass.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>); <span class="comment">//爆破，使用反射可以访问private的构造器/方法/属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">11</span>, <span class="string">&quot;形参&quot;</span>);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="通过反射访问类的属性"><a href="#通过反射访问类的属性" class="headerlink" title="通过反射访问类的属性"></a>通过反射访问类的属性</h4><blockquote>
<p>根据属性名获取Field对象  Field f &#x3D; class对象.getDeclaredField(属性名)</p>
<p>爆破：field.setAccessible(true);</p>
<p>操作属性：</p>
<ul>
<li>field.set(o,值);</li>
<li>field.get(o);       &#x2F;&#x2F;表示对象</li>
</ul>
<p>注意：如果是静态属性，则set和get中的参数o可以为：null。</p>
<p>在方法中如果有返回值，一律使用object类型接收。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;com.qn.xc.User&quot;</span>;</span><br><span class="line">       <span class="comment">//1.获取到指定类的Class对象</span></span><br><span class="line">       Class&lt;?&gt; uclass = Class.forName(filePath);</span><br><span class="line"> 	    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> uclass.newInstance();</span><br><span class="line">  		<span class="comment">//2.获取指定类的指定属性</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">fieldName</span> <span class="operator">=</span> uclass.getDeclaredField(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">  		<span class="comment">//3.如果是私有属性可以使用爆破</span></span><br><span class="line">    fieldName.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  		<span class="comment">//4.获得指定对象的指定属性</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> fieldName.get(o);   <span class="comment">//静态属性.get(null)</span></span><br><span class="line">  		<span class="comment">//5.将指定对象的指定属性设置为指定值</span></span><br><span class="line">       fieldName.set(o,<span class="number">22</span>);   <span class="comment">//静态属性.set(null,22)</span></span><br><span class="line">       System.out.println(o1); </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="通过反射访问类的方法"><a href="#通过反射访问类的方法" class="headerlink" title="通过反射访问类的方法"></a>通过反射访问类的方法</h4><blockquote>
<p>根据方法名和参数列表获取Method方法对象：</p>
<ul>
<li>Method m &#x3D; class.getDeclaredMethod(方法名，XX.class);</li>
</ul>
<p>获取对象： Object o &#x3D; class.newInstance();</p>
<p>爆破：m.setAccessible(true)</p>
<p>访问: Object returnValue &#x3D; m.invoke(o,实参列表)；</p>
<p>如果是静态方法，则invoke的参数o可以写成null。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;com.qn.xc.User&quot;</span>;</span><br><span class="line">        <span class="comment">//1.获取到指定类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; uclass = Class.forName(filePath);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> uclass.newInstance();</span><br><span class="line">        <span class="comment">//2.调用普通的public方法。</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">dance1</span> <span class="operator">=</span> uclass.getMethod(<span class="string">&quot;dance1&quot;</span>,String.class);</span><br><span class="line">        dance1.invoke(o,<span class="string">&quot;实参&quot;</span>);</span><br><span class="line">        <span class="comment">//3.调用私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">dance2</span> <span class="operator">=</span> uclass.getDeclaredMethod(<span class="string">&quot;dance2&quot;</span>, String.class);</span><br><span class="line">        dance2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        dance2.invoke(o,<span class="string">&quot;实参&quot;</span>);</span><br><span class="line">        <span class="comment">//4.调用静态方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">dance3</span> <span class="operator">=</span> uclass.getDeclaredMethod(<span class="string">&quot;dance3&quot;</span>, String.class);</span><br><span class="line">        dance3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        dance3.invoke(<span class="literal">null</span>,<span class="string">&quot;形参&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="52-JDBC和连接池"><a href="#52-JDBC和连接池" class="headerlink" title="52. JDBC和连接池"></a>52. JDBC和连接池</h3><blockquote>
<p>JDBC为访问不同的数据库提供的同一的接口，为了使使用者屏蔽细节问题。</p>
<p>使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的操作。</p>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/jdbc图解.png"></p>
<ul>
<li>JDBC使java提供的一套用于操作数据库接口API，java程序员只需要面向这套接口编程即可，不同的数据库厂商，需要针对这套接口提供不同实现。</li>
</ul>
<h4 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h4><blockquote>
<ol>
<li>前置工作：<ul>
<li>将mysql.jar 拷贝到该目录下，点击add to project  加入到项目中</li>
</ul>
</li>
<li>注册驱动  – 加载Driver类<ul>
<li>Driver driver &#x3D; new Driver();</li>
</ul>
</li>
<li>获取连接  – 得到Connection<ul>
<li>String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db01”;    设置连接了协议，连接地址，连接数据库</li>
<li>Properties properties &#x3D; new Properties();</li>
<li>properties.setProperty(“user”,”root”);   设置用户名</li>
<li>properties.setProperty(“password”,”fsc”);  设置密码</li>
<li>Connection connect &#x3D; driver.connect(url, properties);  &#x2F;&#x2F;建立连接</li>
</ul>
</li>
<li>执行增删改查  – 发送sql给mysql执行<ul>
<li>String sql &#x3D; “sql语句”;   &#x2F;&#x2F;设置要执行的sql语句</li>
<li>Statement statement &#x3D; connect.createStatement();  &#x2F;&#x2F;新建执行sql语句的statement对象</li>
<li>int i &#x3D; statement.executeUpdate(sql); &#x2F;&#x2F;执行sql语句得到返回值。如果返回值大于0则是影响的行数</li>
</ul>
</li>
<li>释放资源  – 关闭相关连接<ul>
<li>statement.close();   &#x2F;&#x2F;释放操作对象连接</li>
<li>connect.close();  &#x2F;&#x2F;释放数据库连接</li>
</ul>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//前置工作</span></span><br><span class="line">        <span class="comment">//将mysql.jar 拷贝到该目录下，点解add to project  加入到项目中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.注册驱动</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.得到连接</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   1. jdbc:mysql:// 规定好的协议，通过jdbc的方式连接mysql</span></span><br><span class="line"><span class="comment">        *   2. localhost 主机，数据库所在的IP地址</span></span><br><span class="line"><span class="comment">        *   3. 3306  数据库所占用的端口</span></span><br><span class="line"><span class="comment">        *   4. db01  数据库名字</span></span><br><span class="line"><span class="comment">        *   5. musql的连接本质就是socket连接</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//将用户名和密码放入properties中</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;fsc&quot;</span>);</span><br><span class="line">        <span class="comment">//连接指定数据库</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.执行增删改查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into lzy values(4,&#x27;豆包&#x27;,590,&#x27;rz&#x27;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connect.createStatement();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> statement.executeUpdate(sql);<span class="comment">//返回的是操作影响的行数</span></span><br><span class="line">        System.out.println(i &gt;<span class="number">0</span>?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connect.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h4><blockquote>
<p>使用DriverManager获得与数据库的连接对象</p>
<ul>
<li>getConnection(url,name,password);  &#x2F;&#x2F;输入数据库的url，用户名，密码，获得连接对象。</li>
</ul>
<p>使用Connection对象获得对应数据库的执行对象</p>
<ul>
<li><p>setAutoCommit(false)  &#x2F;&#x2F;关闭事务的自动提交</p>
</li>
<li><p>commit()  &#x2F;&#x2F;手动提交事务</p>
</li>
<li><p>rollback()  &#x2F;&#x2F;手动回滚事务</p>
</li>
<li><p>createrStatement()  &#x2F;&#x2F;创建Statement对象</p>
</li>
<li><p>preparedStement(sql)    &#x2F;&#x2F;创建预处理对象</p>
</li>
</ul>
</blockquote>
<h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><blockquote>
<p>使用Driver对象连接到数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">     <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(); <span class="comment">//创建driver对象</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">     <span class="comment">//将 用户名和密码放入到Properties 对象</span></span><br><span class="line">     <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">     <span class="comment">//说明 user 和 password 是规定好，后面的值根据实际情况写</span></span><br><span class="line">     properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">     properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;fsc&quot;</span>); <span class="comment">//密码</span></span><br><span class="line">     <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">     System.out.println(connect);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><blockquote>
<p>使用反射机制动态加载Driver类，使用反射加载Driver类 , 动态加载，更加的灵活，减少依赖性。</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException &#123;</span><br><span class="line">     <span class="comment">//使用反射加载Driver类 , 动态加载，更加的灵活，减少依赖性</span></span><br><span class="line">     Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">     <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver)aClass.newInstance();</span><br><span class="line"></span><br><span class="line">     <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">     <span class="comment">//将 用户名和密码放入到Properties 对象</span></span><br><span class="line">     <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">     <span class="comment">//说明 user 和 password 是规定好，后面的值根据实际情况写</span></span><br><span class="line">     properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">     properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;fsc&quot;</span>); <span class="comment">//密码</span></span><br><span class="line"></span><br><span class="line">     <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">     System.out.println(<span class="string">&quot;方式2=&quot;</span> + connect);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><blockquote>
<p>使用DriverManager 替代 driver 进行统一管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect03</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//使用反射加载Driver</span></span><br><span class="line">     Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">     <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建url 和 user 和 password</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">     <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">     <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;fsc&quot;</span>;</span><br><span class="line"></span><br><span class="line">     DriverManager.registerDriver(driver);<span class="comment">//注册Driver驱动</span></span><br><span class="line"></span><br><span class="line">     <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">     System.out.println(<span class="string">&quot;第三种方式=&quot;</span> + connection);</span><br><span class="line">		connection，close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="方式四"><a href="#方式四" class="headerlink" title="方式四"></a>方式四</h5><blockquote>
<p>使用Class.forName 自动完成注册驱动，简化代码</p>
<p>当动态加载Driver类时，会执行静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">             &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">     <span class="comment">//使用反射加载了 Driver类</span></span><br><span class="line">     <span class="comment">//在加载 Driver类时，完成注册</span></span><br><span class="line">     Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建url 和 user 和 password</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">     <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">     <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;fsc&quot;</span>;</span><br><span class="line">     <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;第4种方式~ &quot;</span> + connection);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>mysql驱动在5.1.6之后无需 Class.forName(“com.mysql.jdbc.Driver”);从jdk1.5</p>
<p>之后使用了jdbc4</p>
<p>，不需要显示调用 Class.forName()注册驱动，而是自动调用驱动jar包下META-INF\services\java.sql.Driver 文本中的类名称去注册。</p>
</blockquote>
<h5 id="方式五"><a href="#方式五" class="headerlink" title="方式五"></a>方式五</h5><blockquote>
<p>在方式4的基础上改进，增加配置文件，让连接mysql更加灵活</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//通过Properties对象获取配置文件的信息</span></span><br><span class="line">     <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">     properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">     <span class="comment">//获取相关的值</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">     Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">     <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;方式5 &quot;</span> + connection);</span><br><span class="line">     connection.close();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="ResultSet-结果集"><a href="#ResultSet-结果集" class="headerlink" title="ResultSet 结果集"></a>ResultSet 结果集</h4><blockquote>
<p>表示数据库结果集的数据表，通常通过执行数据看查询语句生成。</p>
<p>ResultSet对象保持一个光标指向当前的数据行，&#x3D;&#x3D;最初光标位于第一行之前&#x3D;&#x3D;，next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以在while循环中使用循环遍历结果集。</p>
<p>默认ResultSet对象不可以更新，并且只有一个向前移动的光标，只能从第一行到最后一行迭代一次，可以生成更新不敏感的结果集。</p>
<ul>
<li>ResultSet对象.next()  &#x2F;&#x2F;使光标向下移动一行,如果没有下一行返回false</li>
<li>ResultSet对象.previous()  &#x2F;&#x2F;使光标向上移动一行,如果没有下一行返回false</li>
<li>ResultSet对象.getXxx(索引 || 列名)     &#x2F;&#x2F;获得当前行指定索引或者列名的值</li>
<li>ResultSet对象.getObject(索引 || 列名)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;fsc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from lzy&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ResultSet 是接口</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        System.out.println(resultSet);</span><br><span class="line">        <span class="keyword">while</span>(resultSet.next())&#123;  <span class="comment">//resultSet.next()如果下一行没有数据则返回false</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tal</span> <span class="operator">=</span> resultSet.getInt(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> resultSet.getString(<span class="number">4</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + tal + <span class="string">&quot;\t&quot;</span> + address);</span><br><span class="line">        &#125;</span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><blockquote>
<ol>
<li><p>Statement对象，用于执行静态sql语句并且返回生成的结果对象。</p>
</li>
<li><p>在连接建立后，需要对数据库进行访问，执行命名或者是sql语句，可以通过：</p>
<ul>
<li>Statement [存在sql注入]</li>
<li>PreparedStatement [预处理]</li>
<li>CallableStatement [存储过程]</li>
</ul>
</li>
<li><p>Statement对象执行sql语句存在sql注入的风险。</p>
</li>
<li><p>sql注入是利用某些系统没有对用户输入的数据进行充分的检查，而是用户输入数据种植呼入非法的sql语句段或者命令，恶意攻击数据库。</p>
<ul>
<li>&#96;&#96;&#96;sql<br>&#x2F;&#x2F;输入的用户名： 1’ or<br>&#x2F;&#x2F;输入密码： or ‘1’&#x3D;’1<br>select * from user<br>where name &#x3D; ‘用户名’ and pwd &#x3D; ‘密码’<br>&#x2F;&#x2F;sql注入后<br>‘1’ or  ‘ and pwd &#x3D; ‘or ‘1’&#x3D;’1’  &#x2F;&#x2F;肯定成立<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>   - </p>
<ol start="5">
<li><p>要防止sql主语只需要使用PreparedStatement(从Startement扩展而来)取代Statement就要可以。</p>
<ul>
<li>executeUpdate(sql)  &#x2F;&#x2F;执行修改，添加，删除语句，返回影响的行数</li>
<li>executeQuery(sql)  &#x2F;&#x2F;执行查询语句，返回影响的行数。</li>
<li>execute(sql)  &#x2F;&#x2F;执行任意sql，返回布尔值</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### PreparedStatement</span><br><span class="line"></span><br><span class="line">PreparedStatement执行的sql语句中的参数使用问号(?)来表示，调用PreparedStatement对象的setXXX()方法来设置这些参数。 setXXX()方法有两个参数，第一个参数要设置sql语句中的参数的索引(从1开始)，第二个是设置sql语句中参数的值。</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">String sql = &quot;select count(*) from 表名 where username=？ and  password =？&quot;</span><br></pre></td></tr></table></figure>

<p>调用executeQuery()，返回ResultSet结果集对象(查询)。</p>
<p>调用executeUpdate(),执行更新，包括增加，删除，修改，返回一个int类型，如果大于0返回影响的行数。</p>
<p>预处理：</p>
<ul>
<li>不再使用 + 拼接sql语句，减少语法错误。</li>
<li>有效的解决了sql注入问题。</li>
<li>大大减少了便于次数，效率提高。</li>
</ul>
<p>主要方法：</p>
<ul>
<li>executeUpdate(sql)  &#x2F;&#x2F;执行修改，添加，删除语句，返回影响的行数</li>
<li>executeQuery(sql)  &#x2F;&#x2F;执行查询语句，返回影响的行数。</li>
<li>execute(sql)  &#x2F;&#x2F;执行任意sql，返回布尔值</li>
<li>setXxx(占位符索引,占位符的值)   &#x2F;&#x2F;设置对应占位符的值，解决sql注入</li>
<li>setObject(占位符索引,占位符的值)</li>
</ul>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/prepared.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;fsc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sql语句的？相当于占位符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from lzy where name=? and tal=?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//preparedStatement是实现了PreparedStatement接口的实现类的对象</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>,<span class="string">&quot;lzy&quot;</span>);</span><br><span class="line">        preparedStatement.setInt(<span class="number">2</span>,<span class="number">12121</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tal</span> <span class="operator">=</span> resultSet.getInt(<span class="number">3</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> resultSet.getString(<span class="number">4</span>);</span><br><span class="line">            System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + tal + <span class="string">&quot;\t&quot;</span> + address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="jdbcAPI总结"><a href="#jdbcAPI总结" class="headerlink" title="jdbcAPI总结"></a>jdbcAPI总结</h4><p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/jdbcAPI.png"></p>
<h4 id="JDBCUtile"><a href="#JDBCUtile" class="headerlink" title="JDBCUtile"></a>JDBCUtile</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.doubao.jdbcUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个工具类，完成mysql数据库的的链接和关闭资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//连接数据库的使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\musqljdbc.properties&quot;</span>));</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常。</span></span><br><span class="line">            <span class="comment">//调用者可以选择捕获异常也可以选择默认处理异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得数据库连接</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转换为运行异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set  结果集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statement statement或者statementMarager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection 连接对象</span></span><br><span class="line"><span class="comment">     * 如果需要关闭资源就传入响应对象，否则传入null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet set, Statement statement,Connection connection)</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(set !=<span class="literal">null</span> )&#123;</span><br><span class="line">                set.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(statement != <span class="literal">null</span>)&#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------properties文件---------------------</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/db01</span></span><br><span class="line">name=root</span><br><span class="line">password=fsc</span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>





<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><blockquote>
<p>基本介绍</p>
<ol>
<li>JDBC程序中当一个Connection对象创建时，&#x3D;&#x3D;默认情况下是自动提交事务&#x3D;&#x3D;，每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li>JDBC程序为了让多个sql语句作为一个整体执行，需要使用事务。</li>
<li>调用Connection的setAutoCommit(false)可以取消自动提交事务。</li>
<li>在所有的sql语句都成功执行后，调用commit();方法提交事务。</li>
<li>在其中某个操作失败或出现异常时，调用rollback()方法回滚事务。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//去除连接的自动提交事务</span></span><br><span class="line">            connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from lzy&quot;</span>;</span><br><span class="line">            preparedStatement =connection.prepareStatement(sql);</span><br><span class="line">            resultSet = preparedStatement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">tal</span> <span class="operator">=</span> resultSet.getInt(<span class="number">3</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">like</span> <span class="operator">=</span> resultSet.getString(<span class="number">4</span>);</span><br><span class="line">                System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + tal + <span class="string">&quot;\t&quot;</span> + like);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有出现异常手动提交事务</span></span><br><span class="line">            connection.commit();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            <span class="comment">//如果出现异常回滚事务</span></span><br><span class="line">            connection.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        JDBCUtils.close(resultSet,preparedStatement,connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><blockquote>
<ol>
<li>当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库进行批量处理，通常情况下，批量处理比单独提交处理更有效率。(批量处理可以减少发送sql语句的网络开销)</li>
<li>JDBC的批处理语句包括下面的方法：<ul>
<li>addBatch():  添加需要处理的批处理的sql语句或者参数。</li>
<li>executeBatch():执行需要批量处理的sql语句或者参数。</li>
<li>clearBatch(): 清空批处理包的语句。</li>
</ul>
</li>
<li>&#x3D;&#x3D;JDBC连接mysql时，如果要使用批处理功能，在url中添加批处理功能参数   <code>?rewriteBatchedStatements=true</code>&#x3D;&#x3D;</li>
<li>批处理往往和PreparedStatement一起搭配使用，可以减少编译次数，减少运行次数，运行效率大大提升。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into admin1 values(?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">prepareStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">                prepareStatement.setInt(<span class="number">1</span>,i);</span><br><span class="line">                prepareStatement.setString(<span class="number">2</span>,<span class="string">&quot;lzy&quot;</span>);</span><br><span class="line"></span><br><span class="line">                prepareStatement.addBatch();</span><br><span class="line">                <span class="comment">//如果加入例如1000跳数据就开始执行</span></span><br><span class="line">                <span class="keyword">if</span>((i + <span class="number">1</span>) %<span class="number">1000</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    prepareStatement.executeBatch();</span><br><span class="line">                    prepareStatement.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            JDBCUtils.close(<span class="literal">null</span>,prepareStatement,connection);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/db01?rewriteBatchedStatements=true</span></span><br><span class="line">name=root</span><br><span class="line">password=fsc</span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>



<h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><blockquote>
<ol>
<li>传统的JDBC数据库了使用DriverManager来获取，每次向数据库建立连接的时候都将Connextion加载到内存中，再验证ip地址，用户名和密码，需要数据库连接的时候，就向数据库请求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</li>
<li>每一次数据库连接，使用完成后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄露，最终将导致重启数据库。</li>
<li>传统获取连接的方式，不能控制创建的来连接数量，如果连接过多，也可能倒是内存泄露，mysql崩溃。</li>
<li>解决传统开发中的数据库来连接问题，可以采用数据库连接池技术(connextion pool)</li>
</ol>
<p>数据库连接池机制：</p>
<ul>
<li>预先在缓冲池中放入一定数量的来连接，当需要建立数据库连接时，只需要从”缓冲池“中取出来一个，使用完毕之后再放回去。</li>
<li>数据库连接池负责分配，管理和释放数据库来凝结，它允许应该程序重复使用一个现有的数据库连接，而不是重新建立一个。</li>
<li>当应用程序向连接池请求的连接数超过最大的连接数量时，和这些请求被加到等待队列中。<ul>
<li>从连接池取出连接</li>
<li>使用连接操作mysql数据库</li>
<li>连接放回连接池(该连接可以重复使用)</li>
</ul>
</li>
<li>在数据库连接池技术中close方法不是断掉连接，只是将连接放回连接池</li>
</ul>
</blockquote>
<p>数据库连接池种类</p>
<blockquote>
<ol>
<li>jdbc的数据库连接池使用javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由第三方提供。</li>
<li>C3P0数据库连接池，速度相对较慢，稳定性好。</li>
<li>DBCP数据库连接池，速度相对C3P0较快，但是不稳定。</li>
<li>Proxool数据库连接池，有监控连接池状态的功能，稳定性较C3P0差一些。</li>
<li>BoneCP 数据库连接池，速度快。</li>
<li>Druid(德鲁伊)是阿里提供的数据库连接池集成C3P0，DBCP，Proxool优点于一身的数据库连接池。</li>
</ol>
</blockquote>
<h5 id="c3p0"><a href="#c3p0" class="headerlink" title="c3p0"></a>c3p0</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要引进jar包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, PropertyVetoException, SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 创建一个数据源对象</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">comboPooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        <span class="comment">//2. 通过配置文件mysql.properties 获取相关连接的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\musqljdbc.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//读取相关的属性值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getPoperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="comment">//给数据源 comboPooledDataSource 设置相关的参数</span></span><br><span class="line">        <span class="comment">//注意：连接管理是由 comboPooledDataSource 来管理</span></span><br><span class="line">        comboPooledDataSource.setDriverClass(driver);</span><br><span class="line">        comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">        comboPooledDataSource.setUser(user);</span><br><span class="line">        comboPooledDataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置初始化连接数</span></span><br><span class="line">        comboPooledDataSource.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        comboPooledDataSource.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//测试连接池的效率, 测试对mysql 5000次操作</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> comboPooledDataSource.getConnection(); <span class="comment">//这个方法就是从 DataSource 接口实现的</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;连接OK&quot;);</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//c3p0 5000连接mysql 耗时=391</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c3p0 5000连接mysql 耗时=&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将c3p0提供的c3p0.config.xml</span></span><br><span class="line">    <span class="comment">//该文件指定了连接数据库和连接池的相关参数</span></span><br><span class="line">        <span class="comment">//方式1： 相关参数，在程序中指定user, url , password等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">comboPooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> comboPooledDataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        </span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---------------------------------c3p0.config.xml</span><br><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">&lt;!--   数据源的名称--&gt;</span><br><span class="line">  &lt;named-config name=<span class="string">&quot;hello&quot;</span>&gt; </span><br><span class="line">&lt;!-- 驱动类 --&gt;</span><br><span class="line">  &lt;property name=<span class="string">&quot;driverClass&quot;</span>&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">  &lt;!-- url--&gt;</span><br><span class="line">  	&lt;property name=<span class="string">&quot;jdbcUrl&quot;</span>&gt;jdbc:mysql:<span class="comment">//127.0.0.1:3306/db01&lt;/property&gt;</span></span><br><span class="line">  &lt;!-- 用户名 --&gt;</span><br><span class="line">  		&lt;property name=<span class="string">&quot;user&quot;</span>&gt;root&lt;/property&gt;</span><br><span class="line">  		&lt;!-- 密码 --&gt;</span><br><span class="line">  	&lt;property name=<span class="string">&quot;password&quot;</span>&gt;fsc&lt;/property&gt;</span><br><span class="line">  	&lt;!-- 每次增长的连接数--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;acquireIncrement&quot;</span>&gt;<span class="number">5</span>&lt;/property&gt;</span><br><span class="line">    &lt;!-- 初始的连接数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;initialPoolSize&quot;</span>&gt;<span class="number">10</span>&lt;/property&gt;</span><br><span class="line">    &lt;!-- 最小连接数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;minPoolSize&quot;</span>&gt;<span class="number">5</span>&lt;/property&gt;</span><br><span class="line">   &lt;!-- 最大连接数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxPoolSize&quot;</span>&gt;<span class="number">10</span>&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 可连接的最多的命令对象数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxStatements&quot;</span>&gt;<span class="number">5</span>&lt;/property&gt; </span><br><span class="line">    </span><br><span class="line">    &lt;!-- 每个连接对象可连接的最多的命令对象数 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;<span class="number">2</span>&lt;/property&gt;</span><br><span class="line">  &lt;/named-config&gt;</span><br><span class="line">&lt;/c3p0-config&gt;</span><br></pre></td></tr></table></figure>



<h5 id="Druid-德鲁伊"><a href="#Druid-德鲁伊" class="headerlink" title="Druid(德鲁伊)"></a>Druid(德鲁伊)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//加入druid的jar包，加入项目</span></span><br><span class="line">        <span class="comment">//加入配置文件</span></span><br><span class="line">        <span class="comment">//创建Propertise对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指定参数数据源</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据源连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">------------------------druid.properties</span><br><span class="line">#key=value</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/db01?rewriteBatchedStatements=true</span></span><br><span class="line">#url=jdbc:mysql:<span class="comment">//localhost:3306/db01</span></span><br><span class="line">username=root</span><br><span class="line">password=fsc</span><br><span class="line">#initial connection Size</span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">#min idle connecton size</span><br><span class="line">minIdle=<span class="number">5</span></span><br><span class="line">#max active connection size</span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">#max wait <span class="title function_">time</span> <span class="params">(<span class="number">5000</span> mil seconds)</span></span><br><span class="line">maxWait=<span class="number">5000</span></span><br></pre></td></tr></table></figure>



<h4 id="JDBCUtilsByDruid"><a href="#JDBCUtilsByDruid" class="headerlink" title="JDBCUtilsByDruid"></a>JDBCUtilsByDruid</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.doubao.jdbcUtils;</span><br><span class="line"><span class="comment">//使用druid连接池技术</span></span><br><span class="line"><span class="comment">//需要添加druid配置文件，引入druid的jar包</span></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsByDruid</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在数据库连接池技术中close方法不是断掉连接，只是将连接放回连接池</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set  结果集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> statement statement或者statementMarager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connection 连接对象</span></span><br><span class="line"><span class="comment">     * 如果需要关闭资源就传入响应对象，否则传入null</span></span><br><span class="line"><span class="comment">     * 并不是关闭数据库连接而是将连接放回连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="literal">null</span>) &#123;</span><br><span class="line">                set.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------druid.properties配置文件</span><br><span class="line">  #key=value</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/db01?rewriteBatchedStatements=true</span></span><br><span class="line">#url=jdbc:mysql:<span class="comment">//localhost:3306/db01</span></span><br><span class="line">username=root</span><br><span class="line">password=fsc</span><br><span class="line">#initial connection Size</span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">#min idle connecton size</span><br><span class="line">minIdle=<span class="number">5</span></span><br><span class="line">#max active connection size</span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">#max wait <span class="title function_">time</span> <span class="params">(<span class="number">5000</span> mil seconds)</span></span><br><span class="line">maxWait=<span class="number">5000</span></span><br></pre></td></tr></table></figure>





<h4 id="Apache-—-DBUtils"><a href="#Apache-—-DBUtils" class="headerlink" title="Apache — DBUtils"></a>Apache — DBUtils</h4><blockquote>
<p>基本介绍：</p>
<p>commons-dbutils 是Apache组织提供的一个开源的JDBC工具类库，他是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。</p>
<p>DbUtils</p>
<ol>
<li>QueryRunner类：该类封装了SQL执行，是&#x3D;&#x3D;线程安全的&#x3D;&#x3D;，可以实现增，删，改，查，批处理等操作。</li>
<li>ResultSetHandler接口：该接口用于处理Java.sql.ResultSet,将数据按照要求转换为另一种形式。</li>
</ol>
</blockquote>
<p><img src="/2022/09/01/Java%E5%9F%BA%E7%A1%80/Users/A/Desktop/面试/img/handler类.png"></p>
<blockquote>
<ol>
<li><p>得到指定数据库的连接</p>
<ul>
<li><code>Connection connection = JDBCUtilsByDruid.getConnection();</code></li>
</ul>
</li>
<li><p>引入DBUtils相关的jar包，加入到本项目中.</p>
</li>
<li><p>创建对应表的javaBean类。</p>
</li>
<li><p>创建QueryRunner 对象:</p>
<ul>
<li><code>QueryRunner queryRunner = new QueryRunner();</code></li>
</ul>
</li>
<li><p>执行相关的方法，返回ArrayList结果集</p>
<ul>
<li><p>QueryRunner对象.query(连接对象，sql语句，new BeanListHandler&lt;&gt;(javaBean对象.class)，sql语句中的占位符所代表的值)</p>
</li>
<li><p><code>String sql = &quot;select * from lzy&quot;;                                                     </code>                       <code>List&lt;lzyBean&gt; list = queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(lzyBean.class));</code></p>
</li>
</ul>
</li>
<li><p>关闭连接</p>
<ul>
<li><code>JDBCUtilsByDruid.close(null,null,connection);</code></li>
</ul>
</li>
</ol>
</blockquote>
<h5 id="查询多列对象"><a href="#查询多列对象" class="headerlink" title="查询多列对象"></a>查询多列对象</h5><blockquote>
<p> query(连接对象，sql，new BeanListHandler&lt;&gt;(javaBean对象.class)，1）</p>
<p> new BeanListHandler&lt;&gt;(javaBean对象.class)查询多行多列的返回值，返回的是一个javaBean对象组成的ArrayList数组。</p>
</blockquote>
<blockquote>
<ol>
<li>query()得到resultset,将resultset中的数据添加到相应的javaBean中，再将javaBean对象放入ArrayList数组中。</li>
<li>new BeanListHandler&lt;&gt;(javaBean对象.class),底层使用反射机制，获取javaBean中的属性，将然后进行封装。</li>
<li>传入的sql语句中可以使用<code>？</code> 当作占位符，再query()方法最后传入相应的值，可以传递多个值。sql语句查询到的会传值到javaBean对象，没有查询赋值为null。</li>
<li>底层中得到的Resultset和PreparedStatement的对象会在query中关闭。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2.引入DBUtils相关的jar包，加入到本项目中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建QueryRunner 对象</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 执行相关的方法，返回ArrayList结果集</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from lzy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;lzyBean&gt; list = queryRunner.query(连接对象, sql语句, new BeanListHandler&lt;&gt;(javaBean类.class),占位符对应的值);</span></span><br><span class="line"></span><br><span class="line">        List&lt;lzyBean&gt; list = queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(lzyBean.class));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(lzyBean lzy : list)&#123;</span><br><span class="line">            System.out.println(lzy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>,<span class="literal">null</span>,connection);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="查询单行对象"><a href="#查询单行对象" class="headerlink" title="查询单行对象"></a>查询单行对象</h5><blockquote>
<p>query(连接对象，sql，new BeanHandler&lt;&gt;(javaBean对象.class)，1）</p>
</blockquote>
<blockquote>
<p>使用new BeanHandler&lt;&gt;(javaBean对象.class)查询到单行返回值，只返回一个对应的javaBean对象。</p>
<p>如果没有查询到返回null。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获得数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//创建QueryRunner对象</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from lzy where id=?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行单列查询，返回对应列的javaBean类</span></span><br><span class="line">        <span class="type">lzyBean</span> <span class="variable">lzyBean</span> <span class="operator">=</span> queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(lzyBean.class), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lzyBean);</span><br><span class="line"></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>,<span class="literal">null</span>,connection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="查询单行单列对象"><a href="#查询单行单列对象" class="headerlink" title="查询单行单列对象"></a>查询单行单列对象</h5><blockquote>
<p>query(连接对象，sql，new ScalarHandler()，1）</p>
<p>new ScalarHandler()查询单行单列的一个返回值，返回的是一个object对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获得数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//创建QueryRunner对象</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name from lzy where id=?&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行单行单列查询，返回对应列的javaBean类</span></span><br><span class="line">        <span class="comment">//返回的是一个值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">query</span> <span class="operator">=</span> queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(query);</span><br><span class="line"></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>,<span class="literal">null</span>,connection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="dml操作"><a href="#dml操作" class="headerlink" title="dml操作"></a>dml操作</h5><blockquote>
<p>QueryRunner对象.update(connection,sql语句,sql语句中的占位符代表值……)用来执行dml操作，返回的是影响的行数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获得数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//创建QueryRunner对象</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update lzy set name =? where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">  		<span class="comment">//执行修改操作，返回影响到的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRow</span> <span class="operator">=</span> queryRunner.update(connection,sql,<span class="string">&quot;name&quot;</span>,<span class="number">1</span>)；</span><br><span class="line"></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="DAO-数据访问对象-data-access-object"><a href="#DAO-数据访问对象-data-access-object" class="headerlink" title="DAO 数据访问对象(data access object)"></a>DAO 数据访问对象(data access object)</h4><blockquote>
<p>apache-dbutils + druid 简化了JDBC开发，但是还有不足：</p>
<ol>
<li>SQL语句是固定的，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查。 </li>
<li>对于select操作，如果有返回值，返回类型不能固定，需要使用泛型。</li>
<li>将来的表很多业务需求复杂，不看可能只靠一个Java类来实现。</li>
</ol>
</blockquote>
<blockquote>
<p>通用类被称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作。</p>
<p>在BasicDao的基础上，实现一张表对应一个Dao，更好的完成功能。</p>
</blockquote>
<h4 id="53-正则表达式"><a href="#53-正则表达式" class="headerlink" title="53. 正则表达式"></a>53. 正则表达式</h4><blockquote>
<p>正则表达式(regular expression)是对字符串执行模式匹配的技术。</p>
<p>正则表达式就是使用某种模式去匹配字符串的一个公式，正则表达式在需要编程语言中都被支持。</p>
<p>分组：</p>
<ul>
<li>我们可以用圆括号组成一个比较复杂的匹配模式。那么一个圆括号的部分我们可以看作是一个子表达式&#x2F;一个分组</li>
</ul>
<p>捕获：</p>
<ul>
<li>把正则表达式中子表达式(分组匹配)的内容，保存到内存中以数字编号或者显示命名的组里，方便以后引用，从左到右，以分组的左括号为标志，第一个出现的组号为1，第二个为2，组号0代表整个正则表达式。</li>
</ul>
<p>反向引用：</p>
<ul>
<li>圆括号的内容被捕获后，可以在这个&#x3D;&#x3D;括号后被使用&#x3D;&#x3D;，从而写出一个比较使用的匹配模式，这种引用即可以实在正则表达式内部，也可以是在正则表达式外部，内部反向引用\\分组号，外部反向引用$分组号</li>
</ul>
</blockquote>
<h5 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到字符串中符合正则表达式的子字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String str= <span class="string">&quot;这是被匹配的字符串&quot;</span>;</span><br><span class="line">		</span><br><span class="line">  		<span class="comment">//1.定义相应的正则表达式规则</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regStr</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;3&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//2.创建一个pattern对象，指定正则表达式规则</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建一个匹配器对象</span></span><br><span class="line">        <span class="comment">//匹配器就是按照模式对象到指定的字符串中匹配，找到相应的字符串</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.开始循环匹配，每次执行find函数找到下一个符合正则表达式的值。</span></span><br><span class="line">        <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="Pattern对象"><a href="#Pattern对象" class="headerlink" title="Pattern对象"></a>Pattern对象</h5><blockquote>
<p>pattern对象是一个正则表达式对象，pattern类没有公共构造方法，要创建一个pattern对象。需要调用公共的静态方法，返回一个pattern对象，该方法接收一个正则表达式作为它的第一个参数。</p>
</blockquote>
<blockquote>
<p>Pattern.compile(正则表达式);  &#x2F;&#x2F;返回一个Pattern对象区分大小写</p>
<p>Pattern.compile(正则表达式，Pattern.CASE_INSENSITIVE);  &#x2F;&#x2F;返回一个Pattern对象，不区分大小写</p>
<p>Pattern.matches(正则表达式,匹配字符串);   &#x2F;&#x2F;如果&#x3D;&#x3D;整体匹配&#x3D;&#x3D;成功返回true，否则false</p>
<ul>
<li><p>Pattern.matches(regstr,content);方法底层是封装了创建Matcher类的Pattern，再创建Matcher对象，调用matcher方法。</p>
<ul>
<li>&#96;&#96;&#96;java<br>public static boolean matches(String regex, CharSequence input) {<br>Pattern p &#x3D; Pattern.compile(regex);<br>Matcher m &#x3D; p.matcher(input);<br>return m.matches();<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">//判断字符串是否符合指定正则表达式</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       String content = &quot;ihwiuadodoubaodfaww&quot;;</span><br><span class="line">       String regstr = &quot;.*douba\\w*&quot;;</span><br><span class="line">       boolean matches = Pattern.matches(regstr,content);</span><br><span class="line">       System.out.println(matches);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Matcher对象"><a href="#Matcher对象" class="headerlink" title="Matcher对象"></a>Matcher对象</h5><blockquote>
<p>matcher对象是对输入字符串进行解释和匹配的引擎，和pattern类一样，matcher也没有公共构造方法，你需要调用pattern对象的matcher方法来获得一个matcher对象。</p>
</blockquote>
<blockquote>
<p>Matcher对象.find()</p>
<ol>
<li>如果找到返回true，未找到返回false，多次执行自动迭代。</li>
<li>根据相应的正则表达式规则，匹配指定的字符串。</li>
<li>matcher对象的oldList属性记录为此次找到子字符串的结束索引+1，当下次开始寻找时，会从oldList记录的索引开始寻找。(自动迭代)</li>
<li>找到对应子字符串后，将开始索引记录到matcher对象的int [] groups属性中。使用matcher.group(0)获得整体子字符串。<ul>
<li>groups[0] &#x3D; 子字符串的开始索引</li>
<li>groups[1] &#x3D; 子字符串的结束索引 + 1</li>
</ul>
</li>
<li>如果正则表达式中使用()进行分组，会将分组得到的部分子字符串储存到matcher对象的int [] groups属性中，使用索引2，3进行储存在查询字符串的索引。如果有更多分组以此类推。<ul>
<li>groups[3] &#x3D; 分组的开始索引</li>
<li>groups[4] &#x3D; 分组的结束索引 + 1</li>
</ul>
</li>
</ol>
<p>Matcher对象.group(index)</p>
<ul>
<li>index为0时返回此次寻找到的子字符串整体。</li>
<li>index大于0时，返回指定的第几个分组返回此次找到的部分子字符串。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int start()</td>
<td>返回以前匹配的初始索引</td>
</tr>
<tr>
<td>public int start(int group)</td>
<td>返回再以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td>
</tr>
<tr>
<td>public int end()</td>
<td>返回最后匹配字符之后的偏移量</td>
</tr>
<tr>
<td>public int end(int group)</td>
<td>返回再以前的匹配操作期间，由给定组所捕获的子序列的最后索引</td>
</tr>
<tr>
<td>public boolean lookingAt()</td>
<td>尝试将从区域开头开始的输入序列于该模式匹配</td>
</tr>
<tr>
<td>public boolean find()</td>
<td>尝试查找和该模式匹配的输入序列的下一个子序列</td>
</tr>
<tr>
<td>public boolean find(int start)</td>
<td>重置此匹配器，然后尝试查找匹配该模式，从指定索引开始的的输入序列的的下一个子序列</td>
</tr>
<tr>
<td>public boolean marches()</td>
<td>尝试将整个区域与模式匹配</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Mather appendReplacement(StringBuffer sb,String replacement)</td>
<td>实现非终端添加和替换步骤</td>
</tr>
<tr>
<td>public StringBuffer appendTail(StringBuffer sb)</td>
<td>实现终端添加和替换步骤</td>
</tr>
<tr>
<td>public String replaceAll(String replacement)</td>
<td>替换模式和给定替换字符串匹配的输入序列的每一个子序列</td>
</tr>
<tr>
<td>public String replaceFirst(String replacement)</td>
<td>替换模式与给定替换字符串匹配的输入序列的第一个子序列</td>
</tr>
<tr>
<td>public static String quoteReplacement(String s)</td>
<td>返回指定字符串的字面替换字符串</td>
</tr>
<tr>
<td>public Matcher appendReplacement(StringBuffer sb，String replacement)</td>
<td>实现非终端添加和替换</td>
</tr>
<tr>
<td>public StringBuffer appendTail(StringBuffer sb)</td>
<td>实现终端添加和替换步骤</td>
</tr>
</tbody></table>
<p>全部替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ihwiuadodoubaodfaww&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regstr</span> <span class="operator">=</span> <span class="string">&quot;douba&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regstr);</span><br><span class="line"></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不会修改原来的字符串，而是新创建一个字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;替换字符串&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h5 id="PatternSyntaxException"><a href="#PatternSyntaxException" class="headerlink" title="PatternSyntaxException"></a>PatternSyntaxException</h5><blockquote>
<p>patternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</blockquote>
<h5 id="正则表达式的语法："><a href="#正则表达式的语法：" class="headerlink" title="正则表达式的语法："></a>正则表达式的语法：</h5><blockquote>
<p>正则表达式中有各种不同功能的元字符：</p>
<ul>
<li>限定符</li>
<li>选择匹配符号</li>
<li>分组组合和反向引用符</li>
<li>字符匹配符</li>
<li>定位符</li>
</ul>
</blockquote>
<h6 id="元字符-转义字符"><a href="#元字符-转义字符" class="headerlink" title="元字符-转义字符  \\"></a>元字符-转义字符  \\</h6><blockquote>
<p>在使用正则表达式检索某些特殊字符的时候，需要使用到转移符号，否则检索不到结果，甚至会报错。</p>
<p>&#x3D;&#x3D;java的正则表达式中两个反斜杠代表其他语言中的一个反斜杠&#x3D;&#x3D;</p>
</blockquote>
<h6 id="元字符-字符匹配符号"><a href="#元字符-字符匹配符号" class="headerlink" title="元字符-字符匹配符号"></a>元字符-字符匹配符号</h6><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>实例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>可以接收的字符列表</td>
<td>[abcd]</td>
<td>a,b,c,d中的任意一个字符</td>
</tr>
<tr>
<td>[ ^ ]</td>
<td>不接受的字符列表</td>
<td>[^abcd]</td>
<td>除a,b,c,d中的字符包含数字和特殊符号</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>任意单个大写字母</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了\n之外的任意字符</td>
<td>a..b</td>
<td>以a开头b结尾中间包含任意的两个字符的长度为4的字符串</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字字符 [0-9]</td>
<td>\\d{3}</td>
<td>包含三个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字字符 [^ 0-9 ]</td>
<td>\\D{3}</td>
<td>包含三个非数组的字符串</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配一个数字，大小写字母字符 [0-9a-zA-Z]下划线</td>
<td>\\w{3}</td>
<td>匹配三个数字或者大小写字母组成的字符串</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配非数字，大小写字母字符和下划线 [^0-9a-zA-Z]</td>
<td>\\W{3}</td>
<td>匹配非三个数字或者非大小写字母组成的字符串</td>
</tr>
<tr>
<td>\\s</td>
<td>匹配任何空白字符(空格制表符等)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>\\S</td>
<td>匹配任何非空白字符</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>&#x3D;&#x3D;在[] 中括号中的字符不需要转义直接使用&#x3D;&#x3D;</li>
<li>使用 (?i) 表示后方的字符大小写不敏感<ul>
<li>(?i) abcd     匹配abcd且大小写不敏感</li>
<li>ab(?i) cd     cd大小写不敏感</li>
<li>ab((?i) c)d     c大小写不敏感</li>
</ul>
</li>
</ul>
<h6 id="元字符-选择匹配符"><a href="#元字符-选择匹配符" class="headerlink" title="元字符-选择匹配符"></a>元字符-选择匹配符</h6><blockquote>
<p>在匹配某个字符串的时候具有选择性，即：既可以匹配这个，又可以匹配另一个，可以使用选择匹配符  | 。</p>
<p>|  匹配之前或者之后的表达式，成立一边既可以匹配</p>
<ul>
<li>ab|cd     匹配ab或者cd</li>
</ul>
</blockquote>
<h6 id="元字符-限定符"><a href="#元字符-限定符" class="headerlink" title="元字符-限定符"></a>元字符-限定符</h6><blockquote>
<p>用于只当前面的字符和组合项连续出现多少次。</p>
<p>java的默认匹配机制为贪婪匹配，即尽可能匹配多的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>实例</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>提示字符重复0到多次</td>
<td>(abc)*</td>
<td>仅包含任意个abc的字符串</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>提示字符重复1到多次</td>
<td>(abc)+</td>
<td>仅包含1到多个abc的字符串</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>提示字符重复0到1次</td>
<td>abc?</td>
<td>ab或者abc</td>
<td></td>
</tr>
<tr>
<td>{n}</td>
<td>提示字符重复的次数</td>
<td>[abc]{3}</td>
<td>以abc其中字母组成的长度为3的字符串</td>
<td></td>
</tr>
<tr>
<td>{n,}</td>
<td>至少n次匹配</td>
<td>a{3,}</td>
<td>三个a或者更多组成的字符串</td>
<td></td>
</tr>
<tr>
<td>{n,m}</td>
<td>至少n次匹配但是不多于m次匹配</td>
<td>a{3,6}</td>
<td>三个到六个a组成的字符串</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>？ &#x3D;&#x3D;当此字符紧随任何其他限定符时&#x3D;&#x3D;，匹配模式时非贪心匹配，匹配尽可能短的字符串。默认为贪心模式，匹配尽可能长的字符串。<ul>
<li>o+   &#x2F;&#x2F;尽可能长的匹配o的个数</li>
<li>o+?   &#x2F;&#x2F;只会匹配一个o</li>
</ul>
</li>
</ul>
<h6 id="元字符-定位符"><a href="#元字符-定位符" class="headerlink" title="元字符-定位符"></a>元字符-定位符</h6><blockquote>
<p>定位符，规定要匹配的字符出现的位置，比如在字符串开始还是结束的位置。</p>
</blockquote>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始字符</td>
<td>^[0-9]+[a-z]*</td>
<td>以至少一个数字开头,任意个小写字母组成的字符串</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>指定结束字符</td>
<td>[a-z]$</td>
<td>以小写字母结尾的字符串</td>
<td></td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>dou\\b</td>
<td>字符串的边界指的是字串间有空格，或者目标字符串的结束位置</td>
<td>baodou</td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>dou\\B</td>
<td>匹配到非边界的指定字符</td>
<td>doubao</td>
</tr>
</tbody></table>
<p>分组</p>
<blockquote>
<ul>
<li>(pattern)  非命名捕获，捕获匹配的子字符串，编号为0的第一个捕获时由整个正则表达式模式匹配的文本，其他捕获结构则根据左括号的顺序从1开始自动编号。</li>
<li>(?&lt;name&gt;pattern)  命名捕获。将匹配的子字符串捕获到一个组名或是编号名称中，用于那么的字符串 不能包含任何标点符号，并且不能是以数字开头可以使用单引号代替尖括号 (?’name’)</li>
</ul>
</blockquote>
<p>特殊分组(非捕获)</p>
<blockquote>
<ul>
<li>(?:pattern)  匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储以后使用的匹配，<ul>
<li><code>regstr = &quot; plan(?:t|e) &quot;</code>  &#x2F;&#x2F;捕获 plane或者plant</li>
</ul>
</li>
<li>(?&#x3D;pattern)  是一个非捕获匹配。<ul>
<li><code>regstr = &quot; plan(?=t|e) &quot; </code>    &#x2F;&#x2F;捕获plane或者plant前的plan</li>
</ul>
</li>
<li>(?!pattern) 该表达式匹配不处于pattern的字符串的起始点的搜索字符串，他是一个非捕获匹配。<ul>
<li><code>regstr = &quot; plan(?!t|e) &quot;  </code>   &#x2F;&#x2F;bh不会捕获plane或者plant前的plan，而是捕获其他的plan</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><blockquote>
<p>圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较使用的匹配模式，这种引用即可以实在正则表达式内部，也可以是在正则表达式外部，内部反向引用&#x3D;&#x3D;\\分组号&#x3D;&#x3D;，外部反向引用&#x3D;&#x3D;$分组号&#x3D;&#x3D;</p>
<ul>
<li>String restr &#x3D; ”(\\d)\\1“；</li>
<li>matcher.replaceAll(“$1”);</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;开始的.开开.始.始，我..我..我..我..们们都是孩子子&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">restr1</span> <span class="operator">=</span> <span class="string">&quot;\\.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(restr1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile.matcher(str);</span><br><span class="line">  		<span class="comment">//取出符号点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(str1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">restr2</span> <span class="operator">=</span> <span class="string">&quot;(.)\\1+&quot;</span>;</span><br><span class="line"></span><br><span class="line">        compile = Pattern.compile(restr2);</span><br><span class="line"></span><br><span class="line">        matcher = compile.matcher(str1);</span><br><span class="line">  		<span class="comment">//使用第一个符号替换重复的所有符号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="String类中的正则表达式"><a href="#String类中的正则表达式" class="headerlink" title="String类中的正则表达式"></a>String类中的正则表达式</h6><blockquote>
<p>public String replaceAll(正则表达式,字符串);</p>
<p>&#x2F;&#x2F;使用指定值替换符合正则表达式的字符</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;开始的开始,我们都是孩子。最后的最后,都将称为天使。&quot;</span>;</span><br><span class="line">	<span class="comment">//使用&quot;&quot;替换&quot;，&quot;和&quot;。&quot;</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;。|,&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	System.out.println(replace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>public boolean matches(正则表达式)；</p>
<p>&#x2F;&#x2F;验证一个字符串是否完全符合一个正则表达式（整体匹配）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;开始的开始,我们都是孩子。最后的最后,都将称为天使。&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;^(开始).*\\。&quot;</span>);</span><br><span class="line">    System.out.println(matches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>public  String[] split(正则表达式)；</p>
<p>&#x2F;&#x2F;以符合正则表达式的子字符串分割字符串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;开始的开始,我们都是孩子。最后的最后,都将称为天使。&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以指定正则表达式分割字符串</span></span><br><span class="line">      String[] split = str.split(<span class="string">&quot;,|。&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s:split) &#123;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>






























































































































































<h2 id="二-模式"><a href="#二-模式" class="headerlink" title="二. 模式"></a>二. 模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p>单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能 存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
<p>单例模式：</p>
<ol>
<li>饿汉式<ol>
<li>饿汉式可能创建对象却不使用。可能造成资源浪费</li>
</ol>
</li>
</ol>
<ul>
<li><p>构造器私有化   —- 防止new创建对象</p>
</li>
<li><p>类的内部创建对象</p>
</li>
<li><p>向外暴露一个静态的公共方法，返回对象</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
<ol start="2">
<li>懒汉式</li>
</ol>
<ul>
<li>构造器私有化    —–防止new创建对象</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
<li>代码实现</li>
</ul>
<p>总结：</p>
<ul>
<li><p>二者最主要的区别就是创建对象的时机不同，饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。</p>
</li>
<li><p>饿汉式不存在线程安全问题，懒汉式存在线程安全问题。</p>
</li>
<li><p>懒汉式存在浪费资源的可能。</p>
</li>
</ul>
</blockquote>
<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><blockquote>
<p>使用抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Work</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">do</span><span class="params">()</span>&#123;</span><br><span class="line"> job();</span><br><span class="line"> 其他代码/共用代码；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/01/Java%E5%9F%BA%E7%A1%80/">http://example.com/2022/09/01/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">JaksonBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"><img class="prev-cover" src="https://w.wallhaven.cc/full/wq/wallhaven-wqve97.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">十大排序法（一）</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/14/%E7%AE%80%E5%8D%95%E7%9A%84CRUD%E6%A1%88%E4%BE%8B/"><img class="next-cover" src="https://w.wallhaven.cc/full/wq/wallhaven-wqve97.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">简单的CRUD案例</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://img.wxcha.com/m00/f0/f5/5e3999ad5a8d62188ac5ba8ca32e058f.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/buleOcean"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/buleOcean" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1792876074@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://buleocean.github.io/" target="_blank" title="Blog"><i class="fab fa-algolia"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Jakson的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">Java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java主要特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">Java运行机制及运行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%EF%BC%8CJRE%EF%BC%8CJVM%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">JDK，JRE，JVM简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">java开发注意事项和细节说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-java%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">一,java语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Java%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. Java转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. Java注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1.单行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2.多行注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.文档注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">4.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">boolean类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8A%A0%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 加号的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 基本数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">自动数据类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BAString"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. 基本数据类型转换为String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.8.</span> <span class="toc-text">8. 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">8.1算数运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">8.2关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">8.3 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.8.4.</span> <span class="toc-text">8.4 赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.8.5.</span> <span class="toc-text">8.5 三元运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.3.8.6.</span> <span class="toc-text">8.6 运算符的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.3.8.7.</span> <span class="toc-text">8.7 位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81"><span class="toc-number">1.3.8.8.</span> <span class="toc-text">8.8 原码，反码，补码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.9.</span> <span class="toc-text">9. 键盘输入语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.10.</span> <span class="toc-text">10. 控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.10.1.</span> <span class="toc-text">10.1 顺序控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.10.2.</span> <span class="toc-text">10.2 分支控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.10.3.</span> <span class="toc-text">10.3 循环控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.3.11.</span> <span class="toc-text">11. 跳转控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.12.</span> <span class="toc-text">12. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.12.1.</span> <span class="toc-text">12.1 动态初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.12.2.</span> <span class="toc-text">12.2 静态初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E7%9A%84%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.12.3.</span> <span class="toc-text">12.3 数组赋值的分配机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.13.</span> <span class="toc-text">13 二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.14.</span> <span class="toc-text">14  类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.14.1.</span> <span class="toc-text">14.1 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.14.2.</span> <span class="toc-text">14.2 成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.14.3.</span> <span class="toc-text">14.3 方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.14.4.</span> <span class="toc-text">14.4 可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.3.14.5.</span> <span class="toc-text">14.5 构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.14.6.</span> <span class="toc-text">14.6 this关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E9%80%92%E5%BD%92"><span class="toc-number">1.3.15.</span> <span class="toc-text">15 递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.16.</span> <span class="toc-text">16. 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%8C%85"><span class="toc-number">1.3.17.</span> <span class="toc-text">17. 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.3.18.</span> <span class="toc-text">18. 访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.19.</span> <span class="toc-text">19. 面向对象—封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.20.</span> <span class="toc-text">20. 面向对象—继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.20.1.</span> <span class="toc-text">super关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%87%8D%E5%86%99-override"><span class="toc-number">1.3.21.</span> <span class="toc-text">21. 重写(override)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.22.</span> <span class="toc-text">22.面向对象—多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#22-1-%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.22.1.</span> <span class="toc-text">22.1 方法的多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">1.3.22.2.</span> <span class="toc-text">22.2 对象的多态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-3-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.22.3.</span> <span class="toc-text">22.3 动态绑定机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-4-%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.22.4.</span> <span class="toc-text">22.4 多态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-5-%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.22.5.</span> <span class="toc-text">22.5 多态参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Object%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.23.</span> <span class="toc-text">23. Object类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#23-1-equals-%E4%B8%8E-x3D-x3D"><span class="toc-number">1.3.23.1.</span> <span class="toc-text">23.1 equals()与 &#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-2-hashCode"><span class="toc-number">1.3.23.2.</span> <span class="toc-text">23.2 hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-3-toString"><span class="toc-number">1.3.23.3.</span> <span class="toc-text">23.3 toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-4-finalize"><span class="toc-number">1.3.23.4.</span> <span class="toc-text">23.4 finalize()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95-static"><span class="toc-number">1.3.24.</span> <span class="toc-text">24. 类变量和类方法(static)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-main%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.25.</span> <span class="toc-text">25. main方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.3.26.</span> <span class="toc-text">26.代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.27.</span> <span class="toc-text">29. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.27.1.</span> <span class="toc-text">接口与抽象类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.27.2.</span> <span class="toc-text">接口的多态特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.28.</span> <span class="toc-text">30. 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#30-1-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.28.1.</span> <span class="toc-text">30.1 局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-2-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.28.2.</span> <span class="toc-text">30.2 匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.28.3.</span> <span class="toc-text">30.3 成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.28.4.</span> <span class="toc-text">30.4 静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%9E%9A%E4%B8%BE-eunmeration"><span class="toc-number">1.3.29.</span> <span class="toc-text">31 枚举(eunmeration)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.29.1.</span> <span class="toc-text">31.1 自定义实现枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-2-enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.29.2.</span> <span class="toc-text">31.2 enum关键字实现枚举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.30.</span> <span class="toc-text">31 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-1-Override"><span class="toc-number">1.3.30.1.</span> <span class="toc-text">31.1 @Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-2-Deprecated"><span class="toc-number">1.3.30.2.</span> <span class="toc-text">31.2 @Deprecated</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-3-Suppress-Warnings"><span class="toc-number">1.3.30.3.</span> <span class="toc-text">31.3 @Suppress Warnings</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-4-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.30.4.</span> <span class="toc-text">31.4 元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-1-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.3.30.5.</span> <span class="toc-text">32.1 异常体系图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.30.6.</span> <span class="toc-text">31.2 常见的运行时异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.30.7.</span> <span class="toc-text">31.3 常见的编译异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.3.30.8.</span> <span class="toc-text">31.4 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.30.9.</span> <span class="toc-text">31.5  自定义异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.3.31.</span> <span class="toc-text">32 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32-1-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.31.1.</span> <span class="toc-text">32.1 包装类和基本数据的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-2-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8CString%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E3%80%82"><span class="toc-number">1.3.31.2.</span> <span class="toc-text">32.2 包装类和String数据类型的相互转换。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-String%E7%B1%BB"><span class="toc-number">1.3.32.</span> <span class="toc-text">33. String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#33-1-String%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.32.1.</span> <span class="toc-text">33.1 String创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-2-String%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.3.32.2.</span> <span class="toc-text">33.2 String类的特性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-3-String%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.32.3.</span> <span class="toc-text">33.3 String类的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-StringBuffer"><span class="toc-number">1.3.33.</span> <span class="toc-text">34. StringBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E4%B8%8EStringBuffer%E7%B1%BB%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.33.1.</span> <span class="toc-text">String类与StringBuffer类区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.3.33.2.</span> <span class="toc-text">StringBuffer构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E4%B8%8EStringBuffer%E4%BA%92%E7%9B%B8%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.33.3.</span> <span class="toc-text">String 与StringBuffer互相进行转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.33.4.</span> <span class="toc-text">StringBuffer常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#append-%E5%A2%9E%E5%8A%A0"><span class="toc-number">1.3.33.4.1.</span> <span class="toc-text">append() 增加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete-%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.33.4.2.</span> <span class="toc-text">delete() 删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.33.4.3.</span> <span class="toc-text">replace() 替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#indexOf-str"><span class="toc-number">1.3.33.4.4.</span> <span class="toc-text">indexOf(str)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-start-string-%E6%8F%92%E5%85%A5"><span class="toc-number">1.3.33.4.5.</span> <span class="toc-text">insert(start,string) 插入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-StringBuilder"><span class="toc-number">1.3.34.</span> <span class="toc-text">35. StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#35-1-StringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.34.1.</span> <span class="toc-text">35.1 StringBuilder常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#append-%E5%A2%9E%E5%8A%A0-1"><span class="toc-number">1.3.34.1.1.</span> <span class="toc-text">append() 增加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#delete-%E5%88%A0%E9%99%A4-1"><span class="toc-number">1.3.34.1.2.</span> <span class="toc-text">delete() 删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replace-%E6%9B%BF%E6%8D%A2-1"><span class="toc-number">1.3.34.1.3.</span> <span class="toc-text">replace() 替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#indexOf-str-1"><span class="toc-number">1.3.34.1.4.</span> <span class="toc-text">indexOf(str)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#insert-start-string-%E6%8F%92%E5%85%A5-1"><span class="toc-number">1.3.34.1.5.</span> <span class="toc-text">insert(start,string) 插入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-2-String-%E4%B8%8E-StringBuffer-%E4%B8%8E-StringBuilder%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.34.2.</span> <span class="toc-text">35.2 String 与 StringBuffer 与 StringBuilder的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-3-String-%E4%B8%8E-StringBuffer-%E4%B8%8E-StringBuilder%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.34.3.</span> <span class="toc-text">35.3 String 与 StringBuffer 与 StringBuilder的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-Math"><span class="toc-number">1.3.35.</span> <span class="toc-text">36. Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-Arrays"><span class="toc-number">1.3.36.</span> <span class="toc-text">37. Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#37-1-Arrays%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.36.1.</span> <span class="toc-text">37.1 Arrays常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.3.36.1.1.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sort%E6%8E%92%E5%BA%8F-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.36.1.2.</span> <span class="toc-text">sort排序(自然排序和定制排序)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binarySeach-%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.36.1.3.</span> <span class="toc-text">binarySeach 二分法查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#copyOf-%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6"><span class="toc-number">1.3.36.1.4.</span> <span class="toc-text">copyOf 数组复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fill-%E6%95%B0%E7%BB%84%E5%A1%AB%E5%85%85"><span class="toc-number">1.3.36.1.5.</span> <span class="toc-text">fill 数组填充</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#equals-%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.36.1.6.</span> <span class="toc-text">equals 比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#asList-%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.36.1.7.</span> <span class="toc-text">asList 转换列表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.3.36.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-System"><span class="toc-number">1.3.37.</span> <span class="toc-text">38. System</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#38-1-System%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.37.1.</span> <span class="toc-text">38.1 System常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exit"><span class="toc-number">1.3.37.1.1.</span> <span class="toc-text">exit()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#arraycopy"><span class="toc-number">1.3.37.1.2.</span> <span class="toc-text">arraycopy()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#currentTimeMillens"><span class="toc-number">1.3.37.1.3.</span> <span class="toc-text">currentTimeMillens</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gc"><span class="toc-number">1.3.37.1.4.</span> <span class="toc-text">gc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-BigInteger%E4%B8%8EBigDecimal"><span class="toc-number">1.3.38.</span> <span class="toc-text">39. BigInteger与BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-1-BigInteger"><span class="toc-number">1.3.38.1.</span> <span class="toc-text">39.1 BigInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-2-BigInteger%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.38.2.</span> <span class="toc-text">39.2 BigInteger方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-3-BigDicimal"><span class="toc-number">1.3.38.3.</span> <span class="toc-text">39.3 BigDicimal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-3-BigDicimal%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.38.4.</span> <span class="toc-text">39.3 BigDicimal方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.3.39.</span> <span class="toc-text">40. 日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#40-1-Date"><span class="toc-number">1.3.39.1.</span> <span class="toc-text">40.1 Date</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-2-Calendar%E7%B1%BB"><span class="toc-number">1.3.39.2.</span> <span class="toc-text">40.2 Calendar类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-3-LocalDate%EF%BC%8CLocalTime%EF%BC%8CLocalDateTime"><span class="toc-number">1.3.39.3.</span> <span class="toc-text">40.3 LocalDate，LocalTime，LocalDateTime</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E9%9B%86%E5%90%88"><span class="toc-number">1.3.40.</span> <span class="toc-text">41. 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#41-1-%E9%9B%86%E5%90%88%E7%BB%A7%E6%89%BF%E5%9B%BE"><span class="toc-number">1.3.40.1.</span> <span class="toc-text">41.1 集合继承图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">1.3.40.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-number">1.3.40.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-2-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.40.4.</span> <span class="toc-text">41.2 Collection接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-3-List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.40.5.</span> <span class="toc-text">41.3 List 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-4-ArrayList"><span class="toc-number">1.3.40.6.</span> <span class="toc-text">41.4 ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-5-Vector"><span class="toc-number">1.3.40.7.</span> <span class="toc-text">41.5 Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-6-LinkedList"><span class="toc-number">1.3.40.8.</span> <span class="toc-text">41.6 LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedListCRUD"><span class="toc-number">1.3.40.8.1.</span> <span class="toc-text">LinkedListCRUD</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-7-Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.40.9.</span> <span class="toc-text">41.7 Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.40.9.1.</span> <span class="toc-text">set接口的遍历方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-8-HashSet"><span class="toc-number">1.3.40.10.</span> <span class="toc-text">41.8 HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-11-Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.40.11.</span> <span class="toc-text">41.11 Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#put-%E6%B7%BB%E5%8A%A0"><span class="toc-number">1.3.40.11.1.</span> <span class="toc-text">put() 添加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#map%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.40.11.2.</span> <span class="toc-text">map遍历方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-12-HashMap"><span class="toc-number">1.3.40.12.</span> <span class="toc-text">41.12 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-13-Hashtable"><span class="toc-number">1.3.40.13.</span> <span class="toc-text">41.13 Hashtable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-14-Properties"><span class="toc-number">1.3.40.14.</span> <span class="toc-text">41.14 Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-15-TreeMap"><span class="toc-number">1.3.40.15.</span> <span class="toc-text">41.15 TreeMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-16-%E9%9B%86%E5%90%88%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.40.16.</span> <span class="toc-text">41.16 集合选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.3.41.</span> <span class="toc-text">42. Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#42-1-%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.3.41.1.</span> <span class="toc-text">42.1 排序操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-2-%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.41.2.</span> <span class="toc-text">42.2 查找，替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.3.42.</span> <span class="toc-text">43. 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#43-1-%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.42.1.</span> <span class="toc-text">43.1 泛型使用:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.42.2.</span> <span class="toc-text">43.3 自定义泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.42.3.</span> <span class="toc-text">43.4 自定义泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-5-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.3.42.4.</span> <span class="toc-text">43.5 泛型的继承和通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-JUnit"><span class="toc-number">1.3.43.</span> <span class="toc-text">44. JUnit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-java%E7%BB%98%E5%9B%BE"><span class="toc-number">1.3.44.</span> <span class="toc-text">45. java绘图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%BB%98%E5%9B%BE%E4%BD%93%E7%B3%BB"><span class="toc-number">1.3.44.1.</span> <span class="toc-text">java绘图体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Component%E7%B1%BB"><span class="toc-number">1.3.44.2.</span> <span class="toc-text">Component类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#paint%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.44.3.</span> <span class="toc-text">paint方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Graphics%E7%B1%BB"><span class="toc-number">1.3.44.4.</span> <span class="toc-text">Graphics类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-java%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.45.</span> <span class="toc-text">46. java事件处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.46.</span> <span class="toc-text">47.  多线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#47-1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.46.1.</span> <span class="toc-text">47.1 创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFthread%E7%B1%BB"><span class="toc-number">1.3.46.1.1.</span> <span class="toc-text">继承thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.46.1.2.</span> <span class="toc-text">实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-2-%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.46.2.</span> <span class="toc-text">47.2 调用线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-3-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">1.3.46.3.</span> <span class="toc-text">47.3 线程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-4-%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.46.4.</span> <span class="toc-text">47.4 线程常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.46.5.</span> <span class="toc-text">47.5. 线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-6-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.46.6.</span> <span class="toc-text">47.6. 线程同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%9ASynchronized"><span class="toc-number">1.3.46.6.1.</span> <span class="toc-text">同步方法：Synchronized</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.3.46.6.2.</span> <span class="toc-text">互斥锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-7-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.46.7.</span> <span class="toc-text">47.7. 线程的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-8-%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">1.3.46.8.</span> <span class="toc-text">47.8 释放锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-IO%E6%B5%81"><span class="toc-number">1.3.47.</span> <span class="toc-text">48. IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.3.47.1.</span> <span class="toc-text">File创建文件对象相关构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.47.2.</span> <span class="toc-text">IO流原理及流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">1.3.47.3.</span> <span class="toc-text">InputStream 字节输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.3.47.4.</span> <span class="toc-text">OutputStream 字节输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">1.3.47.5.</span> <span class="toc-text">FileInputStream  文件字节输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.3.47.6.</span> <span class="toc-text">FileOutputStream  文件字节输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader-%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">1.3.47.7.</span> <span class="toc-text">FileReader  文件字符输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWrite-%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.3.47.8.</span> <span class="toc-text">FileWrite  文件字符输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.47.9.</span> <span class="toc-text">节点流和处理流区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedReader-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.3.47.10.</span> <span class="toc-text">BufferedReader 字符输入处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedWriter-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.3.47.11.</span> <span class="toc-text">BufferedWriter 字符输出处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedInputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.3.47.12.</span> <span class="toc-text">BufferedInputStream 字节输入处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedOutputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">1.3.47.13.</span> <span class="toc-text">BufferedOutputStream 字节输出处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectOutputStream"><span class="toc-number">1.3.47.14.</span> <span class="toc-text">ObjectOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectInputStream"><span class="toc-number">1.3.47.15.</span> <span class="toc-text">ObjectInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.3.47.16.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.47.17.</span> <span class="toc-text">转换流定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InputStreamReader-%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">1.3.47.18.</span> <span class="toc-text">InputStreamReader 转换输入流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OutputStreamWriter-%E8%BD%AC%E6%8D%A2%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">1.3.47.19.</span> <span class="toc-text">OutputStreamWriter  转换输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.47.20.</span> <span class="toc-text">打印流定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrintStream-%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">1.3.47.21.</span> <span class="toc-text">PrintStream 字节打印流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrintWriter-%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">1.3.47.22.</span> <span class="toc-text">PrintWriter 字符打印流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties%E7%B1%BB"><span class="toc-number">1.3.47.23.</span> <span class="toc-text">Properties类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteArrayOutputStream"><span class="toc-number">1.3.47.24.</span> <span class="toc-text">ByteArrayOutputStream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.48.</span> <span class="toc-text">49.网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ip%E5%9C%B0-%E5%9D%80%EF%BC%9A"><span class="toc-number">1.3.48.1.</span> <span class="toc-text">ip地 址：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-number">1.3.48.2.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">1.3.48.3.</span> <span class="toc-text">端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.48.4.</span> <span class="toc-text">网络通信协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-number">1.3.48.5.</span> <span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket"><span class="toc-number">1.3.48.6.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.48.7.</span> <span class="toc-text">TCP网络通信编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E5%AD%97%E8%8A%82%E6%B5%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.48.7.1.</span> <span class="toc-text">TCP字节流编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E5%AD%97%E7%AC%A6%E6%B5%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.48.7.2.</span> <span class="toc-text">TCP字符流编程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.48.8.</span> <span class="toc-text">netstat指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.48.9.</span> <span class="toc-text">UDP网络通信编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.49.</span> <span class="toc-text">50. 项目开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E5%8F%8D%E5%B0%84"><span class="toc-number">1.3.50.</span> <span class="toc-text">51. 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-java-reflection-%EF%BC%9A"><span class="toc-number">1.3.50.1.</span> <span class="toc-text">反射机制(java reflection)：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">1.3.50.2.</span> <span class="toc-text">反射机制相关类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.50.3.</span> <span class="toc-text">反射操作对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.50.4.</span> <span class="toc-text">反射操作方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.50.5.</span> <span class="toc-text">反射操作属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.50.6.</span> <span class="toc-text">反射机制优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">1.3.50.7.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Field%E7%B1%BB"><span class="toc-number">1.3.50.8.</span> <span class="toc-text">Field类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Method%E7%B1%BB"><span class="toc-number">1.3.50.9.</span> <span class="toc-text">Method类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Constructor%E7%B1%BB"><span class="toc-number">1.3.50.10.</span> <span class="toc-text">Constructor类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.50.11.</span> <span class="toc-text">类加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-3"><span class="toc-number">1.3.50.12.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.50.13.</span> <span class="toc-text">1. 类加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5-%E9%AA%8C%E8%AF%81"><span class="toc-number">1.3.50.14.</span> <span class="toc-text">2. 连接阶段-验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5-%E5%87%86%E5%A4%87"><span class="toc-number">1.3.50.15.</span> <span class="toc-text">3.连接阶段-准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5-%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.50.16.</span> <span class="toc-text">3.连接阶段-解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.50.17.</span> <span class="toc-text">4. 初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.50.18.</span> <span class="toc-text">通过反射创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.50.19.</span> <span class="toc-text">通过反射访问类的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.50.20.</span> <span class="toc-text">通过反射访问类的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-JDBC%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">1.3.51.</span> <span class="toc-text">52. JDBC和连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.51.1.</span> <span class="toc-text">JDBC程序编写步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A"><span class="toc-number">1.3.51.2.</span> <span class="toc-text">连接数据库：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">1.3.51.2.1.</span> <span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A"><span class="toc-number">1.3.51.2.2.</span> <span class="toc-text">方式二：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-number">1.3.51.2.3.</span> <span class="toc-text">方式三</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E5%9B%9B"><span class="toc-number">1.3.51.2.4.</span> <span class="toc-text">方式四</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%94"><span class="toc-number">1.3.51.2.5.</span> <span class="toc-text">方式五</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ResultSet-%E7%BB%93%E6%9E%9C%E9%9B%86"><span class="toc-number">1.3.51.3.</span> <span class="toc-text">ResultSet 结果集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Statement"><span class="toc-number">1.3.51.4.</span> <span class="toc-text">Statement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdbcAPI%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.51.5.</span> <span class="toc-text">jdbcAPI总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBCUtile"><span class="toc-number">1.3.51.6.</span> <span class="toc-text">JDBCUtile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.51.7.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.3.51.8.</span> <span class="toc-text">批处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">1.3.51.9.</span> <span class="toc-text">数据库连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#c3p0"><span class="toc-number">1.3.51.9.1.</span> <span class="toc-text">c3p0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Druid-%E5%BE%B7%E9%B2%81%E4%BC%8A"><span class="toc-number">1.3.51.9.2.</span> <span class="toc-text">Druid(德鲁伊)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBCUtilsByDruid"><span class="toc-number">1.3.51.10.</span> <span class="toc-text">JDBCUtilsByDruid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Apache-%E2%80%94-DBUtils"><span class="toc-number">1.3.51.11.</span> <span class="toc-text">Apache — DBUtils</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%A4%9A%E5%88%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.51.11.1.</span> <span class="toc-text">查询多列对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%A1%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.51.11.2.</span> <span class="toc-text">查询单行对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8D%95%E8%A1%8C%E5%8D%95%E5%88%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.51.11.3.</span> <span class="toc-text">查询单行单列对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dml%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.51.11.4.</span> <span class="toc-text">dml操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DAO-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1-data-access-object"><span class="toc-number">1.3.51.12.</span> <span class="toc-text">DAO 数据访问对象(data access object)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.51.13.</span> <span class="toc-text">53. 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.51.13.1.</span> <span class="toc-text">使用正则表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pattern%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.51.13.2.</span> <span class="toc-text">Pattern对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Matcher%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.51.13.3.</span> <span class="toc-text">Matcher对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PatternSyntaxException"><span class="toc-number">1.3.51.13.4.</span> <span class="toc-text">PatternSyntaxException</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.51.13.5.</span> <span class="toc-text">正则表达式的语法：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.3.51.13.5.1.</span> <span class="toc-text">元字符-转义字符  \\</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.3.51.13.5.2.</span> <span class="toc-text">元字符-字符匹配符号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="toc-number">1.3.51.13.5.3.</span> <span class="toc-text">元字符-选择匹配符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.3.51.13.5.4.</span> <span class="toc-text">元字符-限定符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="toc-number">1.3.51.13.5.5.</span> <span class="toc-text">元字符-定位符</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.51.13.6.</span> <span class="toc-text">反向引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#String%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.51.13.6.1.</span> <span class="toc-text">String类中的正则表达式</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">二. 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">模板设计模式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/" title="十大排序法（一）"><img src="https://w.wallhaven.cc/full/wq/wallhaven-wqve97.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十大排序法（一）"/></a><div class="content"><a class="title" href="/2022/09/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/" title="十大排序法（一）">十大排序法（一）</a><time datetime="2022-09-03T07:26:59.000Z" title="发表于 2022-09-03 15:26:59">2022-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/01/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2022/09/01/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2022-09-01T10:52:26.000Z" title="发表于 2022-09-01 18:52:26">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/14/%E7%AE%80%E5%8D%95%E7%9A%84CRUD%E6%A1%88%E4%BE%8B/" title="简单的CRUD案例"><img src="https://w.wallhaven.cc/full/wq/wallhaven-wqve97.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="简单的CRUD案例"/></a><div class="content"><a class="title" href="/2022/08/14/%E7%AE%80%E5%8D%95%E7%9A%84CRUD%E6%A1%88%E4%BE%8B/" title="简单的CRUD案例">简单的CRUD案例</a><time datetime="2022-08-14T12:38:18.000Z" title="发表于 2022-08-14 20:38:18">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/14/Spring-Boot-2-%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Spring Boot 2 基础篇学习笔记"><img src="https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot 2 基础篇学习笔记"/></a><div class="content"><a class="title" href="/2022/08/14/Spring-Boot-2-%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Spring Boot 2 基础篇学习笔记">Spring Boot 2 基础篇学习笔记</a><time datetime="2022-08-14T12:37:25.000Z" title="发表于 2022-08-14 20:37:25">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/10/Spring%E9%9B%86%E6%88%90web%E7%8E%AF%E5%A2%83/" title="Spring集成web环境"><img src="https://w.wallhaven.cc/full/z8/wallhaven-z8dg9y.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring集成web环境"/></a><div class="content"><a class="title" href="/2022/08/10/Spring%E9%9B%86%E6%88%90web%E7%8E%AF%E5%A2%83/" title="Spring集成web环境">Spring集成web环境</a><time datetime="2022-08-10T13:54:08.000Z" title="发表于 2022-08-10 21:54:08">2022-08-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By John Doe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴观看我的Blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>